-- Original English Script
-- Script ID: 981aeceb05f7e3143df98c45d81b4a07
-- Created: 2025-10-09T15:01:38.789Z
-- Source: External API
-- Auto-generated by Lua Script Vault

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local PlantingModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/checkurasshole/PetFinderv0.1/refs/heads/main/latch"))()
local BrainrotModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/checkurasshole/PetFinderv0.1/refs/heads/main/watchh"))()

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local Character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = Character:WaitForChild("HumanoidRootPart")

local espEnabled = true
local isPlanting = false
local isRemoving = false

local antiAFKEnabled = true
local antiAFKMethods = {}

local WEBHOOK_URL = ""
local eventDetectorEnabled = false
local ActiveEvents = {}

local function sendWebhook(title, desc, color)
    if WEBHOOK_URL == "" or not eventDetectorEnabled then return end
    spawn(function()
        local success, err = pcall(function()
            request({
                Url = WEBHOOK_URL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode({
                    embeds = {{
                        title = title,
                        description = desc,
                        color = color or 65280,
                        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
                        footer = {
                            text = "Event Notifier"
                        }
                    }}
                })
            })
        end)
        if not success then
            warn("[Webhook Error]", err)
        end
    end)
end

local function getEventInfo(eventName)
    local EventRegistry = ReplicatedStorage:FindFirstChild("Modules") and ReplicatedStorage.Modules:FindFirstChild("Registries") and ReplicatedStorage.Modules.Registries:FindFirstChild("EventRegistry")
    if EventRegistry then
        local info = require(EventRegistry)[eventName]
        if info then
            return info.DisplayName or eventName, info.Description or "No description available"
        end
    end
    return eventName, "Unknown event."
end

local function initEventDetector()
    local EventManager = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("EventManager")
    
    EventManager.EventStarted.OnClientEvent:Connect(function(eventName, duration)
        ActiveEvents[eventName] = duration
        local title, desc = getEventInfo(eventName)
        sendWebhook("ðŸŽ‰ Event Started: " .. title, "**Duration:** " .. tostring(duration) .. "s\n\n" .. desc, 65280)
    end)
    
    EventManager.EventEnded.OnClientEvent:Connect(function(eventName)
        ActiveEvents[eventName] = nil
        local title, desc = getEventInfo(eventName)
        sendWebhook("ðŸ•“ Event Ended: " .. title, desc, 16711680)
    end)
    
    EventManager.SyncronizeEvents.OnClientEvent:Connect(function(events)
        for name, duration in pairs(events) do
            ActiveEvents[name] = duration
        end
        local list = {}
        for n, t in pairs(ActiveEvents) do
            table.insert(list, n .. " (" .. t .. "s)")
        end
        sendWebhook("ðŸ” Events Sync", (#list > 0 and table.concat(list, ", ") or "No active events"), 2552550)
    end)
end

local success, message = PlantingModule.initialize()
if not success then
    Fluent:Notify({
        Title = "Error",
        Content = message,
        Duration = 10
    })
    error(message)
end

PlantingModule.updateAllESP(espEnabled)

local Notification = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Notification")
Notification.OnClientEvent:Connect(function(data)
    if data and data.Text and data.Text:find("Too many plants!") then
        PlantingModule.plantLimitReached = true
        isPlanting = false
        Fluent:Notify({
            Title = "Limit Reached",
            Duration = 5
        })
    end
end)

local function startAntiAFK()
    task.spawn(function()
        antiAFKMethods.mouseMovement = task.spawn(function()
            while antiAFKEnabled do
                if game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton1) == false then
                    local mouse = player:GetMouse()
                    mouse.Move:Connect(function()end)
                end
                task.wait(math.random(10, 20))
            end
        end)
    end)
    
    task.spawn(function()
        antiAFKMethods.jumpSpam = task.spawn(function()
            while antiAFKEnabled do
                if Character and Character:FindFirstChild("Humanoid") then
                    Character.Humanoid:Jump()
                end
                task.wait(math.random(20, 35))
            end
        end)
    end)
    
    task.spawn(function()
        antiAFKMethods.rootPartMovement = task.spawn(function()
            while antiAFKEnabled do
                if humanoidRootPart then
                    local currentPos = humanoidRootPart.Position
                    humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(math.random(-5, 5), 0, math.random(-5, 5))
                    task.wait(0.2)
                    humanoidRootPart.CFrame = CFrame.new(currentPos)
                end
                task.wait(math.random(25, 40))
            end
        end)
    end)
    
    task.spawn(function()
        antiAFKMethods.characterRotation = task.spawn(function()
            while antiAFKEnabled do
                if humanoidRootPart then
                    humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(15), 0)
                end
                task.wait(math.random(15, 30))
            end
        end)
    end)
    
    task.spawn(function()
        antiAFKMethods.remoteInteraction = task.spawn(function()
            while antiAFKEnabled do
                pcall(function()
                    if ReplicatedStorage:FindFirstChild("Remotes") then
                        task.wait(math.random(40, 60))
                    end
                end)
                task.wait(1)
            end
        end)
    end)
end

local function stopAntiAFK()
    for methodName, methodId in pairs(antiAFKMethods) do
        if methodId then
            pcall(function()
                task.cancel(methodId)
            end)
        end
    end
    antiAFKMethods = {}
end

local Window = Fluent:CreateWindow({
    Title = "COMBO_WICK " .. Fluent.Version,
    SubTitle = "Helped By JJHub",
    TabWidth = 160,
    Size = UDim2.fromOffset(430, 360),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})


local Tabs = {
    Discord = Window:AddTab({ Title = "Join Discord!", Icon = "link" }),
    Main = Window:AddTab({ Title = "Main", Icon = "home" }),
    Plant = Window:AddTab({ Title = "Plants", Icon = "leaf" }),
    Seeds = Window:AddTab({ Title = "Seeds", Icon = "sprout" }),
    Remove = Window:AddTab({ Title = "Remove", Icon = "trash-2" }),
    Shop = Window:AddTab({ Title = "Shop", Icon = "shopping-cart" }),
    Events = Window:AddTab({ Title = "Weather Detector", Icon = "zap" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local function notify(title, content, duration)
    Fluent:Notify({
        Title = title,
        Content = content,
        Duration = duration
    })
end

local WebhookInput = Tabs.Events:AddInput("WebhookURL", {
    Title = "Webhook URL",
    Default = "",
    Placeholder = "Paste Discord webhook here",
    Callback = function(Value)
        WEBHOOK_URL = Value
    end
})

local EventDetectorToggle = Tabs.Events:AddToggle("EventDetector", {
    Title = "Weather Detector",
    Default = false,
    Callback = function(Value)
        eventDetectorEnabled = Value
        if Value and WEBHOOK_URL ~= "" then
            pcall(initEventDetector)
            notify("Event Detector", "Enabled", 3)
        elseif Value and WEBHOOK_URL == "" then
            notify("Event Detector", "Add webhook URL first", 3)
            EventDetectorToggle:SetValue(false)
        else
            notify("Event Detector", "Disabled", 3)
        end
    end
})

local AutoFarmSection = Tabs.Main:AddSection("===========================")

local TargetBrainrotDropdown = Tabs.Main:AddDropdown("TargetBrainrot", {
    Title = "Target Brainrot Type",
    Values = {"Godly", "Secret", "Mythic", "Legendary", "Epic", "Rare", "Common"},
    Multi = true,
    Default = {},
    Callback = function(Value)
        BrainrotModule.settings.selectedBrainrotTypes = {}
        for rarity, isSelected in pairs(Value) do
            if isSelected then
                BrainrotModule.settings.selectedBrainrotTypes[rarity] = true
                print("ðŸŽ¯ Selected: " .. rarity)
            end
        end
        if next(BrainrotModule.settings.selectedBrainrotTypes) == nil then
            print("âš ï¸ No rarities selected, will not target any brainrots")
        end
    end
})

local AttackModeDropdown = Tabs.Main:AddDropdown("AttackMode", {
    Title = "Attack Mode",
    Values = {"WeaponAttack"},
    Multi = true,
    Default = {"WeaponAttack"},
    Callback = function(Value)
        for mode, isSelected in pairs(Value) do
            if isSelected then
                BrainrotModule.settings.attackMode = mode
                break
            end
        end
    end
})

local FarmToggle = Tabs.Main:AddToggle("AutoFarm", {
    Title = "Farm Brainrots",
    Default = false,
    Callback = function(Value)
        BrainrotModule.settings.teleportEnabled = Value
        if Value then
            if next(BrainrotModule.settings.selectedBrainrotTypes) == nil then
                notify("Warning", "No brainrot types selected! Please select at least one type.", 5)
                BrainrotModule.settings.teleportEnabled = false
                FarmToggle:SetValue(false)
                return
            end
            BrainrotModule.startMainAttackLoop()
        else
            humanoidRootPart.Anchored = false
            BrainrotModule.currentTarget = nil
        end
    end
})

local AttackSpeedSlider = Tabs.Main:AddSlider("AttackSpeed", {
    Title = "Attack Speed",
    Default = 20,
    Min = 2,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        BrainrotModule.settings.attackSpeed = 0.5 / Value
    end
})

local ESPSection = Tabs.Main:AddSection("===========================")

local ESPRarityDropdown = Tabs.Main:AddDropdown("ESPRarity", {
    Title = "ESP Rarity Filter",
    Values = {"All", "Godly", "Secret", "Mythic", "Legendary", "Epic", "Rare", "None"},
    Multi = false,
    Default = "All",
    Callback = function(Value)
        pcall(function()
            BrainrotModule.settings.espRarityFilter = Value
            if Value == "None" then
                for _, highlight in pairs(BrainrotModule.highlights) do
                    if highlight then highlight:Destroy() end
                end
                BrainrotModule.highlights = {}
            else
                BrainrotModule.updateAllHighlights()
            end
        end)
    end
})

local HighlightToggle = Tabs.Main:AddToggle("HighlightRare", {
    Title = "Enable ESP",
    Default = true,
    Callback = function(Value)
        pcall(function()
            BrainrotModule.settings.highlightRare = Value
            if not Value then
                for _, highlight in pairs(BrainrotModule.highlights) do
                    if highlight then highlight:Destroy() end
                end
                BrainrotModule.highlights = {}
            else
                BrainrotModule.updateAllHighlights()
            end
        end)
    end
})

local BrainrotActionsSection = Tabs.Main:AddSection("===========================")

local PlaceBestBrainrotsButton = Tabs.Main:AddButton({
    Title = "Place Best Brainrots",
    Callback = function()
        local args = {}
        ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("EquipBestBrainrots", 9e9):FireServer(unpack(args))
        notify("Brainrots", "Placed best brainrots!", 3)
    end
})

local autoCollectMoney = false
local collectMoneyInterval = 5

local AutoCollectMoneySlider = Tabs.Main:AddSlider("AutoCollectInterval", {
    Title = "Auto Collect Interval (Seconds)",
    Default = 5,
    Min = 1,
    Max = 60,
    Rounding = 0,
    Callback = function(Value)
        collectMoneyInterval = Value
    end
})

local AutoCollectMoneyToggle = Tabs.Main:AddToggle("AutoCollectMoney", {
    Title = "Collect All Money",
    Default = false,
    Callback = function(Value)
        autoCollectMoney = Value
        if Value then
            task.spawn(function()
                while autoCollectMoney do
                    local args = {}
                    ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("EquipBestBrainrots", 9e9):FireServer(unpack(args))
                    task.wait(collectMoneyInterval)
                end
            end)
        end
    end
})

local PrisonSection = Tabs.Main:AddSection("===========================")

local TeleportPrisonButton = Tabs.Main:AddButton({
    Title = "Teleport to Prison",
    Callback = function()
        local prison = game:GetService("Workspace").ScriptedMap:FindFirstChild("Prison")
        if prison then
            local wantedSign = prison:FindFirstChild("WantedSign")
            if wantedSign then
                humanoidRootPart.CFrame = wantedSign:GetPivot() * CFrame.new(0, 5, 0)
                notify("Prison", "Teleported to prison!", 3)
            end
        end
    end
})

local TurnInButton = Tabs.Main:AddButton({
    Title = "Turn In Brainrot",
    Callback = function()
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Events"):WaitForChild("Prison"):WaitForChild("Interact"):FireServer("TurnIn")
    end
})

local BrainrotManagementSection = Tabs.Main:AddSection("===========================")

local SellAllBrainrotsButton = Tabs.Main:AddButton({
    Title = "Sell All Brainrots",
    Callback = function()
        local args = {
            [3] = true
        }
        ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("ItemSell", 9e9):FireServer(unpack(args))
        notify("Shop", "Sold all brainrots!", 3)
    end
})

local RebirthSection = Tabs.Main:AddSection("===========================")

local AutoRebirthToggle = Tabs.Main:AddToggle("AutoRebirth", {
    Title = "Rebirth",
    Default = false,
    Callback = function(Value)
        BrainrotModule.settings.autoRebirth = Value
        if Value then
            task.spawn(function()
                while BrainrotModule.settings.autoRebirth do
                    local args = {}
                    ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("Rebirth", 9e9):FireServer(unpack(args))
                    task.wait(1)
                end
            end)
        end
    end
})

local RebirthButton = Tabs.Main:AddButton({
    Title = "Rebirth Once",
    Callback = function()
        local args = {}
        ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("Rebirth", 9e9):FireServer(unpack(args))
        notify("Rebirth", "Rebirthed!", 3)
    end
})

Tabs.Plant:AddParagraph({
    Title = "Plant Mode",
    Content = "Select rarities to place."
})

local selectedPlantRarities = {}

local PlantDropdown = Tabs.Plant:AddDropdown("PlantRarityDropdown", {
    Title = "Rarities",
    Values = PlantingModule.rarityOrder,
    Multi = true,
    Default = {},
})

PlantDropdown:OnChanged(function(Values)
    selectedPlantRarities = {}
    for _, rarity in ipairs(PlantingModule.rarityOrder) do
        if Values[rarity] then
            table.insert(selectedPlantRarities, rarity)
        end
    end
end)

local PlantToggle = Tabs.Plant:AddToggle("PlantToggle", {
    Title = "Start Planting",
    Default = false
})

PlantToggle:OnChanged(function(Value)
    if Value then
        if #selectedPlantRarities == 0 then
            Fluent:Notify({
                Title = "No Selection",
                Duration = 3
            })
            PlantToggle:SetValue(false)
            return
        end
        
        if isPlanting then
            Fluent:Notify({
                Title = "Already Running",
                Duration = 3
            })
            PlantToggle:SetValue(false)
            return
        end
        
        PlantingModule.plantLimitReached = false
        isPlanting = true
        
        task.spawn(function()
            local plantsByRarity, _ = PlantingModule.scanBackpack()
            
            local allSelectedPlants = {}
            local totalCount = 0
            
            for _, rarity in ipairs(selectedPlantRarities) do
                if plantsByRarity[rarity] then
                    for _, plant in ipairs(plantsByRarity[rarity]) do
                        table.insert(allSelectedPlants, plant)
                        totalCount = totalCount + 1
                    end
                end
            end
            
            if totalCount == 0 then
                isPlanting = false
                PlantToggle:SetValue(false)
                Fluent:Notify({
                    Title = "No Plants",
                    Duration = 4
                })
                return
            end
            
            local planted = 0
            local skipped = 0
            
            Fluent:Notify({
                Title = "Planting",
                Duration = 3
            })
            
            local plantIndex = 1
            
            for spotIndex = 1, #PlantingModule.allGrassSpots do
                if not PlantToggle.Value then
                    break
                end
                
                if plantIndex > #allSelectedPlants then
                    break
                end
                
                if PlantingModule.plantLimitReached then
                    break
                end
                
                if PlantingModule.isSpotOccupied(spotIndex) then
                    skipped = skipped + 1
                    continue
                end
                
                local spot = PlantingModule.allGrassSpots[spotIndex]
                local plant = allSelectedPlants[plantIndex]
                
                local equipped, newSearchIndex = PlantingModule.findAndEquipTool(plant.tool, PlantingModule.currentSearchIndex)
                PlantingModule.currentSearchIndex = newSearchIndex + 1
                
                if PlantingModule.currentSearchIndex > 10 then
                    PlantingModule.currentSearchIndex = 1
                end
                
                if equipped then
                    task.wait(0.1)
                    
                    local equippedTool = Character:FindFirstChildOfClass("Tool")
                    if equippedTool then
                        local plantId = PlantingModule.getId(equippedTool)
                        
                        if plantId then
                            local success = pcall(function()
                                local args = {{
                                    ID = plantId,
                                    CFrame = spot.part.CFrame,
                                    Item = plant.name,
                                    Floor = spot.part
                                }}
                                ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PlaceItem"):FireServer(unpack(args))
                            end)
                            
                            if success then
                                PlantingModule.markSpotOccupied(spotIndex)
                                planted = planted + 1
                                plantIndex = plantIndex + 1
                            end
                        end
                    end
                    
                    task.wait(0.15)
                else
                    plantIndex = plantIndex + 1
                end
            end
            
            isPlanting = false
            PlantToggle:SetValue(false)
            
            Fluent:Notify({
                Title = PlantingModule.plantLimitReached and "Limit Reached" or "Complete",
                Duration = 5
            })
        end)
    else
        isPlanting = false
    end
end)

Tabs.Seeds:AddParagraph({
    Title = "Seed Mode",
    Content = "Continuous planting."
})

local selectedSeedNames = {}

local allSeedOptions = {}
local allSeedData = {}
local seedRarityOrder = {"Secret", "Godly", "Mythic", "Legendary", "Epic", "Rare"}

for _, rarity in ipairs(seedRarityOrder) do
    for _, seedName in ipairs(PlantingModule.validSeedNames) do
        if PlantingModule.getSeedRarity(seedName) == rarity then
            local label = seedName .. " - " .. rarity
            table.insert(allSeedOptions, label)
            allSeedData[label] = seedName
        end
    end
end

local SeedDropdown = Tabs.Seeds:AddDropdown("SeedNameDropdown", {
    Title = "Seeds",
    Values = allSeedOptions,
    Multi = true,
    Default = {},
})

SeedDropdown:OnChanged(function(Values)
    selectedSeedNames = {}
    for label, _ in pairs(Values) do
        local seedName = allSeedData[label]
        if seedName then
            table.insert(selectedSeedNames, seedName)
        end
    end
end)

local SeedToggle = Tabs.Seeds:AddToggle("SeedToggle", {
    Title = "Start Planting",
    Default = false
})

SeedToggle:OnChanged(function(Value)
    if Value then
        if #selectedSeedNames == 0 then
            Fluent:Notify({
                Title = "No Selection",
                Duration = 3
            })
            SeedToggle:SetValue(false)
            return
        end
        
        if isPlanting then
            Fluent:Notify({
                Title = "Already Running",
                Duration = 3
            })
            SeedToggle:SetValue(false)
            return
        end
        
        PlantingModule.plantLimitReached = false
        isPlanting = true
        
        task.spawn(function()
            local totalPlanted = 0
            local totalSkipped = 0
            
            Fluent:Notify({
                Title = "Planting Seeds",
                Duration = 3
            })
            
            while SeedToggle.Value and isPlanting do
                local plantsByRarity, seedsByName = PlantingModule.scanBackpack()
                
                local allSelectedSeeds = {}
                
                for _, seedName in ipairs(selectedSeedNames) do
                    if seedsByName[seedName] then
                        for _, seed in ipairs(seedsByName[seedName]) do
                            table.insert(allSelectedSeeds, seed)
                        end
                    end
                end
                
                if #allSelectedSeeds == 0 then
                    task.wait(1)
                    continue
                end
                
                local planted = 0
                local skipped = 0
                local seedIndex = 1
                
                for spotIndex = 1, #PlantingModule.allGrassSpots do
                    if not SeedToggle.Value then
                        break
                    end
                    
                    if seedIndex > #allSelectedSeeds then
                        break
                    end
                    
                    if PlantingModule.plantLimitReached then
                        break
                    end
                    
                    if PlantingModule.isSpotOccupied(spotIndex) then
                        skipped = skipped + 1
                        continue
                    end
                    
                    local spot = PlantingModule.allGrassSpots[spotIndex]
                    local seed = allSelectedSeeds[seedIndex]
                    
                    if seed.tool.Parent ~= game:GetService("Players").LocalPlayer:WaitForChild("Backpack") then
                        break
                    end
                    
                    local equipped, newSearchIndex = PlantingModule.findAndEquipTool(seed.tool, PlantingModule.currentSearchIndex)
                    PlantingModule.currentSearchIndex = newSearchIndex + 1
                    
                    if PlantingModule.currentSearchIndex > 10 then
                        PlantingModule.currentSearchIndex = 1
                    end
                    
                    if equipped then
                        task.wait(0.1)
                        
                        local equippedTool = Character:FindFirstChildOfClass("Tool")
                        if equippedTool then
                            local seedId = PlantingModule.getId(equippedTool)
                            
                            if seedId then
                                local success = pcall(function()
                                    local args = {{
                                        ID = seedId,
                                        CFrame = spot.part.CFrame,
                                        Item = seed.name,
                                        Floor = spot.part
                                    }}
                                    ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PlaceItem"):FireServer(unpack(args))
                                end)
                                
                                if success then
                                    PlantingModule.markSpotOccupied(spotIndex)
                                    planted = planted + 1
                                    totalPlanted = totalPlanted + 1
                                    seedIndex = seedIndex + 1
                                end
                            end
                        end
                        
                        task.wait(0.15)
                    else
                        seedIndex = seedIndex + 1
                    end
                end
                
                totalSkipped = totalSkipped + skipped
                
                task.wait(0.5)
                
                if PlantingModule.plantLimitReached or not SeedToggle.Value then
                    break
                end
            end
            
            isPlanting = false
            SeedToggle:SetValue(false)
            
            Fluent:Notify({
                Title = PlantingModule.plantLimitReached and "Limit Reached" or "Complete",
                Duration = 5
            })
        end)
    else
        isPlanting = false
        Fluent:Notify({
            Title = "Stopped",
            Duration = 2
        })
    end
end)

Tabs.Remove:AddParagraph({
    Title = "Remove Mode",
    Content = "Continuous removal."
})

local selectedRemoveRarities = {}

local RemoveDropdown = Tabs.Remove:AddDropdown("RemoveRarityDropdown", {
    Title = "Rarities",
    Values = PlantingModule.rarityOrder,
    Multi = true,
    Default = {},
})

RemoveDropdown:OnChanged(function(Values)
    selectedRemoveRarities = {}
    for rarity, _ in pairs(Values) do
        table.insert(selectedRemoveRarities, rarity)
    end
end)

local RemoveToggle = Tabs.Remove:AddToggle("RemoveToggle", {
    Title = "Start Removing",
    Default = false
})

RemoveToggle:OnChanged(function(Value)
    if Value then
        if isRemoving then
            Fluent:Notify({
                Title = "Already Running",
                Duration = 3
            })
            RemoveToggle:SetValue(false)
            return
        end
        
        isRemoving = true
        
        local removeAllMode = #selectedRemoveRarities == 0
        
        Fluent:Notify({
            Title = "Removing",
            Duration = 3
        })
        
        if removeAllMode then
            PlantingModule.clearOccupiedSpots()
        end
        
        task.spawn(function()
            local totalRemoved = 0
            local checkCount = 0
            
            while RemoveToggle.Value and isRemoving do
                checkCount = checkCount + 1
                
                local removed = PlantingModule.removeAllPlants(selectedRemoveRarities)
                totalRemoved = totalRemoved + removed
                
                task.wait(2)
            end
            
            isRemoving = false
            
            Fluent:Notify({
                Title = "Stopped",
                Duration = 5
            })
        end)
    else
        isRemoving = false
    end
end)

Tabs.Remove:AddButton({
    Title = "Clear All",
    Callback = function()
        PlantingModule.clearOccupiedSpots()
        local removed = PlantingModule.removeAllPlants({})
        Fluent:Notify({
            Title = "Cleared",
            Duration = 5
        })
    end
})

local PlatformSection = Tabs.Shop:AddSection("===========================")

local PlatformSlider = Tabs.Shop:AddSlider("PlatformLevel", {
    Title = "Platform Level (1-30)",
    Default = 1,
    Min = 1,
    Max = 30,
    Rounding = 0,
    Callback = function(Value)
        BrainrotModule.settings.platformLevel = Value
    end
})

local AutoBuyPlatformToggle = Tabs.Shop:AddToggle("AutoBuyPlatform", {
    Title = "Buy Platforms",
    Default = false,
    Callback = function(Value)
        BrainrotModule.settings.autoBuyPlatform = Value
        if Value then
            task.spawn(function()
                while BrainrotModule.settings.autoBuyPlatform do
                    for i = BrainrotModule.settings.platformLevel, 30 do
                        if not BrainrotModule.settings.autoBuyPlatform then break end
                        local args = {
                            [1] = tostring(i)
                        }
                        ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("BuyPlatform", 9e9):FireServer(unpack(args))
                        task.wait(0.5)
                    end
                    task.wait(2)
                end
            end)
        end
    end
})

local BuyPlatformButton = Tabs.Shop:AddButton({
    Title = "Buy Selected Platform",
    Callback = function()
        local args = {
            [1] = tostring(BrainrotModule.settings.platformLevel)
        }
        ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("BuyPlatform", 9e9):FireServer(unpack(args))
        notify("Platform", "Bought platform level " .. BrainrotModule.settings.platformLevel .. "!", 3)
    end
})

local BuyAllPlatformsButton = Tabs.Shop:AddButton({
    Title = "Buy All Platforms (1-30)",
    Callback = function()
        for i = 1, 30 do
            local args = {
                [1] = tostring(i)
            }
            ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("BuyPlatform", 9e9):FireServer(unpack(args))
            task.wait(0.1)
        end
        notify("Platforms", "Bought all platforms 1-30!", 3)
    end
})

local GearSection = Tabs.Shop:AddSection("===========================")

local selectedGears = {}
local autoBuyGear = false

local GearDropdown = Tabs.Shop:AddDropdown("GearSelect", {
    Title = "Select Gear",
    Values = BrainrotModule.gearList,
    Multi = true,
    Default = {},
    Callback = function(Value)
        selectedGears = {}
        for gear, isSelected in pairs(Value) do
            if isSelected then
                table.insert(selectedGears, gear)
            end
        end
    end
})

local AutoBuyGearToggle = Tabs.Shop:AddToggle("AutoBuyGear", {
    Title = "Auto Buy Selected Gear",
    Default = false,
    Callback = function(Value)
        autoBuyGear = Value
        if Value then
            task.spawn(function()
                while autoBuyGear do
                    for _, gearName in ipairs(selectedGears) do
                        if not autoBuyGear then break end
                        local args = {
                            [1] = gearName,
                            [2] = true
                        }
                        ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("BuyGear", 9e9):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

local BuyAllGearsButton = Tabs.Shop:AddButton({
    Title = "Buy All Gears",
    Callback = function()
        for _, gearName in ipairs(BrainrotModule.gearList) do
            local args = {
                [1] = gearName,
                [2] = true
            }
            ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("BuyGear", 9e9):FireServer(unpack(args))
            task.wait(0.1)
        end
    end
})

local SeedsSection = Tabs.Shop:AddSection("===========================")

local selectedSeed = "Sunflower Seed"
local autoBuySeed = false

local SeedDropdown = Tabs.Shop:AddDropdown("SeedSelect", {
    Title = "Select Seed",
    Values = BrainrotModule.seedsList,
    Multi = true,
    Default = {},
    Callback = function(Value)
        for seed, isSelected in pairs(Value) do
            if isSelected then
                selectedSeed = seed
                break
            end
        end
    end
})

local AutoBuySeedToggle = Tabs.Shop:AddToggle("AutoBuySeed", {
    Title = "Auto Buy Selected Seed",
    Default = false,
    Callback = function(Value)
        autoBuySeed = Value
        if Value then
            task.spawn(function()
                while autoBuySeed do
                    local args = {
                        [1] = selectedSeed,
                        [2] = true
                    }
                    ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("BuyItem", 9e9):FireServer(unpack(args))
                    task.wait(0.5)
                end
            end)
        end
    end
})

local BuyAllSeedsButton = Tabs.Shop:AddButton({
    Title = "Buy All Seeds",
    Callback = function()
        for _, seedName in ipairs(BrainrotModule.seedsList) do
            local args = {
                [1] = seedName,
                [2] = true
            }
            ReplicatedStorage:WaitForChild("Remotes", 9e9):WaitForChild("BuyItem", 9e9):FireServer(unpack(args))
            task.wait(0.1)
        end
    end
})

Tabs.Settings:AddParagraph({
    Title = "ESP",
    Content = "Spot visualization."
})

local ESPToggle = Tabs.Settings:AddToggle("ESPToggle", {
    Title = "Enable ESP",
    Default = true
})

ESPToggle:OnChanged(function(Value)
    espEnabled = Value
    PlantingModule.updateAllESP(espEnabled)
end)

local AntiAFKSection = Tabs.Settings:AddSection("===========================")

local AntiAFKToggle = Tabs.Settings:AddToggle("AntiAFKToggle", {
    Title = "Anti-AFK",
    Default = true,
    Callback = function(Value)
        antiAFKEnabled = Value
        if Value then
            startAntiAFK()
            notify("Anti-AFK", "Anti-AFK Enabled", 3)
        else
            stopAntiAFK()
            notify("Anti-AFK", "Anti-AFK Disabled", 3)
        end
    end
})

Tabs.Settings:AddButton({
    Title = "Reset Tracking",
    Callback = function()
        PlantingModule.clearOccupiedSpots()
        PlantingModule.plantLimitReached = false
        Fluent:Notify({
            Title = "Reset",
            Duration = 3
        })
    end
})

Tabs.Discord:AddParagraph({
    Title = "Discord Server",
    Content = "Join our Discord community for updates and support!"
})

Tabs.Discord:AddParagraph({
    Title = "Invite Link",
    Content = "https://discord.gg/BUzsQPEY"
})

Tabs.Discord:AddButton({
    Title = "Copy Discord Link",
    Callback = function()
        local link = "https://discord.gg/BUzsQPEY"
        setclipboard(link)
        notify("Discord", "Link copied to clipboard!", 3)
    end
})

BrainrotModule.initialize(notify)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("COMBO_WICK")
SaveManager:SetFolder("COMBO_WICK/configs")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

SaveManager:LoadAutoloadConfig()

startAntiAFK()

Fluent:Notify({
    Title = "Loaded",
    Duration = 5
})

print("\n=== COMBO_WICK READY ===")
print("Watch the console for debug messages!")