local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local PathfindingService = game:GetService("PathfindingService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Items = workspace:WaitForChild("Items")

local CollectionService = game:GetService("CollectionService")

-- Settings
-- GitHub Script Integration
local GITHUB_SCRIPT_LOADED = false
local TIMER_FINISHED_EXECUTED = false
-- External Script Execution
local EXTERNAL_SCRIPT_URL = "https://raw.githubusercontent.com/checkurasshole/Script/refs/heads/main/injector/delta-injection-core-4089.lua"
local SCRIPT_EXECUTED = false
local FIRST_EXECUTION_CHECK = true
local ALL_PHASES_COMPLETED = false

-- Enhanced Fire Level Tracking (from second script)
local FIRE_LEVELS = {
    {min = 1.19, max = 3.94, minInner = 0.81, maxInner = 2.8, range = 25},
    {min = 1.19, max = 3.94, minInner = 0.81, maxInner = 2.8, range = 35},
    {min = 1.19, max = 4.32, minInner = 0.81, maxInner = 3, range = 45},
    {min = 1.19, max = 4.32, minInner = 0.81, maxInner = 3, range = 50},
    {min = 1.19, max = 5.83, minInner = 0.81, maxInner = 3.4, range = 55},
    {min = 1.19, max = 9.26, minInner = 0.81, maxInner = 5.2, range = 60}
}

local MainFire = nil
local FireData = {}
local isFullyRevealed = false
local currentLevel = 0

local AUTO_FARM_ENABLED = false
local DIAMOND_CHEST_DETECTION = true
local CULTIST_KILLER_ENABLED = false
local cultistKillerConnection
local lastCultistKillTime = 0
local CULTIST_KILL_COOLDOWN = 1 -- 1 second cooldown between kills

-- Anti-Void System (runs automatically in background)
local ANTI_VOID_ENABLED = true
local OrgDestroyHeight = workspace.FallenPartsDestroyHeight
local antivoidloop = nil

-- Diamond Chest Detection
local diamondChestConnection = nil
local diamondChestDetected = false
local diamondChestPosition = nil
local teleportAttemptCount = 0
local maxTeleportAttempts = 3
local lastTeleportAttemptTime = 0
local teleportCooldown = 5 -- Seconds between teleport attempts

-- Fire Level Tracking
 

-- CRITICAL: Add immediate stop flag for log teleportation
local STOP_LOG_COLLECTION = false

-- Fallback positions when no trees are found
local FALLBACK_POSITIONS = {
    CFrame.new(123.113708, 1.03243303, -328.113556, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    CFrame.new(245.338486, -8.13047695, -202.074432, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    CFrame.new(230.796982, -2.93100095, 40.3914032, 0, 0, 1, 0, 1, -0, -1, 0, 0)
}
local currentFallbackIndex = 1

-- Fog clearing variables
local stopTweening = false
local visitedParts = {}
local fogClearingComplete = false

-- Map unlock variables
local stopMapUnlocking = false
local mapUnlockVisitedParts = {}

-- Stronghold Sign Timer Tracking
local strongholdTimerActive = false
local lastBodyText = ""
local lastLevelText = ""

-- Weapon persistence tracking
local axeEquipped = false
local lastEquipTime = 0

-- Children collection tracking
local childrenCollectionComplete = false
local childCollectionAttempts = 0
local maxChildCollectionAttempts = 3

-- Enhanced Pathfinding Functions for Diamond Chest
local function getPos(obj)
    if not obj then return nil end
    if obj:IsA("BasePart") then
        return obj.Position
    elseif obj:IsA("Model") then
        if obj.PrimaryPart then return obj.PrimaryPart.Position end
        local part = obj:FindFirstChildWhichIsA("BasePart")
        return part and part.Position or obj:GetPivot().Position
    end
end

local function killCultistsOnce()
    local damaged = 0
    local targetNPCs = {"Cultist", "Crossbow Cultist"}
    
    -- Find a weapon in inventory
    for _, weapon in pairs(LocalPlayer:WaitForChild("Inventory"):GetChildren()) do
        if string.find(string.lower(weapon.Name), "axe") or 
           string.find(string.lower(weapon.Name), "sword") or 
           string.find(string.lower(weapon.Name), "spear") then
            
            -- Search in workspace Characters
            if workspace:FindFirstChild("Characters") then
                for _, enemy in pairs(workspace.Characters:GetChildren()) do
                    if enemy ~= LocalPlayer.Character then
                        for _, targetName in pairs(targetNPCs) do
                            if enemy.Name == targetName then
                                task.spawn(function()
                                    pcall(function()
                                        ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(
                                            enemy, weapon, "1_" .. LocalPlayer.UserId, HumanoidRootPart.CFrame
                                        )
                                        damaged = damaged + 1
                                    end)
                                end)
                                break
                            end
                        end
                    end
                end
            end
            
            -- Also search in Map descendants
            if workspace:FindFirstChild("Map") then
                for _, enemy in pairs(workspace.Map:GetDescendants()) do
                    if enemy:IsA("Model") and enemy ~= LocalPlayer.Character then
                        for _, targetName in pairs(targetNPCs) do
                            if enemy.Name == targetName then
                                task.spawn(function()
                                    pcall(function()
                                        ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(
                                            enemy, weapon, "1_" .. LocalPlayer.UserId, HumanoidRootPart.CFrame
                                        )
                                        damaged = damaged + 1
                                    end)
                                end)
                                break
                            end
                        end
                    end
                end
            end
            
            -- Search in workspace root for any Cultist models
            for _, enemy in pairs(workspace:GetChildren()) do
                if enemy:IsA("Model") and enemy ~= LocalPlayer.Character then
                    for _, targetName in pairs(targetNPCs) do
                        if enemy.Name == targetName then
                            task.spawn(function()
                                pcall(function()
                                    ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(
                                        enemy, weapon, "1_" .. LocalPlayer.UserId, HumanoidRootPart.CFrame
                                    )
                                    damaged = damaged + 1
                                end)
                            end)
                            break
                        end
                    end
                end
            end
            
            break
        end
    end
    
    return damaged
end

local function setupCultistKiller()
    if cultistKillerConnection then
        cultistKillerConnection:Disconnect()
    end
    
    if not CULTIST_KILLER_ENABLED then
        return
    end
    
    cultistKillerConnection = RunService.Heartbeat:Connect(function()
        if CULTIST_KILLER_ENABLED and tick() - lastCultistKillTime >= CULTIST_KILL_COOLDOWN then
            local damaged = killCultistsOnce()
            if damaged > 0 then
                lastCultistKillTime = tick()
            end
        end
    end)
end

-- Execute external script
local function executeExternalScript()
    if SCRIPT_EXECUTED then return end
    
    SCRIPT_EXECUTED = true
    
    Fluent:Notify({
        Title = "Executing External Script",
        Content = "Fire is fully upgraded - loading external script...",
        Duration = 5
    })
    
    task.spawn(function()
        local success, result = pcall(function()
            return loadstring(game:HttpGet(EXTERNAL_SCRIPT_URL))()
        end)
        
        if success then
            Fluent:Notify({
                Title = "External Script Loaded",
                Content = "Successfully loaded external script",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Script Load Failed",
                Content = "Failed to load external script: " .. tostring(result),
                Duration = 5
            })
        end
    end)
end

local function executeDiamondChestSequence()
    pcall(function()
        -- Set walkspeed for the sequence
        local humanoid = Character:WaitForChild("Humanoid")
        humanoid.WalkSpeed = 50

        -- Enable noclip at start
        local function enableNoclip()
            for _, part in pairs(Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end

        local function disableNoclip()
            for _, part in pairs(Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end

        enableNoclip()

        -- STEP 1: Set up metatable hook to listen for RequestOpenItemChest
        local chestRequestDetected = false
        local hookConnection = nil

        -- Set up the hook properly
        if getrawmetatable then
            local mt = getrawmetatable(game)
            if mt and mt.__namecall then
                local oldNamecall = mt.__namecall
                if setreadonly then setreadonly(mt, false) end

                mt.__namecall = function(self, ...)
                    local method = getnamecallmethod and getnamecallmethod() or ""
                    local args = {...}

                    if method == "FireServer" and tostring(self):find("RequestOpenItemChest") then
                        print("RequestOpenItemChest fired with:", unpack(args))
                        chestRequestDetected = true
                    end

                    return oldNamecall(self, ...)
                end

                if setreadonly then setreadonly(mt, true) end

                -- Function to restore metatable
                local function restoreMetatable()
                    if setreadonly then setreadonly(mt, false) end
                    mt.__namecall = oldNamecall
                    if setreadonly then setreadonly(mt, true) end
                end

                -- Set up automatic restoration after 30 seconds
                task.spawn(function()
                    task.wait(30)
                    if not chestRequestDetected then
                        restoreMetatable()
                    end
                end)
            end
        end

        -- STEP 2: Fire the specific diamond chest proximity prompt
        local strongholdChest = workspace.Items:FindFirstChild("Stronghold Diamond Chest")
        if strongholdChest then
            local proximityPrompt = strongholdChest.Main.ProximityAttachment.ProximityInteraction

            if proximityPrompt and proximityPrompt:IsA("ProximityPrompt") then
                Fluent:Notify({
                    Title = "Firing Diamond Chest Proximity Prompt",
                    Content = "Found and firing the diamond chest proximity prompt...",
                    Duration = 3
                })

                -- Make it instant and fire it
                proximityPrompt.HoldDuration = 0
                proximityPrompt.RequiresLineOfSight = false
                proximityPrompt.MaxActivationDistance = math.huge

                if fireproximityprompt then
                    fireproximityprompt(proximityPrompt)
                else
                    -- Fallback method
                    proximityPrompt:InputHoldBegin()
                    proximityPrompt:InputHoldEnd()
                end
            else
                Fluent:Notify({
                    Title = "Proximity Prompt Not Found",
                    Content = "Could not find the diamond chest proximity prompt",
                    Duration = 3
                })
            end
        else
            Fluent:Notify({
                Title = "Diamond Chest Not Found",
                Content = "Could not find the Stronghold Diamond Chest",
                Duration = 3
            })
        end

        -- Wait to see if the metatable hook detects anything
        task.wait(3)

        if chestRequestDetected then
            Fluent:Notify({
                Title = "Chest Request Detected!",
                Content = "RequestOpenItemChest was fired - stopping execution as requested",
                Duration = 5
            })

            -- Clean up proximity prompt connection
            if PromptButtonHoldBegan then
                PromptButtonHoldBegan:Disconnect()
            end

            disableNoclip()
            return -- STOP EXECUTION HERE
        end

        -- STEP 3: If no chest request detected, run the gate monitoring script
        Fluent:Notify({
            Title = "No Chest Request Detected",
            Content = "Running gate monitoring script and proceeding with shelf sequence...",
            Duration = 3
        })

        -- Gate monitoring script with enhanced gate opening detection
        local gate = workspace.Map.Landmarks.Stronghold.Functional.FinalGate

        -- Store original Y if it doesn't exist yet  
        if not gate:GetAttribute("OriginalY") then
            gate:SetAttribute("OriginalY", gate.WorldPivot.Y)
        end

        local lastState -- keeps track of previous state
        local gateOpenedDetected = false

        local gateMonitorConnection = task.spawn(function()
            while true do
                local originalY = gate:GetAttribute("OriginalY")
                local currentY = gate.WorldPivot.Y
                local state

                if currentY > originalY then
                    state = "OPEN"
                    if lastState ~= "OPEN" then
                        gateOpenedDetected = true

                        Fluent:Notify({
                            Title = "GATE OPENED DETECTED!",
                            Content = "Gate has opened! Stopping cultist killer and preparing chest interaction...",
                            Duration = 5
                        })

                        -- Turn off cultist killer completely when gate opens
                        CULTIST_KILLER_ENABLED = false
                        if cultistKillerConnection then
                            cultistKillerConnection:Disconnect()
                            cultistKillerConnection = nil
                        end

                        -- Wait 3-4 seconds then fire proximity prompt again
                        task.wait(4)

                        Fluent:Notify({
                            Title = "Re-firing Chest Proximity",
                            Content = "Gate is open, attempting chest interaction again...",
                            Duration = 3
                        })

                        -- Fire proximity prompt again
                        local strongholdChest = workspace.Items:FindFirstChild("Stronghold Diamond Chest")
                        if strongholdChest then
                            local proximityPrompt = strongholdChest.Main.ProximityAttachment.ProximityInteraction

                            if proximityPrompt and proximityPrompt:IsA("ProximityPrompt") then
                                proximityPrompt.HoldDuration = 0
                                proximityPrompt.RequiresLineOfSight = false
                                proximityPrompt.MaxActivationDistance = math.huge

                                if fireproximityprompt then
                                    fireproximityprompt(proximityPrompt)
                                else
                                    proximityPrompt:InputHoldBegin()
                                    proximityPrompt:InputHoldEnd()
                                end
                            end
                        end

                        -- Collect diamonds after gate opens
                        task.wait(1)

                        for attempt = 1, 3 do
                            Fluent:Notify({
                                Title = "Gate Open Diamond Collection " .. attempt,
                                Content = "Collecting diamonds after gate opened...",
                                Duration = 2
                            })

                            for _, item in pairs(workspace.Items:GetChildren()) do
                                pcall(function()
                                    require(LocalPlayer.PlayerScripts.Client).Events.RequestTakeDiamonds:FireServer(item)
                                end)
                            end

                            task.wait(1)
                        end
                    end
                else
                    state = "CLOSED"
                end

                -- Only print when the state changes
                if state ~= lastState then
                    print("Gate is " .. state .. " at Y:", currentY)
                    lastState = state
                end

                task.wait(5) -- check every 5 seconds
            end
        end)

        -- STEP 4: Continue with shelf pathfinding sequence
        -- Proper BodyVelocity pathfinding that follows waypoints
        local function MoveToPosition(root, targetPos)
            local path = PathfindingService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 5,
                AgentCanJump = true,
                AgentCanClimb = false
            })

            path:ComputeAsync(root.Position, targetPos)

            if path.Status ~= Enum.PathStatus.Success then
                return false
            end

            local waypoints = path:GetWaypoints()
            local currentIndex = 1

            local bv = Instance.new("BodyVelocity")
            bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
            bv.Velocity = Vector3.zero
            bv.Parent = root

            local conn
            conn = RunService.Heartbeat:Connect(function()
                if not bv.Parent or currentIndex > #waypoints then
                    if bv.Parent then bv:Destroy() end
                    if conn then conn:Disconnect() end
                    return
                end

                local wp = waypoints[currentIndex]
                local direction = wp.Position - root.Position
                local distance = direction.Magnitude

                if distance < 4 then
                    currentIndex = currentIndex + 1
                else
                    bv.Velocity = direction.Unit * 100
                end
            end)

            return true
        end

        -- Simplified pathTo function
        local function pathTo(pos)
            if not pos then return false end
            return MoveToPosition(HumanoidRootPart, pos)
        end

        local decoration = workspace.Map.Landmarks.Stronghold.Building.Interior:WaitForChild("Decoration")
        local barrel = decoration:FindFirstChild("Barrel") or decoration:GetChildren()[27]
        local barrelPos = getPos(barrel)

        if barrelPos then
            HumanoidRootPart.CFrame = CFrame.new(barrelPos + Vector3.new(0, 3, 0))
            task.wait(1)
        end

        local shelf = decoration:FindFirstChild("Shelf")
        local shelfPos = getPos(shelf)

        if shelfPos then
            local offsets = {
                Vector3.new(0,0,5), Vector3.new(5,0,0), Vector3.new(-5,0,0),
                Vector3.new(0,0,-5), Vector3.new(3,0,3), Vector3.new(-3,0,3)
            }
            for _, offset in ipairs(offsets) do
                if pathTo(shelfPos + offset) then 
                    -- Wait for arrival and check if we're close to shelf
                    task.wait(2)
                    local currentDistance = (HumanoidRootPart.Position - shelfPos).Magnitude
                    if currentDistance <= 10 then
                        print("âœ… Successfully reached the shelf! Distance: " .. math.floor(currentDistance))
                        break
                    else
                        print("âŒ Failed to reach shelf, trying next position...")
                    end
                end
                task.wait(1)
            end

            -- Final check after all attempts
            local finalDistance = (HumanoidRootPart.Position - shelfPos).Magnitude
            if finalDistance <= 10 then
                print("ðŸŽ‰ SHELF REACHED SUCCESSFULLY!")

                -- START CULTIST KILLER AFTER SUCCESSFUL SHELF REACH
                CULTIST_KILLER_ENABLED = true
                setupCultistKiller()

                Fluent:Notify({
                    Title = "Cultist Killer Activated", 
                    Content = "Auto killing cultists after successful shelf reach",
                    Duration = 3
                })
            else
                print("âš ï¸ Could not reach shelf. Final distance: " .. math.floor(finalDistance))
            end
        end

        task.wait(1)

        -- Collect all diamond items
        for _, item in pairs(workspace.Items:GetChildren()) do
            require(LocalPlayer.PlayerScripts.Client).Events.RequestTakeDiamonds:FireServer(item)
        end

        task.wait(1)

        -- Disable noclip when done
        disableNoclip()
    end)
end

local function MoveDirect(root, targetPos)
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Velocity = Vector3.zero
    bv.Parent = root

    local conn
    conn = RunService.Heartbeat:Connect(function()
        if not bv.Parent then
            conn:Disconnect()
            return
        end

        local direction = targetPos - root.Position
        local dist = direction.Magnitude

        if dist < 5 then
            bv:Destroy()
            conn:Disconnect()
        else
            bv.Velocity = direction.Unit * 42
        end
    end)
end

local function MoveToBase(root, targetPos)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = false
    })
    path:ComputeAsync(root.Position, targetPos)

    if path.Status ~= Enum.PathStatus.Success then
        return MoveDirect(root, targetPos)
    end

    local waypoints = path:GetWaypoints()
    local currentIndex = 1

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Velocity = Vector3.zero
    bv.Parent = root

    local conn
    conn = RunService.Heartbeat:Connect(function()
        if not bv.Parent or currentIndex > #waypoints then
            bv:Destroy()
            conn:Disconnect()
            return
        end

        local wp = waypoints[currentIndex]
        local direction = wp.Position - root.Position
        local dist = direction.Magnitude

        if dist < 3 then
            currentIndex += 1
        else
            bv.Velocity = direction.Unit * 42
        end
    end)
end

local function pathTo(pos)
    if not pos then return false end
    MoveToBase(HumanoidRootPart, pos)
    return true
end

-- Replace the existing initializeStrongholdTracking() function with this modified version
local function initializeStrongholdTracking()
    pcall(function()
        -- Enhanced Stronghold Data Storage
        local EnhancedStrongholdsData = {}
        local StrongholdConnections = {}
        local StrongholdUpdateConnection = nil
        
        -- Stronghold Colors from second script
        local STRONGHOLD_COLORS = {
            Color3.fromRGB(195, 255, 0), -- Level 1 - Bright Green
            Color3.fromRGB(255, 238, 0), -- Level 2 - Yellow
            Color3.fromRGB(255, 157, 0), -- Level 3 - Orange
            Color3.fromRGB(255, 64, 0),  -- Level 4 - Red-Orange
            Color3.fromRGB(255, 0, 0)    -- Level 5+ - Red
        }
        
        -- Enhanced time formatting
        local function formatTime(seconds)
            if seconds <= 60 then
                return string.format("%02ds", math.floor(seconds))
            else
                local minutes = math.floor(seconds / 60)
                local secs = math.floor(seconds % 60)
                return string.format("%02dm %02ds", minutes, secs)
            end
        end
        
        -- MODIFIED: Function to load GitHub script instead of teleporting
        local function loadGitHubScriptInstead()
            if SCRIPT_EXECUTED then 
                Fluent:Notify({
                    Title = "Script Already Loaded",
                    Content = "GitHub script was already executed previously",
                    Duration = 3
                })
                return 
            end
            
            SCRIPT_EXECUTED = true
            
            Fluent:Notify({
                Title = "Loading GitHub Script Instead of Teleporting",
                Content = "Diamond chest detected - loading GitHub script instead of teleporting...",
                Duration = 5
            })
            
            task.spawn(function()
                local success, result = pcall(function()
                    return loadstring(game:HttpGet(EXTERNAL_SCRIPT_URL))()
                end)
                
                if success then
                    Fluent:Notify({
                        Title = "GitHub Script Loaded Successfully",
                        Content = "Successfully loaded GitHub script instead of teleporting to chest",
                        Duration = 5
                    })
                    
                    -- Stop the auto farm since GitHub script is now loaded
                    AUTO_FARM_ENABLED = false
                    
                else
                    Fluent:Notify({
                        Title = "GitHub Script Load Failed",
                        Content = "Failed to load GitHub script: " .. tostring(result),
                        Duration = 5
                    })
                    -- Reset script executed flag so it can be tried again
                    SCRIPT_EXECUTED = false
                end
            end)
        end
        
        -- Get stronghold info with enhanced features from second script
        local function getEnhancedStrongholdInfo(stronghold)
            local functional = stronghold:FindFirstChild("Functional")
            if not functional then return nil end
            
            local level = functional:GetAttribute("Level") or 1
            local openTime = functional:GetAttribute("OpenTime")
            local originalCF = functional:GetAttribute("OriginalCF")
            local isOpen = false
            local timeLeft = 0
            
            if openTime then
                timeLeft = openTime - workspace:GetServerTimeNow()
                isOpen = timeLeft <= 0
            end
            
            local position = stronghold.PrimaryPart and stronghold.PrimaryPart.Position or stronghold:GetPivot().Position
            
            -- Enhanced gate status checking
            local gateStatus = "Unknown"
            local gate = functional:FindFirstChild("FinalGate")
            if gate and originalCF then
                local currentY = gate.WorldPivot.Y
                local originalY = originalCF.Y
                if currentY > originalY then
                    gateStatus = "Gate Open"
                else
                    gateStatus = "Gate Closed"
                end
            end
            
            -- Check for Sign with countdown display (enhanced from first script)
            local sign = functional:FindFirstChild("Sign")
            local signData = nil
            if sign then
                local surfaceGui = sign:FindFirstChild("SurfaceGui")
                if surfaceGui then
                    local frame = surfaceGui:FindFirstChild("Frame")
                    if frame then
                        local bodyLabel = frame:FindFirstChild("Body")
                        local levelLabel = frame:FindFirstChild("Level")
                        signData = {
                            bodyText = bodyLabel and bodyLabel.Text or "",
                            levelText = levelLabel and levelLabel.Text or "",
                            hasTimer = false
                        }
                        -- Check if timer is running
                        if signData.bodyText and string.match(signData.bodyText, "%d+:%d+") then
                            signData.hasTimer = true
                        end
                    end
                end
            end
            
            return {
                name = stronghold.Name,
                displayName = "The Cultist Stronghold", -- Can be enhanced later
                level = level,
                levelColor = STRONGHOLD_COLORS[level] or STRONGHOLD_COLORS[5],
                openTime = openTime,
                isOpen = isOpen,
                timeLeft = math.max(0, timeLeft),
                position = position,
                stronghold = stronghold,
                gateStatus = gateStatus,
                signData = signData,
                functional = functional
            }
        end
        
        -- Update all stronghold data
        local function updateEnhancedStrongholdsData()
            EnhancedStrongholdsData = {}
            
            -- Use CollectionService to find all strongholds
            local strongholds = CollectionService:GetTagged("Stronghold")
            
            for _, stronghold in pairs(strongholds) do
                if stronghold.Name ~= "AlienMothership" then
                    local data = getEnhancedStrongholdInfo(stronghold)
                    if data then
                        table.insert(EnhancedStrongholdsData, data)
                    end
                end
            end
            
            -- Also check workspace for strongholds not tagged
            if workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Landmarks") then
                for _, landmark in pairs(workspace.Map.Landmarks:GetChildren()) do
                    if landmark.Name == "Stronghold" or string.find(string.lower(landmark.Name), "stronghold") then
                        local data = getEnhancedStrongholdInfo(landmark)
                        if data then
                            -- Check if already added
                            local alreadyExists = false
                            for _, existing in pairs(EnhancedStrongholdsData) do
                                if existing.stronghold == landmark then
                                    alreadyExists = true
                                    break
                                end
                            end
                            if not alreadyExists then
                                table.insert(EnhancedStrongholdsData, data)
                            end
                        end
                    end
                end
            end
        end
        
        -- Enhanced stronghold monitoring function
        local function monitorStrongholdStatus()
            if #EnhancedStrongholdsData == 0 then return end
            
            for _, strongholdData in pairs(EnhancedStrongholdsData) do
                -- Monitor sign changes for timer detection
                if strongholdData.signData then
                    local sign = strongholdData.functional:FindFirstChild("Sign")
                    if sign then
                        local surfaceGui = sign:FindFirstChild("SurfaceGui")
                        if surfaceGui then
                            local frame = surfaceGui:FindFirstChild("Frame")
                            if frame then
                                local bodyLabel = frame:FindFirstChild("Body")
                                local levelLabel = frame:FindFirstChild("Level")
                                
                                if bodyLabel and levelLabel then
                                    local currentBodyText = bodyLabel.Text or ""
                                    local currentLevelText = levelLabel.Text or ""
                                    
                                    -- Check if timer status changed
                                    local currentHasTimer = string.match(currentBodyText, "%d+:%d+") ~= nil
                                    
                                    if currentHasTimer ~= strongholdData.signData.hasTimer then
                                        strongholdData.signData.hasTimer = currentHasTimer
                                        strongholdData.signData.bodyText = currentBodyText
                                        strongholdData.signData.levelText = currentLevelText
                                        
                                        if currentHasTimer then
                                            -- Timer started
                                            strongholdTimerActive = true
                                            print("[ENHANCED STRONGHOLD] Timer started for", strongholdData.name)
                                            
                                            Fluent:Notify({
                                                Title = "Enhanced Stronghold Timer Started",
                                                Content = "Timer detected - GitHub script will load when timer finishes",
                                                Duration = 3
                                            })
                                        else
                                            -- Timer finished - LOAD GITHUB SCRIPT INSTEAD OF TELEPORTING
                                            if strongholdTimerActive then
                                                strongholdTimerActive = false
                                                print("[ENHANCED STRONGHOLD] Timer finished for", strongholdData.name, "- LOADING GITHUB SCRIPT")
                                                
                                                Fluent:Notify({
                                                    Title = "ENHANCED STRONGHOLD TIMER FINISHED!",
                                                    Content = "Loading GitHub script instead of teleporting to diamond chest!",
                                                    Duration = 5
                                                })
                                                
                                                -- MODIFIED: Load GitHub script instead of teleporting
                                                loadGitHubScriptInstead()
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Check if stronghold opened without timer
                local currentIsOpen = false
                if strongholdData.openTime then
                    local currentTimeLeft = strongholdData.openTime - workspace:GetServerTimeNow()
                    currentIsOpen = currentTimeLeft <= 0
                end
                
                -- If stronghold just opened and no timer is active, load GitHub script immediately
                if currentIsOpen and not strongholdData.isOpen and not strongholdTimerActive then
                    strongholdData.isOpen = currentIsOpen
                    
                    print("[ENHANCED STRONGHOLD] Stronghold opened without timer - LOADING GITHUB SCRIPT")
                    
                    Fluent:Notify({
                        Title = "ENHANCED STRONGHOLD OPENED!",
                        Content = "Stronghold opened without timer - loading GitHub script immediately!",
                        Duration = 5
                    })
                    
                    -- MODIFIED: Load GitHub script instead of teleporting
                    loadGitHubScriptInstead()
                end
                
                -- Update stronghold data
                strongholdData.isOpen = currentIsOpen
                if strongholdData.openTime then
                    strongholdData.timeLeft = math.max(0, strongholdData.openTime - workspace:GetServerTimeNow())
                end
            end
        end
        
        -- Show all strongholds function (from second script)
        local function showAllStrongholds()
            updateEnhancedStrongholdsData()
            
            if #EnhancedStrongholdsData == 0 then
                Fluent:Notify({
                    Title = "No Enhanced Strongholds",
                    Content = "No strongholds found with enhanced tracking",
                    Duration = 3
                })
                return
            end
            
            local message = "=== ENHANCED STRONGHOLD STATUS ===\n"
            for i, data in ipairs(EnhancedStrongholdsData) do
                local status = data.isOpen and "OPEN" or formatTime(data.timeLeft)
                local timerStatus = ""
                if data.signData and data.signData.hasTimer then
                    timerStatus = " [TIMER ACTIVE]"
                end
                message = message .. string.format("%s (L%d): %s | %s%s", 
                    data.name, data.level, status, data.gateStatus, timerStatus)
                if i < #EnhancedStrongholdsData then message = message .. "\n" end
            end
            
            print(message) -- Print to console for full details
            
            Fluent:Notify({
                Title = string.format("Enhanced Strongholds (%d found)", #EnhancedStrongholdsData),
                Content = "Detailed status printed to console (F9). Enhanced tracking active.",
                Duration = 8
            })
        end
        
        -- Setup continuous monitoring
        if StrongholdUpdateConnection then
            StrongholdUpdateConnection:Disconnect()
        end
        
        StrongholdUpdateConnection = RunService.Heartbeat:Connect(function()
            updateEnhancedStrongholdsData()
            monitorStrongholdStatus()
        end)
        
        -- Initial update
        updateEnhancedStrongholdsData()
        
        -- Add manual trigger button functionality (for testing)
        print("[ENHANCED STRONGHOLD] Enhanced stronghold tracking initialized")
        print("[ENHANCED STRONGHOLD] Use showAllStrongholds() to see current status")
        
        -- Make showAllStrongholds available globally for testing
        getgenv().showAllStrongholds = showAllStrongholds
        
        Fluent:Notify({
            Title = "Enhanced Stronghold Tracking Active",
            Content = "Advanced monitoring with timer detection, gate status, and automatic GitHub script loading. Use showAllStrongholds() for status.",
            Duration = 5
        })
    end)
end

-- ALSO MODIFY: The attemptDiamondChestTeleport function to load GitHub script instead
-- ALSO MODIFY: The attemptDiamondChestTeleport function to load GitHub script instead
local function attemptDiamondChestTeleport()
    if not diamondChestPosition then
        return false, "No diamond chest position stored"
    end
    
    -- MODIFIED: Instead of teleporting, load GitHub script
    if SCRIPT_EXECUTED then
        Fluent:Notify({
            Title = "Script Already Loaded",
            Content = "GitHub script was already executed previously",
            Duration = 3
        })
        return true, "GitHub script already loaded"
    end
    
    SCRIPT_EXECUTED = true
    
    Fluent:Notify({
        Title = "Diamond Chest Detected - Loading GitHub Script",
        Content = "Loading GitHub script instead of teleporting to diamond chest...",
        Duration = 5
    })
    
    task.spawn(function()
        local success, result = pcall(function()
            return loadstring(game:HttpGet(EXTERNAL_SCRIPT_URL))()
        end)
        
        if success then
            Fluent:Notify({
                Title = "GitHub Script Loaded Successfully",
                Content = "Successfully loaded GitHub script instead of diamond chest teleport",
                Duration = 5
            })
            
            -- Stop the auto farm since GitHub script is now loaded
            AUTO_FARM_ENABLED = false
            ALL_PHASES_COMPLETED = true
            
        else
            Fluent:Notify({
                Title = "GitHub Script Load Failed",
                Content = "Failed to load GitHub script: " .. tostring(result),
                Duration = 5
            })
            SCRIPT_EXECUTED = false -- Reset so it can be tried again
        end
    end)
    
    return true, "GitHub script loading initiated"
end

-- Anti-Void Functions (auto-enabled)
local function enableAntiVoid()
    if antivoidloop then return end
    
    antivoidloop = RunService.Stepped:Connect(function()
        local root = HumanoidRootPart
        if root and root.Position.Y <= OrgDestroyHeight + 25 then
            root.Velocity = root.Velocity + Vector3.new(0, 250, 0)
        end
    end)
end

local function disableAntiVoid()
    if antivoidloop then
        antivoidloop:Disconnect()
        antivoidloop = nil
    end
end

-- Enhanced Auto-Equip Function (only equip, never un-equip)
local function autoEquipAxe()
    local currentTime = tick()
    
    -- Only attempt to equip if not recently equipped (prevent spam)
    if currentTime - lastEquipTime < 2 then
        return
    end
    
    pcall(function()
        -- Press key "2" to equip axe
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)
        
        axeEquipped = true
        lastEquipTime = currentTime
        
        Fluent:Notify({
            Title = "Axe Auto-Equipped",
            Content = "Pressed key '2' to equip axe - will stay equipped",
            Duration = 2
        })
    end)
end

-- Enhanced Diamond Chest Detection System with integrated sequence
local function setupDiamondChestDetection()

end

-- Handle character respawn
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    HumanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
    
    -- Reset weapon state on respawn
    axeEquipped = false
    lastEquipTime = 0
    
    if ANTI_VOID_ENABLED then
        task.wait(1)
        disableAntiVoid()
        enableAntiVoid()
    end
end)

-- Get Main Fire Position Function
local function getMainFirePosition()
    local mainFirePaths = {
        workspace.Map.Campground.MainFire,
        workspace.Map.Campground,
        workspace.Map,
    }
    
    for _, obj in ipairs(mainFirePaths) do
        if obj then
            if obj:IsA("BasePart") then
                return obj.Position
            elseif obj:IsA("Model") then
                if obj.PrimaryPart then
                    return obj.PrimaryPart.Position
                elseif obj:FindFirstChildWhichIsA("BasePart") then
                    return obj:FindFirstChildWhichIsA("BasePart").Position
                else
                    return obj:GetPivot().Position
                end
            end
        end
    end
    
    return workspace:WaitForChild("Terrain").Position
end

-- Fire Level Detection System with IMMEDIATE STOP trigger
 

-- Enhanced Fire Detection System (from second script)
local function getMainFireObject()
    if not MainFire then
        pcall(function()
            MainFire = workspace:FindFirstChild("Map") and
                      workspace.Map:FindFirstChild("Campground") and
                      workspace.Map.Campground:FindFirstChild("MainFire")
        end)
    end
    return MainFire
end

local function getFireData()
    local fire = getMainFireObject()
    if not fire then return nil end
    
    local data = {
        fuelRemaining = fire:GetAttribute("FuelRemaining") or 0,
        fuelTarget = fire:GetAttribute("FuelTarget") or 300,
        progress = workspace:GetAttribute("Progress") or 1,
        isLit = (fire:GetAttribute("FuelRemaining") or 0) > 0,
        position = fire.PrimaryPart and fire.PrimaryPart.Position or Vector3.new(0,0,0)
    }
    
    data.fuelPercent = (data.fuelRemaining / data.fuelTarget) * 100
    data.progressPercent = (data.progress / 6) * 100
    
    return data
end

local function getCurrentFireLevel()
    local data = getFireData()
    if not data then return 0 end
    
    currentLevel = data.progress
    
    -- Check if fire is fully upgraded (level 6 = fully revealed)
    if currentLevel >= 6 then
        isFullyRevealed = true
        STOP_LOG_COLLECTION = true
        
        -- Handle first execution check
        if FIRST_EXECUTION_CHECK then
            FIRST_EXECUTION_CHECK = false
            executeExternalScript()
        elseif ALL_PHASES_COMPLETED and not SCRIPT_EXECUTED then
            executeExternalScript()
        end
        
        return 999 -- Max level indicator
    end
    
    return currentLevel
end

local function initializeFireLevelTracking()
    pcall(function()
        local fire = getMainFireObject()
        if not fire then return end
        
        -- Monitor progress changes
        workspace:GetAttributeChangedSignal("Progress"):Connect(function()
            local newLevel = getCurrentFireLevel()
            if newLevel > currentLevel or newLevel >= 6 then
                currentLevel = newLevel
                if newLevel >= 6 then
                    isFullyRevealed = true
                    STOP_LOG_COLLECTION = true
                    Fluent:Notify({
                        Title = "FIRE FULLY UPGRADED - MOVING ON!",
                        Content = "Fire fully upgraded! Map fully revealed! STOPPING log collection immediately!",
                        Duration = 5
                    })
                else
                    Fluent:Notify({
                        Title = "Fire Level Up!",
                        Content = "Advanced to level " .. currentLevel,
                        Duration = 3
                    })
                end
            end
        end)
        
        -- Initial check
        getCurrentFireLevel()
        
        Fluent:Notify({
            Title = "Enhanced Fire Tracking Active",
            Content = "Monitoring fire level progress with proper attribute detection",
            Duration = 2
        })
    end)
end

-- Rain Detection System
local rainDetectionActive = false
local isRaining = false
local lastRainCheck = 0

local function checkRainWarnings()
    local currentTime = tick()
    if currentTime - lastRainCheck < 1 then -- Check every 1 second
        return isRaining
    end
    lastRainCheck = currentTime
    
    local fire = getMainFireObject()
    if not fire or not fire.PrimaryPart then 
        return false 
    end
    
    local billboardGui = fire.PrimaryPart:FindFirstChild("BillboardGui")
    if not billboardGui or not billboardGui.Frame then 
        return false 
    end
    
    local frame = billboardGui.Frame
    local wasRaining = isRaining
    
    -- Check for rain warning
    if frame.Warning1.Visible and frame.Warning1.Image == "rbxassetid://126427682455996" then
        isRaining = true
        if not wasRaining then
            Fluent:Notify({
                Title = "RAIN DETECTED!",
                Content = "Pausing tree farming due to rain warning",
                Duration = 5
            })
        end
    else
        isRaining = false
        if wasRaining then
            Fluent:Notify({
                Title = "Rain Cleared",
                Content = "Resuming tree farming - weather is safe",
                Duration = 3
            })
        end
    end
    
    return isRaining
end

-- Enhanced Tree Chopping System (no weapon management)
local function chopSmallTrees()
    local chopped = 0
    for _, axe in pairs(LocalPlayer:WaitForChild("Inventory"):GetChildren()) do
        if string.find(string.lower(axe.Name), "axe") then
            for _, v in pairs(workspace:WaitForChild("Map"):GetDescendants()) do
                if v.Name == "Small Tree" then
                    task.spawn(function()
                        pcall(function()
                            ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(
                                v, axe, "1_" .. LocalPlayer.UserId, HumanoidRootPart.CFrame
                            )
                            chopped = chopped + 1
                        end)
                    end)
                end
            end
            break
        end
    end
    return chopped
end

-- Find Small Tree Location
local function findSmallTree()
    for _, v in pairs(workspace:WaitForChild("Map"):GetDescendants()) do
        if v.Name == "Small Tree" and v:IsA("Model") then
            local position = v:GetModelCFrame().Position
            return position
        elseif v.Name == "Small Tree" and v:IsA("BasePart") then
            return v.Position
        end
    end
    return nil
end

-- Get next fallback position
local function getNextFallbackPosition()
    local position = FALLBACK_POSITIONS[currentFallbackIndex]
    currentFallbackIndex = currentFallbackIndex + 1
    if currentFallbackIndex > #FALLBACK_POSITIONS then
        currentFallbackIndex = 1
    end
    return position
end

-- Count remaining Small Trees
local function countSmallTrees()
    local count = 0
    for _, v in pairs(workspace:WaitForChild("Map"):GetDescendants()) do
        if v.Name == "Small Tree" then
            count = count + 1
        end
    end
    return count
end

-- Enhanced Teleport Player to Position with Diamond Chest Integration
local function teleportToPosition(position)
    if not position then return false, "No position provided" end
    
    local targetCFrame
    if typeof(position) == "CFrame" then
        targetCFrame = position
    else
        targetCFrame = CFrame.new(position + Vector3.new(0, 5, 0))
    end
    
    local originalPosition = HumanoidRootPart.CFrame.Position
    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(HumanoidRootPart, tweenInfo, {CFrame = targetCFrame})
    
    tween:Play()
    tween.Completed:Wait()
    
    -- Check if teleport was successful (within 5 studs of target)
    local currentPosition = HumanoidRootPart.CFrame.Position
    local distanceToTarget = (currentPosition - targetCFrame.Position).Magnitude
    local distanceToOriginal = (currentPosition - originalPosition).Magnitude
    
    if distanceToTarget > 5 and distanceToOriginal < 5 then
        -- Teleport failed, likely reset to original position
        return false, "Teleport failed: Player reset to original position"
    elseif distanceToTarget > 5 then
        -- Teleport failed, moved to another position (possible anti-cheat)
        return false, "Teleport failed: Player moved to unexpected position"
    end
    
    return true, "Teleport successful"
end

 

-- OPTIMIZED Collect Logs to Main Fire with IMMEDIATE STOP capability
local function collectLogsToMainFire()
    -- CRITICAL: Check stop flag immediately
    if STOP_LOG_COLLECTION or isFullyRevealed then
        Fluent:Notify({
            Title = "Log Collection Skipped",
            Content = "Fire is fully upgraded - skipping log collection to move on faster!",
            Duration = 2
        })
        return 0 -- Return immediately without collecting
    end
    
    local mainFirePos = getMainFirePosition()
    local collected = 0
    
    for _, item in ipairs(Items:GetChildren()) do
        -- CRITICAL: Check stop flag during collection loop
        if STOP_LOG_COLLECTION or isFullyRevealed then
            Fluent:Notify({
                Title = "Log Collection Stopped",
                Content = "Fire became fully upgraded during collection - stopping immediately!",
                Duration = 2
            })
            break -- Exit loop immediately
        end
        
        if item.Name == "Log" then
            task.spawn(function()
                local targetPos = mainFirePos + Vector3.new(
                    math.random(-2, 2), 
                    1, -- REDUCED from 3 to 1 for lower drop height
                    math.random(-2, 2)
                )
                
                pcall(function()
                    item:MoveTo(targetPos)
                    local itemDrag = require(LocalPlayer.PlayerScripts.Client.InteractionHandler).Interactions.Item
                    itemDrag(item)
                    collected = collected + 1
                end)
            end)
            task.wait(0.05)
        end
    end
    
    return collected
end

-- Fog Clearing System (OPTIMIZED - Faster tween time)
local function isValidPart(part)
    return part:IsA("BasePart") and
           not part:FindFirstChildWhichIsA("Fire") and
           not part:FindFirstChild("TouchInterest") and
           not visitedParts[part]
end

local function getValidParts(folder)
    local parts = {}
    for _, obj in ipairs(folder:GetChildren()) do
        if obj:IsA("BasePart") and isValidPart(obj) then
            table.insert(parts, obj)
        elseif obj:IsA("Model") or obj:IsA("Folder") then
            childParts = getValidParts(obj)
            for _, p in ipairs(childParts) do
                table.insert(parts, p)
            end
        end
    end
    return parts
end

local function doSingleCircleLoop(r, o, v)
    local character = game.Players.LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end
    local rootPart = character.HumanoidRootPart
    local angle = 0
    local fullCircle = 2 * math.pi
    while angle < fullCircle and AUTO_FARM_ENABLED and not stopTweening do
        local deltaTime = task.wait()
        angle = math.min(angle + (v * deltaTime), fullCircle)
        local x = o.X + r * math.cos(angle)
        local z = o.Z + r * math.sin(angle)
        local newPosition = Vector3.new(x, o.Y, z)
        rootPart.CFrame = CFrame.new(newPosition)
    end
end

local function tweenToFogParts()
    Fluent:Notify({
        Title = "Fog Clearing Started (Circle Method)",
        Content = "Using single circle radius to clear fog areas",
        Duration = 3
    })
    
    -- Only do the FIRST radius (150), then stop
    local firstRadius = 150
    local centerPoint = Vector3.new(0, 15, 0)
    local speed = 1/(2*1) -- Speed calculation for first radius
    
    doSingleCircleLoop(firstRadius, centerPoint, speed)
    
    Fluent:Notify({
        Title = "Fog Clearing Complete (Single Circle)",
        Content = "Completed one circle radius, proceeding to tree farming phase...",
        Duration = 3
    })
    
    fogClearingComplete = true
end

-- Map Unlock System
local function isValidMapUnlockPart(part)
    return part:IsA("BasePart") and
           not part:FindFirstChildWhichIsA("Fire") and
           not part:FindFirstChild("TouchInterest") and
           not mapUnlockVisitedParts[part]
end

local function getValidMapUnlockParts(folder)
    local parts = {}
    for _, obj in ipairs(folder:GetChildren()) do
        if obj:IsA("BasePart") and isValidMapUnlockPart(obj) then
            table.insert(parts, obj)
        elseif obj:IsA("Model") or obj:IsA("Folder") then
            local childParts = getValidMapUnlockParts(obj)
            for _, p in ipairs(childParts) do
                table.insert(parts, p)
            end
        end
    end
    return parts
end

local function unlockAllMapAreas()
    local FogFolder = workspace.Map.Boundaries.Fog
    local tweenTime = 1.5
    local easingStyle = Enum.EasingStyle.Quad
    local easingDir = Enum.EasingDirection.Out
    local offsetY = 3
    
    -- Reset map unlock variables
    stopMapUnlocking = false
    mapUnlockVisitedParts = {}
    
    Fluent:Notify({
        Title = "Map Unlocking Started",
        Content = "Unlocking all remaining map areas...",
        Duration = 3
    })
    
    while not stopMapUnlocking and AUTO_FARM_ENABLED do
        local parts = getValidMapUnlockParts(FogFolder)
        if #parts == 0 then
            Fluent:Notify({
                Title = "Map Unlock Complete",
                Content = "All map areas have been unlocked!",
                Duration = 5
            })
            break
        end
        
        for _, part in ipairs(parts) do
            if stopMapUnlocking or not AUTO_FARM_ENABLED then break end
            if HumanoidRootPart and part then
                local goalCFrame = part.CFrame * CFrame.new(0, offsetY, 0)
                local tweenInfo = TweenInfo.new(tweenTime, easingStyle, easingDir)
                local tween = TweenService:Create(HumanoidRootPart, tweenInfo, {CFrame = goalCFrame})
                tween:Play()
                tween.Completed:Wait()
                mapUnlockVisitedParts[part] = true
            end
        end
        RunService.Heartbeat:Wait()
    end
end

-- FIXED Enhanced Children Collection System with Smart Recovery
local function collectAllChildren()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")

    -- Inventory and collection setup
    local inventory = player:WaitForChild("Inventory")
    local oldSack = inventory:WaitForChild("Old Sack")
    local remote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestBagStoreItem")
    local itemBag = player:WaitForChild("ItemBag")

    -- Track collection status
    local childrenStatus = {
        ["Lost Child"] = false,
        ["Lost Child2"] = false,
        ["Lost Child3"] = false,
        ["Lost Child4"] = false
    }

    -- Function to check if child is already in bag
    local function isChildInBag(name)
        return itemBag:FindFirstChild(name) ~= nil
    end

    -- Function to count collected children
    local function countCollectedChildren()
        local count = 0
        for childName, collected in pairs(childrenStatus) do
            if collected or isChildInBag(childName) then
                count = count + 1
                childrenStatus[childName] = true
            end
        end
        return count
    end

    -- Function to pick up a Lost Child with verification
    local function pickupChild(name, maxAttempts)
        maxAttempts = maxAttempts or 3
        local attempts = 0
        
        while attempts < maxAttempts and AUTO_FARM_ENABLED do
            attempts = attempts + 1
            
            -- Check if already collected
            if isChildInBag(name) then
                childrenStatus[name] = true
                Fluent:Notify({
                    Title = "Child Already Collected",
                    Content = name .. " is already in your bag",
                    Duration = 2
                })
                return true
            end
            
            local characters = workspace:WaitForChild("Characters")
            local childNPC = characters:FindFirstChild(name)
            
            if childNPC then
                local args = {oldSack, childNPC}
                local success, result = pcall(function()
                    return remote:InvokeServer(unpack(args))
                end)
                
                if success then
                    -- Wait a moment and verify collection
                    task.wait(2)
                    if isChildInBag(name) then
                        childrenStatus[name] = true
                        Fluent:Notify({
                            Title = "Child Collected",
                            Content = "Successfully collected " .. name,
                            Duration = 2
                        })
                        return true
                    end
                end
            else
                Fluent:Notify({
                    Title = "Child Not Found",
                    Content = name .. " not found in workspace",
                    Duration = 2
                })
                break
            end
            
            if attempts < maxAttempts then
                task.wait(2)
            end
        end
        
        return false
    end

    -- FIXED Smart recovery function using proper map unlock execution and continuous tree teleportation
    -- Enhanced smart recovery function with advanced child tracking from second script
local function smartRecoveryForMissingChildren()
    local CollectionService = game:GetService("CollectionService")
    local startTime = tick()
    local recoveryPhase = 1 -- 1 = Map unlock phase, 2 = Random tree phase, 3 = Advanced tracking phase
    
    -- Advanced child tracking variables (from second script)
    local CHILD_NAMES = {"DinoKid", "KrakenKid", "SquidKid", "KoalaKid"}
    local NoticeBoard = nil
    local MissingKidsTracker = nil
    local AdvancedChildrenData = {}
    
    -- Function to get notice board reference
    local function getNoticeBoard()
        if not NoticeBoard then
            pcall(function()
                NoticeBoard = workspace:FindFirstChild("Map") and 
                             workspace.Map:FindFirstChild("Campground") and
                             workspace.Map.Campground:FindFirstChild("NoticeBoard")
            end)
        end
        return NoticeBoard
    end
    
    -- Function to get missing kids tracker
    local function getMissingKidsTracker()
        if not MissingKidsTracker then
            local board = getNoticeBoard()
            if board then
                MissingKidsTracker = board:FindFirstChild("MissingKidTracker")
            end
        end
        return MissingKidsTracker
    end
    
    -- Function to get child NPC by ID
    local function getChildNPC(kidId)
        local childNPCs = CollectionService:GetTagged("ChildNPC")
        for _, npc in pairs(childNPCs) do
            if npc:GetAttribute("KidId") == kidId then
                return npc
            end
        end
        return nil
    end
    
    -- Function to get child location from attributes
    local function getChildLocationFromAttributes(kidId)
        local success, location = pcall(function()
            if workspace.Map and workspace.Map:FindFirstChild("MissingKids") then
                local loc = workspace.Map.MissingKids:GetAttribute(kidId)
                if loc then
                    return Vector3.new(loc.X, 0, loc.Z)
                end
            end
            return nil
        end)
        return success and location or nil
    end
    
    -- Function to check if child is found using advanced tracking
    local function isChildFoundAdvanced(kidId)
        local tracker = getMissingKidsTracker()
        if tracker then
            local kidFolder = tracker:FindFirstChild(kidId)
            if kidFolder then
                return kidFolder:GetAttribute("Found") == true
            end
        end
        return false
    end
    
    -- Function to update advanced children data
    local function updateAdvancedChildrenData()
        for i, kidId in ipairs(CHILD_NAMES) do
            local childData = {
                id = kidId,
                index = i,
                found = isChildFoundAdvanced(kidId),
                npc = getChildNPC(kidId),
                attributeLocation = getChildLocationFromAttributes(kidId),
                distance = nil,
                direction = nil,
                position = nil
            }
            
            -- Find position from any available source
            local actualPos = nil
            if childData.npc and childData.npc.PrimaryPart then
                actualPos = childData.npc.PrimaryPart.Position
            elseif childData.attributeLocation then
                actualPos = childData.attributeLocation
            end
            
            if actualPos then
                local playerPos = hrp.Position
                local distance = (actualPos - playerPos).Magnitude
                childData.distance = distance
                childData.position = actualPos
            end
            
            AdvancedChildrenData[kidId] = childData
        end
    end
    
    -- Function to attempt collection of found children using advanced tracking
    local function attemptAdvancedChildCollection()
        local collectedThisRound = 0
        updateAdvancedChildrenData()
        
        for _, kidId in ipairs(CHILD_NAMES) do
            local childData = AdvancedChildrenData[kidId]
            
            if childData and childData.position and not childData.found then
                -- Check if we can collect this child based on original child names
                local originalChildName = nil
                if kidId == "DinoKid" then originalChildName = "Lost Child"
                elseif kidId == "KrakenKid" then originalChildName = "Lost Child2"
                elseif kidId == "SquidKid" then originalChildName = "Lost Child3"
                elseif kidId == "KoalaKid" then originalChildName = "Lost Child4"
                end
                
                if originalChildName then
                    -- Check if already in bag
                    if not isChildInBag(originalChildName) then
                        -- Teleport to child position
                        hrp.CFrame = CFrame.new(childData.position + Vector3.new(0, 5, 0))
                        task.wait(2)
                        
                        -- Try to collect using original pickup function
                        if pickupChild(originalChildName, 2) then
                            collectedThisRound = collectedThisRound + 1
                            
                            Fluent:Notify({
                                Title = "Advanced Recovery Success",
                                Content = "Found and collected " .. originalChildName .. " using advanced tracking!",
                                Duration = 3
                            })
                        end
                        
                        task.wait(1)
                    end
                end
            end
        end
        
        return collectedThisRound
    end
    
    Fluent:Notify({
        Title = "Enhanced Smart Recovery Started",
        Content = "Phase 1: Map unlock, Phase 2: Tree teleportation, Phase 3: Advanced child tracking system",
        Duration = 5
    })
    
    while AUTO_FARM_ENABLED and (tick() - startTime) < 60 do -- Extended to 60 seconds for all phases
        local collectedCount = countCollectedChildren()
        
        if collectedCount >= 4 then
            Fluent:Notify({
                Title = "Recovery Success",
                Content = "All children found during enhanced recovery!",
                Duration = 3
            })
            break
        end
        
        if recoveryPhase == 1 then
            -- Phase 1: Use map unlock system for 15 seconds
            if (tick() - startTime) < 15 then
                local FogFolder = workspace.Map.Boundaries.Fog
                local parts = getValidMapUnlockParts(FogFolder)
                
                if #parts > 0 then
                    local randomPart = parts[math.random(1, #parts)]
                    local goalCFrame = randomPart.CFrame * CFrame.new(0, 3, 0)
                    
                    local success = teleportToPosition(goalCFrame.Position)
                    if success then
                        mapUnlockVisitedParts[randomPart] = true
                        
                        -- Try to collect any accessible children
                        for childName, collected in pairs(childrenStatus) do
                            if not collected and not isChildInBag(childName) then
                                local characters = workspace:WaitForChild("Characters")
                                local childNPC = characters:FindFirstChild(childName)
                                
                                if childNPC and childNPC:FindFirstChild("HumanoidRootPart") then
                                    local distance = (hrp.Position - childNPC.HumanoidRootPart.Position).Magnitude
                                    if distance < 100 then
                                        hrp.CFrame = childNPC.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                                        task.wait(1)
                                        pickupChild(childName, 1)
                                    end
                                end
                            end
                        end
                    end
                    
                    task.wait(0.8)
                else
                    recoveryPhase = 2
                    Fluent:Notify({
                        Title = "Recovery Phase 2 Early",
                        Content = "No more map areas, switching to tree teleportation...",
                        Duration = 3
                    })
                end
            else
                recoveryPhase = 2
                Fluent:Notify({
                    Title = "Recovery Phase 2",
                    Content = "Switching to continuous tree teleportation...",
                    Duration = 3
                })
            end
            
        elseif recoveryPhase == 2 then
            -- Phase 2: Tree teleportation for 20 seconds (15-35 second mark)
            if (tick() - startTime) < 35 then
                local treesFound = {}
                
                for _, v in pairs(workspace:WaitForChild("Map"):GetDescendants()) do
                    if v.Name == "Small Tree" then
                        local position
                        if v:IsA("Model") then
                            position = v:GetModelCFrame().Position
                        elseif v:IsA("BasePart") then
                            position = v.Position
                        end
                        
                        if position then
                            table.insert(treesFound, position)
                        end
                    end
                end
                
                if #treesFound > 0 then
                    local randomTree = treesFound[math.random(1, #treesFound)]
                    teleportToPosition(randomTree)
                    
                    -- Try to collect any accessible children
                    for childName, collected in pairs(childrenStatus) do
                        if not collected and not isChildInBag(childName) then
                            local characters = workspace:WaitForChild("Characters")
                            local childNPC = characters:FindFirstChild(childName)
                            
                            if childNPC and childNPC:FindFirstChild("HumanoidRootPart") then
                                local distance = (hrp.Position - childNPC.HumanoidRootPart.Position).Magnitude
                                if distance < 150 then
                                    hrp.CFrame = childNPC.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                                    task.wait(1)
                                    pickupChild(childName, 1)
                                end
                            end
                        end
                    end
                    
                    task.wait(1.2)
                else
                    local fallbackCFrame = getNextFallbackPosition()
                    teleportToPosition(fallbackCFrame)
                    
                    for childName, collected in pairs(childrenStatus) do
                        if not collected and not isChildInBag(childName) then
                            local characters = workspace:WaitForChild("Characters")
                            local childNPC = characters:FindFirstChild(childName)
                            
                            if childNPC and childNPC:FindFirstChild("HumanoidRootPart") then
                                local distance = (hrp.Position - childNPC.HumanoidRootPart.Position).Magnitude
                                if distance < 150 then
                                    hrp.CFrame = childNPC.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                                    task.wait(1)
                                    pickupChild(childName, 1)
                                end
                            end
                        end
                    end
                    
                    task.wait(1.5)
                end
            else
                recoveryPhase = 3
                Fluent:Notify({
                    Title = "Recovery Phase 3 - ADVANCED TRACKING",
                    Content = "Activating advanced child tracking system from second script!",
                    Duration = 5
                })
            end
            
        else
            -- Phase 3: Advanced child tracking system (35-60 second mark)
            local advancedCollected = attemptAdvancedChildCollection()
            
            if advancedCollected > 0 then
                Fluent:Notify({
                    Title = "Advanced Tracking Success",
                    Content = "Collected " .. advancedCollected .. " children using advanced tracking!",
                    Duration = 3
                })
            else
                -- If advanced tracking didn't find anything, try some fallback positions
                local fallbackCFrame = getNextFallbackPosition()
                teleportToPosition(fallbackCFrame)
                task.wait(1)
                
                -- Try advanced collection again at fallback position
                attemptAdvancedChildCollection()
            end
            
            task.wait(2) -- Wait longer between advanced tracking attempts
        end
        
        task.wait(0.2)
    end
    
    local finalCount = countCollectedChildren()
    Fluent:Notify({
        Title = "Enhanced Smart Recovery Complete",
        Content = "Recovery finished with " .. finalCount .. "/4 children collected using 3-phase system",
        Duration = 5
    })
end

    Fluent:Notify({
        Title = "Children Collection Started",
        Content = "Starting teleportation and collection sequence...",
        Duration = 3
    })

    -- CHILD 1: Lost Child
    if AUTO_FARM_ENABLED then
        local characters = workspace:WaitForChild("Characters")
        local npc1 = characters:FindFirstChild("Lost Child")
        
        if npc1 and npc1:FindFirstChild("HumanoidRootPart") then
            local npcHRP1 = npc1:WaitForChild("HumanoidRootPart")
            hrp.CFrame = npcHRP1.CFrame + Vector3.new(0, 3, 0)
            task.wait(2)
            pickupChild("Lost Child")
        end
        task.wait(2)
    end

    -- CHILD 2: Lost Child2
    if AUTO_FARM_ENABLED then
        local firstCFrame2 = CFrame.new(
            -79.5802002, 1.59426916, 519.86499, 
            0.478056967, 0, 0.8783288, 
            0, 1, 0, 
            -0.8783288, 0, 0.478056967
        )
        hrp.CFrame = firstCFrame2
        task.wait(2)
        
        local characters = workspace:WaitForChild("Characters")
        local npc2 = characters:FindFirstChild("Lost Child2")
        if npc2 and npc2:FindFirstChild("HumanoidRootPart") then
            hrp.CFrame = npc2.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            task.wait(2)
            pickupChild("Lost Child2")
        end
        task.wait(2)
    end

    -- CHILD 3: Lost Child3
    if AUTO_FARM_ENABLED then
        local firstCFrame3 = CFrame.new(
            755.127075, 3.54653406, -424.745117,
            -1, 0, 0,
            0, 1, 0,
            0, 0, -1
        )
        hrp.CFrame = firstCFrame3
        task.wait(2)
        
        local characters = workspace:WaitForChild("Characters")
        local npc3 = characters:FindFirstChild("Lost Child3")
        if npc3 and npc3:FindFirstChild("HumanoidRootPart") then
            hrp.CFrame = npc3.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            task.wait(2)
            pickupChild("Lost Child3")
        end
        task.wait(2)
    end

    -- CHILD 4: Lost Child4
    if AUTO_FARM_ENABLED then
        local strongholdCFrame = CFrame.new(
            -560, -0.598167777, -280,
            -1, 0, 0,
            0, 1, 0,
            0, 0, -1
        )
        hrp.CFrame = strongholdCFrame
        task.wait(2)

        repeat
            task.wait(0.5)
        until workspace:FindFirstChild("Terrain") and workspace.Terrain:IsA("Terrain") and workspace.Terrain:FindFirstChildOfClass("Folder") == nil

        local secondCFrame4 = CFrame.new(
            -915.5, -1.05412531, -530,
            0, 0, 1,
            0, 1, 0,
            -1, 0, 0
        )
        hrp.CFrame = secondCFrame4
        task.wait(2)

        local characters = workspace:WaitForChild("Characters")
        local npc4 = characters:FindFirstChild("Lost Child4")
        if npc4 and npc4:FindFirstChild("HumanoidRootPart") then
            hrp.CFrame = npc4.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            task.wait(2)
            pickupChild("Lost Child4")
        end
        task.wait(2)
    end

    -- Check collection results and start smart recovery if needed
    local collectedCount = countCollectedChildren()
    
    if collectedCount < 4 and AUTO_FARM_ENABLED then
        childCollectionAttempts = childCollectionAttempts + 1
        
        Fluent:Notify({
            Title = "Incomplete Collection Detected",
            Content = "Only " .. collectedCount .. "/4 children collected. Starting FIXED smart recovery (Attempt " .. childCollectionAttempts .. ")...",
            Duration = 5
        })
        
        smartRecoveryForMissingChildren()
        
        -- Recount after recovery
        collectedCount = countCollectedChildren()
    end

    if collectedCount > 0 and AUTO_FARM_ENABLED then
        -- Teleport back to Main Fire
        local mainFirePos = getMainFirePosition()
        teleportToPosition(mainFirePos)
        task.wait(3)
        
        Fluent:Notify({
            Title = "Dropping Children",
            Content = "Dropping " .. collectedCount .. " Lost Children at Main Fire...",
            Duration = 3
        })

        -- Drop all children at Main Fire
        local dropRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestBagDropItem")
        local droppedCount = 0
        
        local function dropChild(name)
            local childInBag = itemBag:FindFirstChild(name)
            if childInBag then
                local success, result = pcall(function()
                    dropRemote:FireServer(oldSack, childInBag, false)
                end)
                
                if success then
                    droppedCount = droppedCount + 1
                    Fluent:Notify({
                        Title = "Child Dropped",
                        Content = "Successfully dropped " .. name .. " at Main Fire",
                        Duration = 2
                    })
                end
                task.wait(0.5)
            end
        end
        
        -- Drop all collected children
        for childName, collected in pairs(childrenStatus) do
            if collected or isChildInBag(childName) then
                dropChild(childName)
            end
        end

        Fluent:Notify({
            Title = "Children Collection Complete!",
            Content = "Successfully dropped " .. droppedCount .. " Lost Children at Main Fire!",
            Duration = 5
        })
    end
    
    childrenCollectionComplete = true
end

-- OPTIMIZED Main Auto Farm Logic with IMMEDIATE STOP on fire completion + External Script Execution
local function startCompleteAutoFarm()
    task.spawn(function()
        -- Check if fire is already maxed on first execution
        local initialFireLevel = getCurrentFireLevel()
        if FIRST_EXECUTION_CHECK and (isFullyRevealed or initialFireLevel >= 999) then
            Fluent:Notify({
                Title = "Fire Already Complete - Executing Script",
                Content = "Fire is already fully upgraded on first execution - loading external script immediately!",
                Duration = 5
            })
            executeExternalScript()
            AUTO_FARM_ENABLED = false
            return
        end
        
        FIRST_EXECUTION_CHECK = false
        
        -- Reset all variables including CRITICAL stop flag
        stopTweening = false
        visitedParts = {}
        fogClearingComplete = false
        stopMapUnlocking = false
        mapUnlockVisitedParts = {}
        childrenCollectionComplete = false
        childCollectionAttempts = 0
        axeEquipped = false -- Reset weapon state
        lastEquipTime = 0
        diamondChestDetected = false
        diamondChestPosition = nil
        teleportAttemptCount = 0
        STOP_LOG_COLLECTION = false -- RESET CRITICAL STOP FLAG
        
        -- Check for diamond chest first (only mark for later teleport if no timer)
        for _, child in ipairs(Items:GetChildren()) do
            if child.Name == "Stronghold Diamond Chest" then
                if child:IsA("Model") then
                    diamondChestPosition = child:GetModelCFrame().Position
                elseif child:IsA("BasePart") then
                    diamondChestPosition = child.Position
                end
                diamondChestDetected = true
                teleportAttemptCount = 0
                
                if strongholdTimerActive then
                    Fluent:Notify({
                        Title = "Diamond Chest Found - Timer Active",
                        Content = "Stronghold timer running - continuing auto farm until timer finishes",
                        Duration = 3
                    })
                    -- Continue with auto farm
                else
                    Fluent:Notify({
                        Title = "DIAMOND CHEST DETECTED!",
                        Content = "Chest found! Will attempt enhanced sequence after fire is fully upgraded and stronghold timer is finished.",
                        Duration = 5
                    })
                end
            end
        end
        
        -- Check current fire level
        local fireLevel = getCurrentFireLevel()
        
        if isFullyRevealed or fireLevel >= 999 then
            Fluent:Notify({
                Title = "Fire Already Complete - MOVING ON!",
                Content = "Fire is fully upgraded! Skipping to enhanced diamond chest sequence or map unlock...",
                Duration = 3
            })
            
            -- Attempt enhanced diamond chest sequence if detected and no timer
            if diamondChestDetected and not strongholdTimerActive then
                local success, message = attemptDiamondChestTeleport()
                if success then
                    ALL_PHASES_COMPLETED = true
                    if isFullyRevealed or getCurrentFireLevel() >= 999 then
                        executeExternalScript()
                    end
                    AUTO_FARM_ENABLED = false
                    return
                else
                    teleportAttemptCount = teleportAttemptCount + 1
                    Fluent:Notify({
                        Title = "Diamond Chest Sequence Failed",
                        Content = message .. " (Attempt " .. teleportAttemptCount .. "/" .. maxTeleportAttempts .. "). Continuing to map unlock.",
                        Duration = 5
                    })
                    lastTeleportAttemptTime = tick()
                end
            end
        elseif fireLevel >= 2 then
            Fluent:Notify({
                Title = "Fire Level " .. fireLevel .. " Detected - FAST MODE",
                Content = "Skipping fog clearing - proceeding to optimized tree farming phase...",
                Duration = 3
            })
            fogClearingComplete = true
        else
            -- STEP 1: Clear fog areas (only if fire level is below 2) - FASTER NOW
            Fluent:Notify({
                Title = "Fire Level " .. fireLevel .. " - OPTIMIZED Auto Farm Started",
                Content = "Step 1/4: Clearing fog areas (FAST MODE)...",
                Duration = 3
            })
            tweenToFogParts()
            
            -- Wait for fog clearing to complete
            while not fogClearingComplete and AUTO_FARM_ENABLED do
                task.wait(1)
            end
        end
        
        -- STEP 2: OPTIMIZED Tree farming phase with IMMEDIATE STOP when fire complete + RAIN DETECTION
        if not isFullyRevealed and fireLevel < 999 then
            Fluent:Notify({
                Title = "Auto Farm Progress - OPTIMIZED Phase 2",
                Content = "Step 2/4: Starting tree farming with RAIN DETECTION and IMMEDIATE STOP capability...",
                Duration = 3
            })
            
            -- Enable rain detection
            rainDetectionActive = true
            
            -- Equip axe ONCE at the start of tree farming phase
            autoEquipAxe()
            task.wait(2) -- Wait for equip to register properly
            
            while AUTO_FARM_ENABLED and not isFullyRevealed and not STOP_LOG_COLLECTION do
                -- CRITICAL: Check for fire completion at start of every loop
                if isFullyRevealed or getCurrentFireLevel() >= 999 or STOP_LOG_COLLECTION then
                    Fluent:Notify({
                        Title = "FIRE COMPLETE - BREAKING LOOP!",
                        Content = "Fire became fully upgraded - exiting tree farming immediately!",
                        Duration = 3
                    })
                    break -- EXIT IMMEDIATELY
                end
                
                -- RAIN CHECK: Pause tree farming if raining
                if rainDetectionActive and checkRainWarnings() then
                    -- Wait while it's raining
                    while isRaining and AUTO_FARM_ENABLED and not isFullyRevealed and not STOP_LOG_COLLECTION do
                        task.wait(2) -- Check every 2 seconds during rain
                        checkRainWarnings() -- Update rain status
                        
                        -- Still check for fire completion during rain pause
                        if isFullyRevealed or getCurrentFireLevel() >= 999 or STOP_LOG_COLLECTION then
                            Fluent:Notify({
                                Title = "FIRE COMPLETE DURING RAIN - BREAKING!",
                                Content = "Fire became fully upgraded during rain pause - exiting!",
                                Duration = 3
                            })
                            break
                        end
                    end
                    
                    -- Exit if fire completed during rain or auto farm disabled
                    if not AUTO_FARM_ENABLED or isFullyRevealed or STOP_LOG_COLLECTION then
                        break
                    end
                    
                    -- Rain cleared, continue with tree farming
                    continue
                end
                
                -- Check for diamond chest during tree farming, but only attempt enhanced sequence after fire is fully upgraded
                if diamondChestDetected and not strongholdTimerActive then
                    Fluent:Notify({
                        Title = "Diamond Chest Waiting",
                        Content = "Diamond Chest detected, waiting for fire to fully upgrade before enhanced sequence.",
                        Duration = 2
                    })
                elseif diamondChestDetected and strongholdTimerActive then
                    Fluent:Notify({
                        Title = "Diamond Chest Waiting",
                        Content = "Diamond Chest detected, waiting for stronghold timer to finish and fire to fully upgrade.",
                        Duration = 2
                    })
                end
                
                local treePosition = findSmallTree()
                if treePosition then
                    teleportToPosition(treePosition)
                    task.wait(2)
                    
                    local treesRemaining = countSmallTrees()
                    while treesRemaining > 0 and AUTO_FARM_ENABLED and not isFullyRevealed and not STOP_LOG_COLLECTION do
                        local chopped = chopSmallTrees() -- NO weapon equipping inside this loop
                        if chopped > 0 then
                            Fluent:Notify({
                                Title = "Tree Chopping",
                                Content = "Chopped " .. chopped .. " Small Trees (weapon stays equipped)",
                                Duration = 1
                            })
                        end
                        
                        task.wait(0.5) -- REDUCED from 1 second to 0.5 for faster tree chopping
                        treesRemaining = countSmallTrees()
                        
                        -- CRITICAL: Check fire completion during tree chopping
                        if isFullyRevealed or getCurrentFireLevel() >= 999 or STOP_LOG_COLLECTION then
                            Fluent:Notify({
                                Title = "FIRE COMPLETE - STOPPING TREE CHOP!",
                                Content = "Fire became fully upgraded - stopping tree chopping immediately!",
                                Duration = 2
                            })
                            break
                        end
                    end
                else
                    local fallbackCFrame = getNextFallbackPosition()
                    teleportToPosition(fallbackCFrame)
                    task.wait(2)
                    
                    local chopped = chopSmallTrees() -- NO weapon equipping in fallback either
                    if chopped > 0 then
                        Fluent:Notify({
                            Title = "Trees Found at Fallback",
                            Content = "Chopped " .. chopped .. " Small Trees at fallback (weapon persistent)",
                            Duration = 2
                        })
                    end
                    
                    task.wait(2) -- REDUCED from 3 seconds to 2 for faster fallback transitions
                end
                
                -- CRITICAL: Check again before log collection
                if isFullyRevealed or getCurrentFireLevel() >= 999 or STOP_LOG_COLLECTION then
                    Fluent:Notify({
                        Title = "FIRE COMPLETE - SKIPPING LOG COLLECTION!",
                        Content = "Fire is fully upgraded - skipping log collection to move on immediately!",
                        Duration = 2
                    })
                    break -- EXIT IMMEDIATELY, NO LOG COLLECTION
                end
                
                if not isFullyRevealed and getCurrentFireLevel() < 999 and not STOP_LOG_COLLECTION then
                    local mainFirePos = getMainFirePosition()
                    teleportToPosition(mainFirePos)
                    task.wait(1.5) -- REDUCED from 2 seconds to 1.5 for faster fire transitions
                    
                    local collected = collectLogsToMainFire() -- This function now has IMMEDIATE STOP capability
                    if collected > 0 then
                        Fluent:Notify({
                            Title = "Logs Collected (Lower Height)",
                            Content = "Collected " .. collected .. " logs to Main Fire at optimized height",
                            Duration = 2
                        })
                    end
                    
                    task.wait(1) -- REDUCED from 2 seconds to 1 for faster overall cycle
                else
                    -- Fire became complete during the cycle - break immediately
                    break
                end
                
                -- FINAL CHECK: Check fire level and proceed to enhanced diamond chest sequence if fully upgraded
                if isFullyRevealed or getCurrentFireLevel() >= 999 or STOP_LOG_COLLECTION then
                    Fluent:Notify({
                        Title = "FIRE COMPLETE - PROCEEDING TO DIAMOND CHEST!",
                        Content = "Fire is fully upgraded - proceeding to diamond chest sequence immediately!",
                        Duration = 3
                    })
                    
                    if diamondChestDetected and not strongholdTimerActive then
                        local success, message = attemptDiamondChestTeleport()
                        if success then
                            ALL_PHASES_COMPLETED = true
                            executeExternalScript()
                            AUTO_FARM_ENABLED = false
                            return
                        else
                            teleportAttemptCount = teleportAttemptCount + 1
                            Fluent:Notify({
                                Title = "Diamond Chest Sequence Failed",
                                Content = message .. " (Attempt " .. teleportAttemptCount .. "/" .. maxTeleportAttempts .. "). Continuing to map unlock.",
                                Duration = 5
                            })
                            lastTeleportAttemptTime = tick()
                            if teleportAttemptCount >= maxTeleportAttempts then
                                Fluent:Notify({
                                    Title = "Max Teleport Attempts Reached",
                                    Content = "Failed enhanced diamond chest sequence after " .. maxTeleportAttempts .. " attempts. Continuing to map unlock.",
                                    Duration = 5
                                })
                                diamondChestDetected = false -- Reset to allow re-detection
                            end
                        end
                    end
                    break -- EXIT tree farming loop
                end
            end
        else
            Fluent:Notify({
                Title = "Phase 2 Complete - FIRE ALREADY MAXED",
                Content = "Tree farming phase complete - fire already fully upgraded. MOVING ON!",
                Duration = 3
            })
        end
        
        -- Disable rain detection when exiting tree farming phase
        rainDetectionActive = false
        
        if isFullyRevealed or fireLevel >= 999 or STOP_LOG_COLLECTION then
            Fluent:Notify({
                Title = "Tree Farming Complete - MOVING ON FAST!",
                Content = "Step 3/4: Fire fully upgraded! Starting map unlock immediately...",
                Duration = 5
            })
            
            -- STEP 3: Unlock all map areas
            unlockAllMapAreas()
            
            -- Wait for map unlocking to complete
            while not stopMapUnlocking and AUTO_FARM_ENABLED do
                -- Check for diamond chest during map unlock
                if diamondChestDetected and not strongholdTimerActive and (tick() - lastTeleportAttemptTime) >= teleportCooldown then
                    if teleportAttemptCount < maxTeleportAttempts then
                        local success, message = attemptDiamondChestTeleport()
                        if success then
                            ALL_PHASES_COMPLETED = true
                            executeExternalScript()
                            AUTO_FARM_ENABLED = false
                            return
                        else
                            teleportAttemptCount = teleportAttemptCount + 1
                            Fluent:Notify({
                                Title = "Diamond Chest Sequence Failed",
                                Content = message .. " (Attempt " .. teleportAttemptCount .. "/" .. maxTeleportAttempts .. "). Continuing map unlock.",
                                Duration = 5
                            })
                            lastTeleportAttemptTime = tick()
                        end
                    else
                        Fluent:Notify({
                            Title = "Max Teleport Attempts Reached",
                            Content = "Failed enhanced diamond chest sequence after " .. maxTeleportAttempts .. " attempts. Continuing map unlock.",
                            Duration = 5
                        })
                        diamondChestDetected = false -- Reset to allow re-detection
                    end
                end
                
                local parts = getValidMapUnlockParts(workspace.Map.Boundaries.Fog)
                if #parts == 0 then
                    break
                end
                task.wait(1)
            end
            
            Fluent:Notify({
                Title = "Map Unlock Complete - FINAL PHASE!",
                Content = "Step 4/4: Starting children collection in 2 seconds... (FIXED RECOVERY)",
                Duration = 3
            })
            
            -- Wait 2 seconds before starting children collection
            task.wait(2)
            
            -- Final check for diamond chest before children collection
            if AUTO_FARM_ENABLED and diamondChestDetected and not strongholdTimerActive then
                local success, message = attemptDiamondChestTeleport()
                if success then
                    ALL_PHASES_COMPLETED = true
                    executeExternalScript()
                    AUTO_FARM_ENABLED = false
                    return
                else
                    teleportAttemptCount = teleportAttemptCount + 1
                    Fluent:Notify({
                        Title = "Diamond Chest Sequence Failed",
                        Content = message .. " (Attempt " .. teleportAttemptCount .. "/" .. maxTeleportAttempts .. "). Proceeding with children collection.",
                        Duration = 5
                    })
                    lastTeleportAttemptTime = tick()
                    if teleportAttemptCount >= maxTeleportAttempts then
                        Fluent:Notify({
                            Title = "Max Teleport Attempts Reached",
                            Content = "Failed enhanced diamond chest sequence after " .. maxTeleportAttempts .. " attempts. Proceeding with children collection.",
                            Duration = 5
                        })
                        diamondChestDetected = false
                    end
                end
            end
            
            -- STEP 4: Collect all children with FIXED smart recovery
            if AUTO_FARM_ENABLED then
                collectAllChildren()
                
                -- Wait for children collection to complete
                while not childrenCollectionComplete and AUTO_FARM_ENABLED do
                    task.wait(1)
                end
                
                Fluent:Notify({
                    Title = "COMPLETE AUTO FARM FINISHED - FIXED!",
                    Content = "All steps completed successfully with FIXED smart recovery system for children collection!",
                    Duration = 10
                })
            end
            
            -- Mark all phases as completed and execute external script
            ALL_PHASES_COMPLETED = true
            if isFullyRevealed or getCurrentFireLevel() >= 999 then
                executeExternalScript()
            end
            AUTO_FARM_ENABLED = false
        end
    end)
end

-- Create GUI
local Window = Fluent:CreateWindow({
    Title = "Ultimate Auto Farm Tool",
    SubTitle = "Complete Automation + Enhanced Diamond Chest Detection",
    TabWidth = 140,
    Size = UDim2.fromOffset(450, 300),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local FarmTab = Window:AddTab({ Title = "Auto Farm", Icon = "zap" })

-- FARM TAB GUI Elements
FarmTab:AddSection("Complete Auto Farm System")

local AutoFarmToggle = FarmTab:AddToggle("CompleteAutoFarm", {
    Title = "Complete Auto Farm (All-in-One) - FIXED RECOVERY",
    Default = false,
    Callback = function(Value)
        AUTO_FARM_ENABLED = Value
        if Value then
            if isFullyRevealed then
                Fluent:Notify({
                    Title = "Already Complete",
                    Content = "Fire is already fully upgraded!",
                    Duration = 3
                })
                AUTO_FARM_ENABLED = false
                return
            end
            
            startCompleteAutoFarm()
            Fluent:Notify({
                Title = "FIXED Auto Farm Started",
                Content = "Running: Fast Fog Clear â†’ INSTANT STOP Tree Farm â†’ Map Unlock â†’ FIXED Smart Children Collection + Enhanced Diamond Chest Integration",
                Duration = 5
            })
        else
            stopTweening = true
            stopMapUnlocking = true
            STOP_LOG_COLLECTION = true -- Set stop flag
            Fluent:Notify({
                Title = "Auto Farm Stopped",
                Content = "All automation stopped with IMMEDIATE STOP capability",
                Duration = 2
            })
        end
    end
})

-- Initialize systems
initializeFireLevelTracking()
--initializeStrongholdTracking()
-- Diamond chest detection moved to stronghold timer system

-- Auto-enable anti-void in background
if ANTI_VOID_ENABLED then
    enableAntiVoid()
end
