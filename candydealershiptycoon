local CandyFarm = {}

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local Halloween2025 = workspace:WaitForChild("Halloween2025")
local Mazes = Halloween2025:WaitForChild("Mazes")
local collectEvent = ReplicatedStorage:WaitForChild("Databases"):WaitForChild("Halloween2025"):WaitForChild("CollectCandy")

CandyFarm.Running = false
CandyFarm.CurrentMap = nil

CandyFarm.Maps = {
	FastPumpkin = {
		Name = "Fast Pumpkin",
		Maze = Mazes:WaitForChild("Cornfield2"),
		FastMode = true,
	},
	Stronghold = {
		Name = "Stronghold",
		Maze = Mazes:WaitForChild("Castle1"),
	},
	ScarecrowSprint = {
		Name = "Scarecrow Sprint",
		Maze = Mazes:WaitForChild("Cornfield1"),
	},
	GraveyardGauntlet = {
		Name = "Graveyard Gauntlet",
		Maze = Mazes:WaitForChild("Castle2"),
	},
	PumpkinPathway = {
		Name = "Pumpkin Pathway",
		Maze = Mazes:WaitForChild("Cornfield2"),
	},
}

local function tweenTo(hrp, targetCFrame, duration)
	local tween = TweenService:Create(
		hrp,
		TweenInfo.new(duration or 0.5, Enum.EasingStyle.Linear),
		{CFrame = targetCFrame}
	)
	tween:Play()
	tween.Completed:Wait()
end

local function getAllCandies(candyFolder)
	local candies = {}
	for _, candy in pairs(candyFolder:GetChildren()) do
		if candy:IsA("Model") and candy:FindFirstChild("RootPart") then
			table.insert(candies, candy)
		end
	end
	return candies
end

function CandyFarm:StartFast(mapData, statusCallback)
	self.Running = true
	self.CurrentMap = mapData
	
	task.spawn(function()
		while self.Running do
			local char = player.Character
			if not char then 
				if statusCallback then statusCallback("No Character") end
				task.wait(1)
				continue 
			end
			
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if not hrp then 
				if statusCallback then statusCallback("No HRP") end
				task.wait(1)
				continue 
			end
			
			local maze = mapData.Maze
			local candyFolder = maze:FindFirstChild("Candy")
			local startPoint = maze:FindFirstChild("Start")
			local finishPoint = maze:FindFirstChild("Finish")
			
			if not candyFolder or not startPoint or not finishPoint then
				if statusCallback then statusCallback("Map Error") end
				task.wait(2)
				continue
			end
			
			local firstCandy = nil
			for _, candy in pairs(candyFolder:GetChildren()) do
				if candy:IsA("Model") and candy:FindFirstChild("RootPart") then
					firstCandy = candy
					break
				end
			end
			
			if firstCandy then
				if statusCallback then statusCallback("Going to Start") end
				tweenTo(hrp, startPoint.CFrame + Vector3.new(0, 3, 0), 0.5)
				task.wait(0.1)
				
				if statusCallback then statusCallback("Collecting Candy") end
				tweenTo(hrp, firstCandy.RootPart.CFrame + Vector3.new(0, 3, 0), 0.5)
				task.wait(0.1)
				
				pcall(function()
					collectEvent:InvokeServer(firstCandy)
				end)
				
				if statusCallback then statusCallback("Completing") end
				local finishPos = finishPoint.Position
				local finishSize = finishPoint.Size
				
				local leftOutside = finishPos - Vector3.new(finishSize.X/2 + 5, -3, 0)
				local rightInside = finishPos + Vector3.new(finishSize.X/2 - 2, 3, 0)
				
				tweenTo(hrp, CFrame.new(leftOutside), 0.5)
				task.wait(0.05)
				tweenTo(hrp, CFrame.new(rightInside), 0.5)
				task.wait(0.2)
			else
				if statusCallback then statusCallback("No Candy - Returning") end
				tweenTo(hrp, startPoint.CFrame + Vector3.new(0, 3, 0), 0.5)
				task.wait(2)
			end
			
			task.wait(0.1)
		end
		
		if statusCallback then statusCallback("Stopped") end
	end)
end

function CandyFarm:StartFull(mapData, statusCallback)
	self.Running = true
	self.CurrentMap = mapData
	
	task.spawn(function()
		while self.Running do
			local char = player.Character
			if not char then 
				if statusCallback then statusCallback("No Character") end
				task.wait(1)
				continue 
			end
			
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if not hrp then 
				if statusCallback then statusCallback("No HRP") end
				task.wait(1)
				continue 
			end
			
			local maze = mapData.Maze
			local candyFolder = maze:FindFirstChild("Candy")
			local startPoint = maze:FindFirstChild("Start")
			local finishPoint = maze:FindFirstChild("Finish")
			
			if not candyFolder or not startPoint or not finishPoint then
				if statusCallback then statusCallback("Map Error") end
				task.wait(2)
				continue
			end
			
			local candies = getAllCandies(candyFolder)
			
			if #candies == 0 then
				if statusCallback then statusCallback("No Candies") end
				tweenTo(hrp, startPoint.CFrame + Vector3.new(0, 3, 0), 0.5)
				task.wait(3)
				continue
			end
			
			if statusCallback then statusCallback("Going to Start") end
			tweenTo(hrp, startPoint.CFrame + Vector3.new(0, 3, 0), 0.5)
			task.wait(0.2)
			
			for i, candy in ipairs(candies) do
				if not self.Running then break end
				
				if statusCallback then statusCallback(string.format("Candy %d/%d", i, #candies)) end
				
				tweenTo(hrp, candy.RootPart.CFrame + Vector3.new(0, 3, 0), 0.3)
				task.wait(0.1)
				
				pcall(function()
					collectEvent:InvokeServer(candy)
				end)
				
				task.wait(0.1)
			end
			
			if not self.Running then break end
			
			if statusCallback then statusCallback("Completing") end
			local finishPos = finishPoint.Position
			local finishSize = finishPoint.Size
			
			local leftOutside = finishPos - Vector3.new(finishSize.X/2 + 5, -3, 0)
			local rightInside = finishPos + Vector3.new(finishSize.X/2 - 2, 3, 0)
			
			tweenTo(hrp, CFrame.new(leftOutside), 0.5)
			task.wait(0.1)
			tweenTo(hrp, CFrame.new(rightInside), 0.5)
			task.wait(0.3)
			
			if statusCallback then statusCallback("Complete - Restarting") end
			task.wait(0.5)
		end
		
		if statusCallback then statusCallback("Stopped") end
	end)
end

function CandyFarm:Stop()
	self.Running = false
	self.CurrentMap = nil
end

return CandyFarm
