-- Protected Script (Thai)
-- Script ID: af8b107ba78995d9628a36bca4658124
-- Created: 2026-01-03T00:53:15.686Z
-- Source: External API
-- Auto-generated by Lua Script Vault

local CoreGui = game:GetService("CoreGui")
local guiName = "LinoriaGui"
local targetParent = gethui and gethui() or CoreGui

for _, Interface in ipairs(targetParent:GetChildren()) do
    if Interface.Name == guiName then
        pcall(function()
            Interface:Destroy()
        end)
    end
end

if gethui then
    for _, Interface in ipairs(CoreGui:GetChildren()) do
        if Interface.Name == guiName then
            pcall(function()
                Interface:Destroy()
            end)
        end
    end
end

_G.ComboWickLoaded = nil
_G.VaultInitialized = nil
_G.VaultVersionToken = nil
getgenv().VaultReady = nil

task.wait(0.1)

_G.ComboWickLoaded = true

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local VaultModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/checkurasshole/MainModule/refs/heads/main/MainModule"))()
local HttpService = game:GetService("HttpService")
local RbxAnalytics = game:GetService("RbxAnalyticsService")
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer

getgenv().VaultReady = false

VaultModule.VALIDATION_STATE.sessionToken = VaultModule.generateSessionToken("init")

local clientId = tostring(RbxAnalytics:GetClientId() or "")
if clientId == "" then
    return {
        success = false,
        error = "‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏Ñ‡∏•‡πÄ‡∏≠‡πá‡∏ô‡∏ï‡πå ID"
    }
end

local encryptedClientId = VaultModule.encrypt(clientId, VaultModule.CONFIG.MASTER_KEY)

local versionValid, versionMessage, fetchedToken = VaultModule.checkVersionAndToken()
if not versionValid then
    Library:Notify({
        Title = '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∏‡πà‡∏ô',
        Description = versionMessage,
        Time = 10,
    })
    return {
        success = false,
        error = "version_check_failed",
        message = versionMessage
    }
end

if VaultModule.compareVersions(VaultModule.CONFIG.VERSION, '1.3.2') <= 0 then
    Library:Notify({
        Title = '‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï',
        Description = '‡∏£‡∏∏‡πà‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡πÅ‡∏•‡πâ‡∏ß ‡πÇ‡∏õ‡∏£‡∏î‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∏‡πà‡∏ô ' .. VaultModule.CONFIG.MIN_VERSION .. ' ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤',
        Time = 10,
    })
    return {
        success = false,
        error = "legacy_version",
        message = "‡∏£‡∏∏‡πà‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡πÅ‡∏•‡πâ‡∏ß"
    }
end

_G.VaultInitialized = true
_G.VaultVersionToken = fetchedToken

local whitelisted, matchData, errorType = VaultModule.isClientIdWhitelisted(clientId, encryptedClientId)

if not whitelisted or errorType == "access_denied" or errorType == "tamper_detected" or errorType == "key_expired" then
    local Window = Library:CreateWindow({
        Title = "COMBO_WICK",
        Footer = "‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏£‡∏∏‡πà‡∏ô " .. VaultModule.CONFIG.VERSION,
        Icon = 18928661286,
        Size = UDim2.new(0, 580, 0, 380),
        Resizable = false,
        ShowCustomCursor = false,
    })
    
    local Tabs = {
        Validation = Window:AddTab("‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á", "key"),
        Info = Window:AddTab("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏•‡∏¥‡∏á‡∏Å‡πå", "info")
    }
        
    local validationComplete = false
    local validationSuccess = false
    
    local MainGroup = Tabs.Validation:AddLeftGroupbox("‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏µ‡∏¢‡πå API")
    
    local savedKey = VaultModule.loadKey()
    local keyInputValue = savedKey or ""
    
    MainGroup:AddInput("KeyInput", {
        Default = keyInputValue,
        Numeric = false,
        Finished = true,
        ClearTextOnFocus = false,
        Text = "‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏µ‡∏¢‡πå",
        Placeholder = "‡∏ß‡∏≤‡∏á‡∏Ñ‡∏µ‡∏¢‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà...",
        Callback = function(value)
            keyInputValue = value
        end
    })
    
    MainGroup:AddButton({
        Text = "‚úÖ ‡∏™‡πà‡∏á‡∏Ñ‡∏µ‡∏¢‡πå",
        Func = function()
            local key = VaultModule.trim(keyInputValue)
            
            if key == "" then
                Library:Notify({
                    Title = "‚ö†Ô∏è ‡∏Ñ‡∏µ‡∏¢‡πå‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤",
                    Description = "‡πÇ‡∏õ‡∏£‡∏î‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏µ‡∏¢‡πå‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
                    Time = 3
                })
                return
            end
            
            local success = VaultModule.validateKey(key, clientId, Library)
            
            if success then
                validationSuccess = true
                validationComplete = true
                
                wait(2)
                Library:Unload()
            end
        end
    })
    
    MainGroup:AddButton({
        Text = "üîó ‡∏£‡∏±‡∏ö‡∏Ñ‡∏µ‡∏¢‡πå‡∏•‡∏¥‡πâ‡∏á‡∏Ñ‡πå",
        Func = function()
            setclipboard("https://chronicle-secure-admin-dashboard-kappa.vercel.app/verify/provider-select")
            Library:Notify({
                Title = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß",
                Description = "‡∏•‡∏¥‡πâ‡∏á‡∏Ñ‡πå‡∏Ñ‡∏µ‡∏¢‡πå‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏•‡∏¥‡∏õ‡∏ö‡∏≠‡∏£‡πå‡∏î",
                Time = 2
            })
        end
    })
    
    local LinksGroup = Tabs.Info:AddLeftGroupbox("‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏î‡πà‡∏ß‡∏ô")

    LinksGroup:AddButton({
        Text = "‡∏ä‡πà‡∏≠‡∏á Youtube",
        Func = function()
            setclipboard("https://www.youtube.com/@COMBO_WICK")
            Library:Notify({
                Title = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß",
                Description = "‡∏•‡∏¥‡∏á‡∏Å‡πå Youtube ‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏•‡∏¥‡∏õ‡∏ö‡∏≠‡∏£‡πå‡∏î",
                Time = 2
            })
        end
    })
    
    LinksGroup:AddButton({
        Text = "‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå Discord",
        Func = function()
            setclipboard("https://discord.gg/9FWBQnVXCy")
            Library:Notify({
                Title = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß",
                Description = "‡∏•‡∏¥‡∏á‡∏Å‡πå Discord ‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏•‡∏¥‡∏õ‡∏ö‡∏≠‡∏£‡πå‡∏î",
                Time = 2
            })
        end
    })
    
    local HWIDGroup = Tabs.Info:AddRightGroupbox("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• HWID")
    
    HWIDGroup:AddLabel({
        Text = "HWID ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì:",
        DoesWrap = false,
    })
    
    HWIDGroup:AddLabel({
        Text = clientId,
        DoesWrap = true,
    })
    
    HWIDGroup:AddDivider()
    
    HWIDGroup:AddButton({
        Text = "üìã ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å HWID",
        Func = function()
            setclipboard(clientId)
            Library:Notify({
                Title = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß",
                Description = "HWID ‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏•‡∏¥‡∏õ‡∏ö‡∏≠‡∏£‡πå‡∏î",
                Time = 2
            })
        end
    })
    
    local timeout = 300
    local elapsed = 0
    while not validationComplete and elapsed < timeout do
        task.wait(1)
        elapsed = elapsed + 1
    end
    
    if validationSuccess then
        task.wait(1)
        
        VaultModule.resetCache(clientId)
        
        whitelisted, matchData, errorType = VaultModule.isClientIdWhitelisted(clientId, encryptedClientId)
        
        if whitelisted then
            VaultModule.startSessionMonitoring(clientId)
            
            getgenv().VaultReady = true
            
            Library:Notify({
                Title = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î",
                Description = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå...",
                Time = 2
            })
            
            local scriptApiUrl = VaultModule.getScriptApiUrl()
            local defaultScriptUrl = VaultModule.getDefaultScriptUrl()
            
            local scriptToLoad = defaultScriptUrl
            
            local success, response = pcall(function()
                return VaultModule.httpRequest({
                    Url = scriptApiUrl,
                    Method = 'GET',
                })
            end)
            
            if success and response and response.Body then
                local parseSuccess, data = pcall(function()
                    return HttpService:JSONDecode(response.Body)
                end)
                
                if parseSuccess and data then
                    local gameIdStr = tostring(game.PlaceId)
                    if data[gameIdStr] then
                        scriptToLoad = data[gameIdStr]
                    elseif data['default'] then
                        scriptToLoad = data['default']
                    end
                end
            end
            
            VaultModule.memoryCleanup:disconnectAll()
            
            if type(scriptToLoad) == 'table' then
                for i, url in ipairs(scriptToLoad) do
                    spawn(function()
                        pcall(function()
                            loadstring(game:HttpGet(url:match('^[^%s]+')))()
                        end)
                    end)
                end
            else
                spawn(function()
                    pcall(function()
                        loadstring(game:HttpGet(scriptToLoad:match('^[^%s]+')))()
                    end)
                end)
            end
            
            return {
                success = true,
                whitelisted = true,
                matchData = matchData,
                validated = true,
                sessionToken = VaultModule.VALIDATION_STATE.sessionToken
            }
        else
            return {
                success = false,
                error = "not_whitelisted_after_validation"
            }
        end
    else
        return {
            success = false,
            error = "validation_cancelled"
        }
    end
end

if whitelisted then
    VaultModule.startSessionMonitoring(clientId)
    
    getgenv().VaultReady = true
    
    Library:Notify({
        Title = "‡∏£‡∏±‡∏ö‡∏£‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß",
        Description = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå...",
        Time = 2
    })
    
    local scriptApiUrl = VaultModule.getScriptApiUrl()
    local defaultScriptUrl = VaultModule.getDefaultScriptUrl()
    
    local scriptToLoad = defaultScriptUrl
    
    local success, response = pcall(function()
        return VaultModule.httpRequest({
            Url = scriptApiUrl,
            Method = 'GET',
        })
    end)
    
    if success and response and response.Body then
        local parseSuccess, data = pcall(function()
            return HttpService:JSONDecode(response.Body)
        end)
        
        if parseSuccess and data then
            local gameIdStr = tostring(game.PlaceId)
            if data[gameIdStr] then
                scriptToLoad = data[gameIdStr]
            elseif data['default'] then
                scriptToLoad = data['default']
            end
        end
    end
    
    VaultModule.memoryCleanup:disconnectAll()
    
    if type(scriptToLoad) == 'table' then
        for i, url in ipairs(scriptToLoad) do
            spawn(function()
                pcall(function()
                    loadstring(game:HttpGet(url:match('^[^%s]+')))()
                end)
            end)
        end
    else
        spawn(function()
            pcall(function()
                loadstring(game:HttpGet(scriptToLoad:match('^[^%s]+')))()
            end)
        end)
    end
    
    return {
        success = true,
        whitelisted = true,
        matchData = matchData,
        sessionToken = VaultModule.VALIDATION_STATE.sessionToken
    }
else
    return {
        success = false,
        whitelisted = false
    }
end