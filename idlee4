local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer

-- Create movable GUI toggle button
local ScreenGui = Instance.new("ScreenGui")
local ToggleButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local UIStroke = Instance.new("UIStroke")

ScreenGui.Name = "ComboWickToggle"
ScreenGui.Parent = game.CoreGui
ScreenGui.ResetOnSpawn = false

ToggleButton.Parent = ScreenGui
ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
ToggleButton.BorderSizePixel = 0
ToggleButton.Position = UDim2.new(0, 20, 0, 100)
ToggleButton.Size = UDim2.new(0, 120, 0, 40)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Text = "COMBO_WICK"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 12
ToggleButton.Active = true
ToggleButton.Draggable = true

UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = ToggleButton

UIStroke.Parent = ToggleButton
UIStroke.Color = Color3.fromRGB(0, 150, 255)
UIStroke.Thickness = 2

-- Animate button on hover
ToggleButton.MouseEnter:Connect(function()
    local tween = TweenService:Create(ToggleButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    })
    tween:Play()
end)

ToggleButton.MouseLeave:Connect(function()
    local tween = TweenService:Create(ToggleButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    })
    tween:Play()
end)

-- GLOBAL VARIABLES
local ragdoll
local char
local parts = {}
local boxSize = Vector3.new(50,30,50)
local walls = {}
local flingStrength = 300
local flingInterval = 0.03
local active = false
local spinning = false
local flingConnection
local boundsConnection
local boxCenter
local spinSpeed = 20
local autoBuyLeg = false
local autoBuyArm = false
local autoBuyTorso = false
local autoBuyHead = false

local PurchaseBoneUpgrade = ReplicatedStorage.Remotes.PurchaseBoneUpgrade
local afkConnections = {}
local autoBuyLoops = {}

-- Function to find ragdoll with flexible searching
local function findRagdoll()
    char = player.Character
    if not char then return nil end
    
    -- Method 1: Look in workspace for player's folder
    local playerFolder = workspace:FindFirstChild(player.Name)
    if playerFolder then
        local ragdollFolder = playerFolder:FindFirstChild("Ragdoll")
        if ragdollFolder then
            -- Try Default first
            local defaultRagdoll = ragdollFolder:FindFirstChild("Default")
            if defaultRagdoll then
                return defaultRagdoll
            end
            -- If no Default, get first child that looks like a ragdoll
            for _, child in pairs(ragdollFolder:GetChildren()) do
                if child:IsA("Model") or child:IsA("Folder") then
                    return child
                end
            end
        end
    end
    
    -- Method 2: Look directly in character
    if char:FindFirstChild("Ragdoll") then
        local ragdollFolder = char.Ragdoll
        local defaultRagdoll = ragdollFolder:FindFirstChild("Default")
        if defaultRagdoll then
            return defaultRagdoll
        end
        for _, child in pairs(ragdollFolder:GetChildren()) do
            if child:IsA("Model") or child:IsA("Folder") then
                return child
            end
        end
    end
    
    -- Method 3: Look in workspace root for ragdoll-like objects
    for _, obj in pairs(workspace:GetChildren()) do
        if obj.Name:find(player.Name) and (obj.Name:find("Ragdoll") or obj.Name:find("ragdoll")) then
            return obj
        end
    end
    
    return nil
end

-- Function to initialize character and ragdoll
local function initializeCharacterAndRagdoll()
    char = player.Character or player.CharacterAdded:Wait()
    
    -- Find ragdoll
    ragdoll = findRagdoll()
    parts = {}
    
    if not ragdoll then
        -- Wait and try again
        wait(1)
        ragdoll = findRagdoll()
    end
    
    if not ragdoll then
        print("Could not find ragdoll. Make sure you're spawned in the game.")
        return false
    end
    
    -- Update parts list
    parts = {}
    for _, part in pairs(ragdoll:GetChildren()) do
        if part:IsA("BasePart") then
            table.insert(parts, part)
        end
    end
    
    print("Character and ragdoll initialized! Found " .. #parts .. " parts")
    return ragdoll ~= nil
end

-- Function to refresh ragdoll and parts when needed
local function refreshRagdollData()
    if not ragdoll or not ragdoll.Parent then
        print("Ragdoll lost, searching for new one...")
        ragdoll = findRagdoll()
        if not ragdoll then
            return false
        end
    end
    
    -- Check if parts are still valid
    local validParts = {}
    for _, part in ipairs(parts) do
        if part and part.Parent then
            table.insert(validParts, part)
        end
    end
    
    -- If we lost parts, refresh the parts list
    if #validParts < #parts then
        parts = {}
        for _, part in pairs(ragdoll:GetChildren()) do
            if part:IsA("BasePart") then
                table.insert(parts, part)
            end
        end
        print("Refreshed parts list: " .. #parts .. " parts found")
    end
    
    return true
end

local function startAntiAFK()
    afkConnections[1] = game:GetService("Players").LocalPlayer.Idled:connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
        wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    end)
    
    afkConnections[2] = RunService.Heartbeat:Connect(function()
        if math.random(1,600) == 1 then
            VirtualUser:MoveMouse(Vector2.new(math.random(-50,50), math.random(-50,50)))
        end
    end)
    
    afkConnections[3] = spawn(function()
        while wait(300) do
            keypress(0x20)
            wait(0.1)
            keyrelease(0x20)
        end
    end)
    
    afkConnections[4] = spawn(function()
        while wait(120) do
            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(".", "All")
            wait(0.5)
        end
    end)
end

local function stopAntiAFK()
    for i, connection in pairs(afkConnections) do
        if connection then
            if type(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            end
        end
    end
    afkConnections = {}
end

-- Better box center updating with validation
local function updateBoxCenter()
    if not ragdoll or not ragdoll.Parent then
        refreshRagdollData()
        if not ragdoll then return false end
    end
    
    if ragdoll:FindFirstChild("HumanoidRootPart") then
        boxCenter = ragdoll.HumanoidRootPart.Position
        return true
    elseif ragdoll:FindFirstChild("Torso") then
        boxCenter = ragdoll.Torso.Position
        return true
    else
        -- Try to find any valid part to center on
        for _, part in pairs(ragdoll:GetChildren()) do
            if part:IsA("BasePart") then
                boxCenter = part.Position
                return true
            end
        end
    end
    return false
end

local function createWall(position, size)
    local wall = Instance.new("Part")
    wall.Name = "FlingWall"
    wall.Anchored = true
    wall.CanCollide = true
    wall.Transparency = 0.3
    wall.Material = Enum.Material.Neon
    wall.BrickColor = BrickColor.new("Bright blue")
    wall.Size = size
    wall.Position = position
    wall.Parent = workspace
    
    if size.X <= 3 then
        wall.Size = Vector3.new(5, size.Y, size.Z)
    elseif size.Y <= 3 then
        wall.Size = Vector3.new(size.X, 5, size.Z)
    elseif size.Z <= 3 then
        wall.Size = Vector3.new(size.X, size.Y, 5)
    end
    
    local selectionBox = Instance.new("SelectionBox")
    selectionBox.Adornee = wall
    selectionBox.Color3 = Color3.fromRGB(0, 150, 255)
    selectionBox.LineThickness = 0.2
    selectionBox.Transparency = 0.5
    selectionBox.Parent = wall
    
    table.insert(walls, wall)
end

local function generateWalls()
    if not updateBoxCenter() then
        print("Failed to update box center, cannot generate walls")
        return false
    end
    
    local s = boxSize/2
    createWall(boxCenter + Vector3.new(s.X, 0, 0), Vector3.new(2, boxSize.Y, boxSize.Z))
    createWall(boxCenter - Vector3.new(s.X, 0, 0), Vector3.new(2, boxSize.Y, boxSize.Z))
    createWall(boxCenter + Vector3.new(0, s.Y, 0), Vector3.new(boxSize.X, 2, boxSize.Z))
    createWall(boxCenter - Vector3.new(0, s.Y, 0), Vector3.new(boxSize.X, 2, boxSize.Z))
    createWall(boxCenter + Vector3.new(0, 0, s.Z), Vector3.new(boxSize.X, boxSize.Y, 2))
    createWall(boxCenter - Vector3.new(0, 0, s.Z), Vector3.new(boxSize.X, boxSize.Y, 2))
    
    return true
end

-- Improved bounds checking with ragdoll validation
local function keepInBounds()
    if not refreshRagdollData() or not updateBoxCenter() then return end
    
    local buffer = 3
    local s = boxSize/2 - Vector3.new(buffer, buffer, buffer)
    local minBounds = boxCenter - s
    local maxBounds = boxCenter + s
    
    for _, part in ipairs(parts) do
        if part and part.Parent and part:IsA("BasePart") then
            local partPos = part.Position
            local needsCorrection = false
            local correctedPos = partPos
            
            if partPos.X < minBounds.X then 
                correctedPos = Vector3.new(minBounds.X + 1, correctedPos.Y, correctedPos.Z)
                needsCorrection = true
            elseif partPos.X > maxBounds.X then
                correctedPos = Vector3.new(maxBounds.X - 1, correctedPos.Y, correctedPos.Z)
                needsCorrection = true
            end
            
            if partPos.Y < minBounds.Y then
                correctedPos = Vector3.new(correctedPos.X, minBounds.Y + 1, correctedPos.Z)
                needsCorrection = true
            elseif partPos.Y > maxBounds.Y then
                correctedPos = Vector3.new(correctedPos.X, maxBounds.Y - 1, correctedPos.Z)
                needsCorrection = true
            end
            
            if partPos.Z < minBounds.Z then
                correctedPos = Vector3.new(correctedPos.X, correctedPos.Y, minBounds.Z + 1)
                needsCorrection = true
            elseif partPos.Z > maxBounds.Z then
                correctedPos = Vector3.new(correctedPos.X, correctedPos.Y, maxBounds.Z - 1)
                needsCorrection = true
            end
            
            if needsCorrection then
                part.CFrame = CFrame.new(correctedPos, correctedPos + (boxCenter - correctedPos).Unit)
                
                for _, obj in pairs(part:GetChildren()) do
                    if obj:IsA("BodyVelocity") and obj.Name ~= "Spinning" then
                        obj:Destroy()
                    end
                end
                
                local bounceDirection = (boxCenter - correctedPos).Unit
                local safeVelocity = bounceDirection * math.min(flingStrength, 400)
                
                local bounceForce = Instance.new("BodyVelocity")
                bounceForce.Velocity = safeVelocity
                bounceForce.MaxForce = Vector3.new(5e4, 5e4, 5e4)
                bounceForce.P = 8e4
                bounceForce.Parent = part
                Debris:AddItem(bounceForce, 0.2)
            end
        end
    end
end

-- Improved spinning with ragdoll validation
local function startSpin()
    if not refreshRagdollData() then return false end
    
    local rootPart = ragdoll:FindFirstChild("HumanoidRootPart") or ragdoll:FindFirstChild("Torso")
    if not rootPart then
        -- Find any valid part to spin
        for _, part in pairs(ragdoll:GetChildren()) do
            if part:IsA("BasePart") then
                rootPart = part
                break
            end
        end
    end
    
    if not rootPart then return false end
    
    for i,v in pairs(rootPart:GetChildren()) do
        if v.Name == "Spinning" then
            v:Destroy()
        end
    end
    
    local Spin = Instance.new("BodyAngularVelocity")
    Spin.Name = "Spinning"
    Spin.Parent = rootPart
    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
    Spin.AngularVelocity = Vector3.new(0, spinSpeed, 0)
    spinning = true
    return true
end

local function stopSpin()
    if ragdoll and ragdoll.Parent then
        for _, part in pairs(ragdoll:GetChildren()) do
            if part:IsA("BasePart") then
                for i,v in pairs(part:GetChildren()) do
                    if v.Name == "Spinning" then
                        v:Destroy()
                    end
                end
            end
        end
    end
    spinning = false
end

-- Improved flinging with better validation
local function flingRagdoll()
    if not active or not refreshRagdollData() or not updateBoxCenter() then return end
    
    for _, part in ipairs(parts) do
        if part and part.Parent and part:IsA("BasePart") then
            -- Clean up existing body movers first
            for _, obj in pairs(part:GetChildren()) do
                if obj:IsA("BodyVelocity") and obj.Name ~= "Spinning" then
                    obj:Destroy()
                end
            end
            
            local partPos = part.Position
            local centerDirection = (boxCenter - partPos).Unit
            local randomDirection = Vector3.new(
                math.random(-100, 100)/100,
                math.random(-100, 100)/100,
                math.random(-100, 100)/100
            )
            
            local safeDirection = (centerDirection * 0.3 + randomDirection * 0.7).Unit
            local maxSafeForce = math.min(flingStrength, 600)
            local forceMultiplier = math.random(50, 100)/100
            local randomForce = safeDirection * (maxSafeForce * forceMultiplier)
            
            local bv = Instance.new("BodyVelocity")
            bv.Velocity = randomForce
            bv.MaxForce = Vector3.new(6e4, 6e4, 6e4)
            bv.P = 5e4
            bv.Parent = part
            Debris:AddItem(bv, flingInterval * 2)
            
            -- Random impulse for extra chaos
            if math.random() > 0.7 then
                local impulse = Instance.new("BodyVelocity")
                impulse.Velocity = Vector3.new(
                    math.random(-200, 200),
                    math.random(-150, 250),
                    math.random(-200, 200)
                )
                impulse.MaxForce = Vector3.new(3e4, 3e4, 3e4)
                impulse.P = 4e4
                impulse.Parent = part
                Debris:AddItem(impulse, 0.1)
            end
        end
    end
end

local function safeStopAllMovement()
    -- Stop all body movers on all parts
    if ragdoll and ragdoll.Parent then
        for _, part in pairs(ragdoll:GetChildren()) do
            if part:IsA("BasePart") then
                for _, obj in pairs(part:GetChildren()) do
                    if obj:IsA("BodyMover") then
                        obj:Destroy()
                    end
                end
                -- Set velocity to zero immediately
                part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end
        end
    end
    
    -- Small delay to ensure physics settle
    wait(0.1)
    
    -- Then destroy walls
    for _, wall in ipairs(walls) do
        if wall and wall.Parent then
            wall:Destroy()
        end
    end
    walls = {}
end

-- Better start function with proper initialization
local function startFling()
    print("Starting fling system...")
    
    -- Make sure we have valid ragdoll and parts
    if not initializeCharacterAndRagdoll() then
        print("Failed to initialize character/ragdoll!")
        return false
    end
    
    active = true
    
    -- Generate walls
    if not generateWalls() then
        print("Failed to generate walls!")
        active = false
        return false
    end
    
    -- Start spinning
    if not startSpin() then
        print("Failed to start spinning!")
    end
    
    -- Start fling loop
    flingConnection = spawn(function()
        while active do
            if ragdoll and ragdoll.Parent then
                flingRagdoll()
            else
                print("Lost ragdoll during fling, attempting to recover...")
                if not refreshRagdollData() then
                    print("Failed to recover ragdoll, stopping fling")
                    break
                end
            end
            wait(flingInterval)
        end
    end)
    
    -- Keep bounds checking on Heartbeat for responsiveness
    boundsConnection = RunService.Heartbeat:Connect(function()
        if active then
            keepInBounds()
        end
    end)
    
    print("Fling system started successfully!")
    return true
end

local function stopFling()
    print("Stopping fling system...")
    active = false
    
    if flingConnection then
        flingConnection = nil
    end
    
    if boundsConnection then
        boundsConnection:Disconnect()
        boundsConnection = nil
    end
    
    stopSpin()
    safeStopAllMovement()
    
    print("Fling system stopped!")
end

local function startAutoBuy(partName)
    autoBuyLoops[partName] = spawn(function()
        while true do
            if partName == "Leg" and autoBuyLeg then
                PurchaseBoneUpgrade:FireServer("Leg")
            elseif partName == "Arm" and autoBuyArm then
                PurchaseBoneUpgrade:FireServer("Arm")
            elseif partName == "Torso" and autoBuyTorso then
                PurchaseBoneUpgrade:FireServer("Torso")
            elseif partName == "Head" and autoBuyHead then
                PurchaseBoneUpgrade:FireServer("Head")
            end
            wait(0.1)
        end
    end)
end

local function stopAutoBuy(partName)
    if autoBuyLoops[partName] then
        autoBuyLoops[partName] = nil
    end
end

-- Initialize on script start
initializeCharacterAndRagdoll()

local Window = Fluent:CreateWindow({
    Title = "COMBO_WICK",
    SubTitle = "",
    TabWidth = 160,
    Size = UDim2.fromOffset(350, 250),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "activity" }),
    Shop = Window:AddTab({ Title = "Shop", Icon = "shopping-cart" }),
    AntiAFK = Window:AddTab({ Title = "No Kick", Icon = "shield" })
}

-- Store reference to the Fluent window for toggling
local FluentWindow = Window
local guiVisible = true

-- GUI Toggle functionality with complete hiding
local fluentGuis = {}

local function findAllFluentGuis()
    fluentGuis = {}
    
    for _, gui in pairs(game.CoreGui:GetChildren()) do
        if gui:IsA("ScreenGui") and gui ~= ScreenGui then
            local isFluentGui = false
            
            if gui.Name:lower():find("fluent") or gui.Name:lower():find("library") then
                isFluentGui = true
            end
            
            if gui:FindFirstChild("Main") then
                local main = gui.Main
                if main:FindFirstChild("Navigation") and main:FindFirstChild("TabContainer") then
                    isFluentGui = true
                end
            end
            
            for _, child in pairs(gui:GetDescendants()) do
                if child.Name == "Acrylic" or child.Name == "DropShadow" or 
                   (child:IsA("TextLabel") and child.Text == "COMBO_WICK") then
                    isFluentGui = true
                    break
                end
            end
            
            if not isFluentGui and gui:FindFirstChildWhichIsA("Frame") then
                local frame = gui:FindFirstChildWhichIsA("Frame")
                if frame.Size.X.Scale > 0.1 and frame.Size.Y.Scale > 0.1 then
                    isFluentGui = true
                end
            end
            
            if isFluentGui then
                table.insert(fluentGuis, gui)
            end
        end
    end
end

ToggleButton.MouseButton1Click:Connect(function()
    guiVisible = not guiVisible
    
    findAllFluentGuis()
    
    for _, gui in pairs(fluentGuis) do
        if gui and gui.Parent then
            gui.Enabled = guiVisible
            
            for _, child in pairs(gui:GetChildren()) do
                if child:IsA("GuiObject") then
                    child.Visible = guiVisible
                end
            end
        end
    end
    
    if not guiVisible then
        for _, gui in pairs(game.CoreGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui ~= ScreenGui then
                for _, element in pairs(gui:GetDescendants()) do
                    if element:IsA("GuiObject") and (
                        element.Name:lower():find("fluent") or 
                        element.Name:lower():find("main") or 
                        element.Name:lower():find("window") or
                        element.Name:lower():find("tab") or
                        element.Name:lower():find("navigation")
                    ) then
                        element.Visible = false
                    end
                end
            end
        end
    end
    
    print("Toggled " .. #fluentGuis .. " GUI(s) to " .. tostring(guiVisible))
    
    if guiVisible then
        ToggleButton.Text = "COMBO_WICK"
        UIStroke.Color = Color3.fromRGB(0, 150, 255)
        ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    else
        ToggleButton.Text = "HIDDEN"  
        UIStroke.Color = Color3.fromRGB(255, 100, 100)
        ToggleButton.BackgroundColor3 = Color3.fromRGB(60, 30, 30)
    end
end)

Tabs.Main:AddToggle("BounceToggle", {
    Title = "Start Autofarm",
    Default = false,
    Callback = function(Value)
        if Value then
            if startFling() then
                Fluent:Notify({
                    Title = "Autofarm Started",
                    Content = "Fling system is now active!",
                    Duration = 3
                })
            else
                Fluent:Notify({
                    Title = "Start Failed",
                    Content = "Could not initialize fling system. Try again.",
                    Duration = 3
                })
            end
        else
            stopFling()
            Fluent:Notify({
                Title = "Autofarm Stopped", 
                Content = "Fling system has been disabled.",
                Duration = 3
            })
        end
    end
})

Tabs.Main:AddSlider("PowerSlider", {
    Title = "Power & Speed",
    Default = 300,
    Min = 100,
    Max = 1000,
    Rounding = 10,
    Callback = function(Value)
        flingStrength = Value
        spinSpeed = math.floor(Value / 15)
        if spinning and ragdoll and ragdoll.Parent then
            -- Update all spinning parts
            for _, part in pairs(ragdoll:GetChildren()) do
                if part:IsA("BasePart") then
                    for i,v in pairs(part:GetChildren()) do
                        if v.Name == "Spinning" then
                            v.AngularVelocity = Vector3.new(0, spinSpeed, 0)
                        end
                    end
                end
            end
        end
    end
})

local currentPower = 300
Tabs.Main:AddButton({
    Title = "Power -50",
    Description = "Decrease power by 50",
    Callback = function()
        currentPower = math.max(100, currentPower - 50)
        flingStrength = currentPower
        spinSpeed = math.floor(currentPower / 15)
        if spinning and ragdoll and ragdoll.Parent then
            for _, part in pairs(ragdoll:GetChildren()) do
                if part:IsA("BasePart") then
                    for i,v in pairs(part:GetChildren()) do
                        if v.Name == "Spinning" then
                            v.AngularVelocity = Vector3.new(0, spinSpeed, 0)
                        end
                    end
                end
            end
        end
        Fluent:Notify({
            Title = "Power Updated",
            Content = "Power set to: " .. currentPower,
            Duration = 2
        })
    end
})

Tabs.Main:AddButton({
    Title = "Power +50",
    Description = "Increase power by 50",
    Callback = function()
        currentPower = math.min(1000, currentPower + 50)
        flingStrength = currentPower
        spinSpeed = math.floor(currentPower / 15)
        if spinning and ragdoll and ragdoll.Parent then
            for _, part in pairs(ragdoll:GetChildren()) do
                if part:IsA("BasePart") then
                    for i,v in pairs(part:GetChildren()) do
                        if v.Name == "Spinning" then
                            v.AngularVelocity = Vector3.new(0, spinSpeed, 0)
                        end
                    end
                end
            end
        end
        Fluent:Notify({
            Title = "Power Updated",
            Content = "Power set to: " .. currentPower,
            Duration = 3
        })
    end
})

Tabs.Shop:AddToggle("AutoLeg", {
    Title = "Auto Buy Legs",
    Default = false,
    Callback = function(Value)
        autoBuyLeg = Value
        if Value then
            startAutoBuy("Leg")
        else
            stopAutoBuy("Leg")
        end
    end
})

Tabs.Shop:AddToggle("AutoArm", {
    Title = "Auto Buy Arms", 
    Default = false,
    Callback = function(Value)
        autoBuyArm = Value
        if Value then
            startAutoBuy("Arm")
        else
            stopAutoBuy("Arm")
        end
    end
})

Tabs.Shop:AddToggle("AutoTorso", {
    Title = "Auto Buy Torso",
    Default = false,
    Callback = function(Value)
        autoBuyTorso = Value
        if Value then
            startAutoBuy("Torso")
        else
            stopAutoBuy("Torso")
        end
    end
})

Tabs.Shop:AddToggle("AutoHead", {
    Title = "Auto Buy Head",
    Default = false,
    Callback = function(Value)
        autoBuyHead = Value
        if Value then
            startAutoBuy("Head")
        else
            stopAutoBuy("Head")
        end
    end
})

Tabs.AntiAFK:AddToggle("AntiAFKToggle", {
    Title = "Anti AFK",
    Default = false,
    Callback = function(Value)
        if Value then
            startAntiAFK()
        else
            stopAntiAFK()
        end
    end
})

Window:SelectTab(1)

-- Simple cleanup and restart on character respawn
player.CharacterAdded:Connect(function(newChar)
    print("Character respawned, reinitializing...")
    
    -- Stop current system if running
    if active then
        stopFling()
    end
    
    -- Wait a bit for character to fully load
    wait(2)
    
    -- Reinitialize everything
    if initializeCharacterAndRagdoll() then
        print("Successfully reinitialized after respawn!")
        Fluent:Notify({
            Title = "Respawn Detected",
            Content = "System reinitialized. You can restart autofarm.",
            Duration = 4
        })
    else
        print("Failed to reinitialize after respawn")
        Fluent:Notify({
            Title = "Respawn Issue",
            Content = "Please wait and try starting autofarm again.",
            Duration = 4
        })
    end
end)

-- Add manual refresh button
Tabs.Main:AddButton({
    Title = "ðŸ”„ Refresh Character",
    Description = "Use this if having issues finding ragdoll",
    Callback = function()
        print("Manual refresh triggered...")
        
        -- Stop current system if running
        if active then
            stopFling()
        end
        
        -- Force reinitialization
        if initializeCharacterAndRagdoll() then
            Fluent:Notify({
                Title = "Character Refreshed",
                Content = "Successfully reloaded ragdoll!",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Refresh Failed",
                Content = "Could not find ragdoll. Make sure you're spawned in game.",
                Duration = 4
            })
        end
    end
})

-- Initial notification
Fluent:Notify({
    Title = "COMBO_WICK Loaded",
    Content = "Use the toggle button to hide/show GUI! Fixed for all accounts.",
    Duration = 5
})
