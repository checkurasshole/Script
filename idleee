local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer

-- Create movable GUI toggle button
local ScreenGui = Instance.new("ScreenGui")
local ToggleButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local UIStroke = Instance.new("UIStroke")

ScreenGui.Name = "ComboWickToggle"
ScreenGui.Parent = game.CoreGui
ScreenGui.ResetOnSpawn = false

ToggleButton.Parent = ScreenGui
ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
ToggleButton.BorderSizePixel = 0
ToggleButton.Position = UDim2.new(0, 20, 0, 100)
ToggleButton.Size = UDim2.new(0, 120, 0, 40)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Text = "COMBO_WICK"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 12
ToggleButton.Active = true
ToggleButton.Draggable = true

UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = ToggleButton

UIStroke.Parent = ToggleButton
UIStroke.Color = Color3.fromRGB(0, 150, 255)
UIStroke.Thickness = 2

-- Animate button on hover
ToggleButton.MouseEnter:Connect(function()
    local tween = TweenService:Create(ToggleButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    })
    tween:Play()
end)

ToggleButton.MouseLeave:Connect(function()
    local tween = TweenService:Create(ToggleButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    })
    tween:Play()
end)

-- GLOBAL VARIABLES
local ragdoll
local char
local parts = {}
local boxSize = Vector3.new(50,30,50)
local walls = {}
local flingStrength = 300
local flingInterval = 0.03
local active = false
local spinning = false
local flingConnection
local boundsConnection
local boxCenter
local spinSpeed = 20
local autoBuyLeg = false
local autoBuyArm = false
local autoBuyTorso = false
local autoBuyHead = false

local PurchaseBoneUpgrade = ReplicatedStorage.Remotes.PurchaseBoneUpgrade
local afkConnections = {}
local autoBuyLoops = {}

-- Function to get current ragdoll dynamically
local function getCurrentRagdoll()
    local currentPlayer = Players.LocalPlayer
    if workspace:FindFirstChild(currentPlayer.Name) and workspace[currentPlayer.Name]:FindFirstChild("Ragdoll") then
        return workspace[currentPlayer.Name].Ragdoll.Default
    end
    return nil
end

-- Function to get current parts dynamically
local function getCurrentParts()
    local currentRagdoll = getCurrentRagdoll()
    if not currentRagdoll then return {} end
    
    local currentParts = {}
    for _, part in pairs(currentRagdoll:GetChildren()) do
        if part:IsA("BasePart") then
            table.insert(currentParts, part)
        end
    end
    return currentParts
end

-- Function to validate and refresh ragdoll data
local function refreshRagdollData()
    player = Players.LocalPlayer -- Update player reference
    char = player.Character
    ragdoll = getCurrentRagdoll()
    parts = getCurrentParts()
    
    if ragdoll and #parts > 0 then
        print("Ragdoll refreshed for " .. player.Name .. ". Found " .. #parts .. " parts.")
        return true
    else
        print("Failed to find ragdoll or parts for " .. player.Name)
        return false
    end
end

local function startAntiAFK()
    afkConnections[1] = game:GetService("Players").LocalPlayer.Idled:connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
        wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    end)
    
    afkConnections[2] = RunService.Heartbeat:Connect(function()
        if math.random(1,600) == 1 then
            VirtualUser:MoveMouse(Vector2.new(math.random(-50,50), math.random(-50,50)))
        end
    end)
    
    afkConnections[3] = spawn(function()
        while wait(300) do
            keypress(0x20)
            wait(0.1)
            keyrelease(0x20)
        end
    end)
    
    afkConnections[4] = spawn(function()
        while wait(120) do
            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(".", "All")
            wait(0.5)
        end
    end)
end

local function stopAntiAFK()
    for i, connection in pairs(afkConnections) do
        if connection then
            if type(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            end
        end
    end
    afkConnections = {}
end

-- Dynamic box center updating
local function updateBoxCenter()
    local currentRagdoll = getCurrentRagdoll()
    if not currentRagdoll then return false end
    
    if currentRagdoll:FindFirstChild("HumanoidRootPart") then
        boxCenter = currentRagdoll.HumanoidRootPart.Position
        return true
    elseif currentRagdoll:FindFirstChild("Torso") then
        boxCenter = currentRagdoll.Torso.Position
        return true
    else
        -- Try to find any valid part to center on
        local currentParts = getCurrentParts()
        if #currentParts > 0 then
            boxCenter = currentParts[1].Position
            return true
        end
    end
    return false
end

local function createWall(position, size)
    local wall = Instance.new("Part")
    wall.Name = "FlingWall"
    wall.Anchored = true
    wall.CanCollide = true
    wall.Transparency = 0.3
    wall.Material = Enum.Material.Neon
    wall.BrickColor = BrickColor.new("Bright blue")
    wall.Size = size
    wall.Position = position
    wall.Parent = workspace
    
    if size.X <= 3 then
        wall.Size = Vector3.new(5, size.Y, size.Z)
    elseif size.Y <= 3 then
        wall.Size = Vector3.new(size.X, 5, size.Z)
    elseif size.Z <= 3 then
        wall.Size = Vector3.new(size.X, size.Y, 5)
    end
    
    local selectionBox = Instance.new("SelectionBox")
    selectionBox.Adornee = wall
    selectionBox.Color3 = Color3.fromRGB(0, 150, 255)
    selectionBox.LineThickness = 0.2
    selectionBox.Transparency = 0.5
    selectionBox.Parent = wall
    
    table.insert(walls, wall)
end

local function generateWalls()
    if not updateBoxCenter() then
        print("Failed to update box center, cannot generate walls")
        return false
    end
    
    local s = boxSize/2
    createWall(boxCenter + Vector3.new(s.X, 0, 0), Vector3.new(2, boxSize.Y, boxSize.Z))
    createWall(boxCenter - Vector3.new(s.X, 0, 0), Vector3.new(2, boxSize.Y, boxSize.Z))
    createWall(boxCenter + Vector3.new(0, s.Y, 0), Vector3.new(boxSize.X, 2, boxSize.Z))
    createWall(boxCenter - Vector3.new(0, s.Y, 0), Vector3.new(boxSize.X, 2, boxSize.Z))
    createWall(boxCenter + Vector3.new(0, 0, s.Z), Vector3.new(boxSize.X, boxSize.Y, 2))
    createWall(boxCenter - Vector3.new(0, 0, s.Z), Vector3.new(boxSize.X, boxSize.Y, 2))
    
    return true
end

-- Dynamic bounds checking
local function keepInBounds()
    local currentParts = getCurrentParts()
    if #currentParts == 0 or not updateBoxCenter() then return end
    
    local buffer = 3
    local s = boxSize/2 - Vector3.new(buffer, buffer, buffer)
    local minBounds = boxCenter - s
    local maxBounds = boxCenter + s
    
    for _, part in ipairs(currentParts) do
        if part and part.Parent and part:IsA("BasePart") then
            local partPos = part.Position
            local needsCorrection = false
            local correctedPos = partPos
            
            if partPos.X < minBounds.X then 
                correctedPos = Vector3.new(minBounds.X + 1, correctedPos.Y, correctedPos.Z)
                needsCorrection = true
            elseif partPos.X > maxBounds.X then
                correctedPos = Vector3.new(maxBounds.X - 1, correctedPos.Y, correctedPos.Z)
                needsCorrection = true
            end
            
            if partPos.Y < minBounds.Y then
                correctedPos = Vector3.new(correctedPos.X, minBounds.Y + 1, correctedPos.Z)
                needsCorrection = true
            elseif partPos.Y > maxBounds.Y then
                correctedPos = Vector3.new(correctedPos.X, maxBounds.Y - 1, correctedPos.Z)
                needsCorrection = true
            end
            
            if partPos.Z < minBounds.Z then
                correctedPos = Vector3.new(correctedPos.X, correctedPos.Y, minBounds.Z + 1)
                needsCorrection = true
            elseif partPos.Z > maxBounds.Z then
                correctedPos = Vector3.new(correctedPos.X, correctedPos.Y, maxBounds.Z - 1)
                needsCorrection = true
            end
            
            if needsCorrection then
                part.CFrame = CFrame.new(correctedPos, correctedPos + (boxCenter - correctedPos).Unit)
                
                for _, obj in pairs(part:GetChildren()) do
                    if obj:IsA("BodyVelocity") and obj.Name ~= "Spinning" then
                        obj:Destroy()
                    end
                end
                
                local bounceDirection = (boxCenter - correctedPos).Unit
                local safeVelocity = bounceDirection * math.min(flingStrength, 400)
                
                local bounceForce = Instance.new("BodyVelocity")
                bounceForce.Velocity = safeVelocity
                bounceForce.MaxForce = Vector3.new(5e4, 5e4, 5e4)
                bounceForce.P = 8e4
                bounceForce.Parent = part
                Debris:AddItem(bounceForce, 0.2)
            end
        end
    end
end

-- Dynamic spinning
local function startSpin()
    local currentRagdoll = getCurrentRagdoll()
    if not currentRagdoll then return false end
    
    local rootPart = currentRagdoll:FindFirstChild("HumanoidRootPart") or currentRagdoll:FindFirstChild("Torso")
    if not rootPart then
        -- Find any valid part to spin
        local currentParts = getCurrentParts()
        if #currentParts > 0 then
            rootPart = currentParts[1]
        end
    end
    
    if not rootPart then return false end
    
    for i,v in pairs(rootPart:GetChildren()) do
        if v.Name == "Spinning" then
            v:Destroy()
        end
    end
    
    local Spin = Instance.new("BodyAngularVelocity")
    Spin.Name = "Spinning"
    Spin.Parent = rootPart
    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
    Spin.AngularVelocity = Vector3.new(0, spinSpeed, 0)
    spinning = true
    return true
end

local function stopSpin()
    local currentRagdoll = getCurrentRagdoll()
    if currentRagdoll then
        for _, part in pairs(currentRagdoll:GetChildren()) do
            if part:IsA("BasePart") then
                for i,v in pairs(part:GetChildren()) do
                    if v.Name == "Spinning" then
                        v:Destroy()
                    end
                end
            end
        end
    end
    spinning = false
end

-- Dynamic flinging
local function flingRagdoll()
    if not active then return end
    
    local currentParts = getCurrentParts()
    if #currentParts == 0 or not updateBoxCenter() then 
        print("No parts found or box center invalid, refreshing ragdoll...")
        refreshRagdollData()
        return 
    end
    
    for _, part in ipairs(currentParts) do
        if part and part.Parent and part:IsA("BasePart") then
            -- Clean up existing body movers first
            for _, obj in pairs(part:GetChildren()) do
                if obj:IsA("BodyVelocity") and obj.Name ~= "Spinning" then
                    obj:Destroy()
                end
            end
            
            local partPos = part.Position
            local centerDirection = (boxCenter - partPos).Unit
            local randomDirection = Vector3.new(
                math.random(-100, 100)/100,
                math.random(-100, 100)/100,
                math.random(-100, 100)/100
            )
            
            local safeDirection = (centerDirection * 0.3 + randomDirection * 0.7).Unit
            local maxSafeForce = math.min(flingStrength, 600)
            local forceMultiplier = math.random(50, 100)/100
            local randomForce = safeDirection * (maxSafeForce * forceMultiplier)
            
            local bv = Instance.new("BodyVelocity")
            bv.Velocity = randomForce
            bv.MaxForce = Vector3.new(6e4, 6e4, 6e4)
            bv.P = 5e4
            bv.Parent = part
            Debris:AddItem(bv, flingInterval * 2)
            
            -- Random impulse for extra chaos
            if math.random() > 0.7 then
                local impulse = Instance.new("BodyVelocity")
                impulse.Velocity = Vector3.new(
                    math.random(-200, 200),
                    math.random(-150, 250),
                    math.random(-200, 200)
                )
                impulse.MaxForce = Vector3.new(3e4, 3e4, 3e4)
                impulse.P = 4e4
                impulse.Parent = part
                Debris:AddItem(impulse, 0.1)
            end
        end
    end
end

local function safeStopAllMovement()
    local currentParts = getCurrentParts()
    
    -- Stop all body movers on all parts
    for _, part in ipairs(currentParts) do
        if part and part.Parent then
            for _, obj in pairs(part:GetChildren()) do
                if obj:IsA("BodyMover") then
                    obj:Destroy()
                end
            end
            -- Set velocity to zero immediately
            if part:IsA("BasePart") then
                part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end
        end
    end
    
    -- Small delay to ensure physics settle
    wait(0.1)
    
    -- Then destroy walls
    for _, wall in ipairs(walls) do
        if wall and wall.Parent then
            wall:Destroy()
        end
    end
    walls = {}
end

-- Improved start function
local function startFling()
    print("Starting fling system...")
    
    -- Refresh ragdoll data first
    if not refreshRagdollData() then
        print("Failed to initialize ragdoll!")
        return false
    end
    
    active = true
    
    -- Generate walls
    if not generateWalls() then
        print("Failed to generate walls!")
        active = false
        return false
    end
    
    -- Start spinning
    if not startSpin() then
        print("Failed to start spinning!")
    end
    
    -- Start fling loop with better error handling
    flingConnection = spawn(function()
        while active do
            local success, err = pcall(flingRagdoll)
            if not success then
                print("Error in fling loop: " .. tostring(err))
                wait(1) -- Wait longer on error
            else
                wait(flingInterval)
            end
        end
    end)
    
    -- Keep bounds checking on Heartbeat for responsiveness
    boundsConnection = RunService.Heartbeat:Connect(function()
        if active then
            local success, err = pcall(keepInBounds)
            if not success then
                print("Error in bounds check: " .. tostring(err))
            end
        end
    end)
    
    print("Fling system started successfully!")
    return true
end

local function stopFling()
    print("Stopping fling system...")
    active = false
    
    if flingConnection then
        flingConnection = nil
    end
    
    if boundsConnection then
        boundsConnection:Disconnect()
        boundsConnection = nil
    end
    
    stopSpin()
    safeStopAllMovement()
    
    print("Fling system stopped!")
end

local function startAutoBuy(partName)
    autoBuyLoops[partName] = spawn(function()
        while true do
            if partName == "Leg" and autoBuyLeg then
                PurchaseBoneUpgrade:FireServer("Leg")
            elseif partName == "Arm" and autoBuyArm then
                PurchaseBoneUpgrade:FireServer("Arm")
            elseif partName == "Torso" and autoBuyTorso then
                PurchaseBoneUpgrade:FireServer("Torso")
            elseif partName == "Head" and autoBuyHead then
                PurchaseBoneUpgrade:FireServer("Head")
            end
            wait(0.1)
        end
    end)
end

local function stopAutoBuy(partName)
    if autoBuyLoops[partName] then
        autoBuyLoops[partName] = nil
    end
end

-- Initialize on script start
refreshRagdollData()

local Window = Fluent:CreateWindow({
    Title = "COMBO_WICK",
    SubTitle = "",
    TabWidth = 160,
    Size = UDim2.fromOffset(350, 250),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "activity" }),
    Shop = Window:AddTab({ Title = "Shop", Icon = "shopping-cart" }),
    AntiAFK = Window:AddTab({ Title = "No Kick", Icon = "shield" })
}

-- GUI Toggle functionality
local guiVisible = true
local fluentGuis = {}

local function findAllFluentGuis()
    fluentGuis = {}
    
    for _, gui in pairs(game.CoreGui:GetChildren()) do
        if gui:IsA("ScreenGui") and gui ~= ScreenGui then
            local isFluentGui = false
            
            if gui.Name:lower():find("fluent") or gui.Name:lower():find("library") then
                isFluentGui = true
            end
            
            if gui:FindFirstChild("Main") then
                local main = gui.Main
                if main:FindFirstChild("Navigation") and main:FindFirstChild("TabContainer") then
                    isFluentGui = true
                end
            end
            
            for _, child in pairs(gui:GetDescendants()) do
                if child.Name == "Acrylic" or child.Name == "DropShadow" or 
                   (child:IsA("TextLabel") and child.Text == "COMBO_WICK") then
                    isFluentGui = true
                    break
                end
            end
            
            if isFluentGui then
                table.insert(fluentGuis, gui)
            end
        end
    end
end

ToggleButton.MouseButton1Click:Connect(function()
    guiVisible = not guiVisible
    
    findAllFluentGuis()
    
    for _, gui in pairs(fluentGuis) do
        if gui and gui.Parent then
            gui.Enabled = guiVisible
        end
    end
    
    print("Toggled " .. #fluentGuis .. " GUI(s) to " .. tostring(guiVisible))
    
    if guiVisible then
        ToggleButton.Text = "COMBO_WICK"
        UIStroke.Color = Color3.fromRGB(0, 150, 255)
        ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    else
        ToggleButton.Text = "HIDDEN"  
        UIStroke.Color = Color3.fromRGB(255, 100, 100)
        ToggleButton.BackgroundColor3 = Color3.fromRGB(60, 30, 30)
    end
end)

Tabs.Main:AddToggle("BounceToggle", {
    Title = "Start Autofarm",
    Default = false,
    Callback = function(Value)
        if Value then
            if startFling() then
                Fluent:Notify({
                    Title = "Autofarm Started",
                    Content = "Fling system is now active!",
                    Duration = 3
                })
            else
                Fluent:Notify({
                    Title = "Start Failed",
                    Content = "Could not initialize fling system. Try refreshing character.",
                    Duration = 3
                })
            end
        else
            stopFling()
            Fluent:Notify({
                Title = "Autofarm Stopped", 
                Content = "Fling system has been disabled.",
                Duration = 3
            })
        end
    end
})

Tabs.Main:AddSlider("PowerSlider", {
    Title = "Power & Speed",
    Default = 300,
    Min = 100,
    Max = 1000,
    Rounding = 10,
    Callback = function(Value)
        flingStrength = Value
        spinSpeed = math.floor(Value / 15)
        if spinning then
            local currentRagdoll = getCurrentRagdoll()
            if currentRagdoll then
                for _, part in pairs(currentRagdoll:GetChildren()) do
                    if part:IsA("BasePart") then
                        for i,v in pairs(part:GetChildren()) do
                            if v.Name == "Spinning" then
                                v.AngularVelocity = Vector3.new(0, spinSpeed, 0)
                            end
                        end
                    end
                end
            end
        end
    end
})

local currentPower = 300
Tabs.Main:AddButton({
    Title = "Power -50",
    Description = "Decrease power by 50",
    Callback = function()
        currentPower = math.max(100, currentPower - 50)
        flingStrength = currentPower
        spinSpeed = math.floor(currentPower / 15)
        if spinning then
            local currentRagdoll = getCurrentRagdoll()
            if currentRagdoll then
                for _, part in pairs(currentRagdoll:GetChildren()) do
                    if part:IsA("BasePart") then
                        for i,v in pairs(part:GetChildren()) do
                            if v.Name == "Spinning" then
                                v.AngularVelocity = Vector3.new(0, spinSpeed, 0)
                            end
                        end
                    end
                end
            end
        end
        Fluent:Notify({
            Title = "Power Updated",
            Content = "Power set to: " .. currentPower,
            Duration = 2
        })
    end
})

Tabs.Main:AddButton({
    Title = "Power +50",
    Description = "Increase power by 50",
    Callback = function()
        currentPower = math.min(1000, currentPower + 50)
        flingStrength = currentPower
        spinSpeed = math.floor(currentPower / 15)
        if spinning then
            local currentRagdoll = getCurrentRagdoll()
            if currentRagdoll then
                for _, part in pairs(currentRagdoll:GetChildren()) do
                    if part:IsA("BasePart") then
                        for i,v in pairs(part:GetChildren()) do
                            if v.Name == "Spinning" then
                                v.AngularVelocity = Vector3.new(0, spinSpeed, 0)
                            end
                        end
                    end
                end
            end
        end
        Fluent:Notify({
            Title = "Power Updated",
            Content = "Power set to: " .. currentPower,
            Duration = 3
        })
    end
})

-- Add manual refresh button
Tabs.Main:AddButton({
    Title = "Refresh Character",
    Description = "Use if having issues or switched accounts",
    Callback = function()
        print("Manual refresh triggered...")
        
        -- Stop current system if running
        if active then
            stopFling()
        end
        
        -- Force reinitialization
        if refreshRagdollData() then
            Fluent:Notify({
                Title = "Character Refreshed",
                Content = "Successfully reloaded for " .. player.Name,
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Refresh Failed",
                Content = "Could not find ragdoll. Make sure you're spawned in game.",
                Duration = 4
            })
        end
    end
})

Tabs.Shop:AddToggle("AutoLeg", {
    Title = "Auto Buy Legs",
    Default = false,
    Callback = function(Value)
        autoBuyLeg = Value
        if Value then
            startAutoBuy("Leg")
        else
            stopAutoBuy("Leg")
        end
    end
})

Tabs.Shop:AddToggle("AutoArm", {
    Title = "Auto Buy Arms", 
    Default = false,
    Callback = function(Value)
        autoBuyArm = Value
        if Value then
            startAutoBuy("Arm")
        else
            stopAutoBuy("Arm")
        end
    end
})

Tabs.Shop:AddToggle("AutoTorso", {
    Title = "Auto Buy Torso",
    Default = false,
    Callback = function(Value)
        autoBuyTorso = Value
        if Value then
            startAutoBuy("Torso")
        else
            stopAutoBuy("Torso")
        end
    end
})

Tabs.Shop:AddToggle("AutoHead", {
    Title = "Auto Buy Head",
    Default = false,
    Callback = function(Value)
        autoBuyHead = Value
        if Value then
            startAutoBuy("Head")
        else
            stopAutoBuy("Head")
        end
    end
})

Tabs.AntiAFK:AddToggle("AntiAFKToggle", {
    Title = "Anti AFK",
    Default = false,
    Callback = function(Value)
        if Value then
            startAntiAFK()
        else
            stopAntiAFK()
        end
    end
})

Window:SelectTab(1)

-- Cleanup on character respawn
player.CharacterAdded:Connect(function(newChar)
    print("Character respawned, stopping current fling...")
    
    -- Stop current system if running
    if active then
        stopFling()
    end
    
    -- Wait for character to fully load, then refresh
    wait(3)
    refreshRagdollData()
    
    Fluent:Notify({
        Title = "Respawn Detected",
        Content = "Character reloaded. You can restart autofarm.",
        Duration = 4
    })
end)

-- Initial notification
Fluent:Notify({
    Title = "COMBO_WICK Loaded",
    Content = "Use toggle button to hide GUI. Works with any account!",
    Duration = 5
})
