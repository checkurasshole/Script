local Module = {}

Module.CONFIG = {
    DefaultHeightOffset = 6,
    MinHeightOffset = -50,
    MaxHeightOffset = 12,
    MaxTeleportDistance = 500,
    SafetyDistance = 50,
}

Module.Variables = {
    teleportToItemsEnabled = false,
    AutoTeleportWasEnabledItems = false,
    radioCompleted = false,
    heliCompleted = false,
    v2Enabled = false,
    v2ObjectiveMode = "Radio + Helicopter",
    ObjectiveAutomationActive = false,
    firing = false,
    v2NoclipConnection = nil,
    doorActivatorEnabled = false,
    teleportToDoorEnabled = false,
    autoActivationConnection = nil,
    v2DoorNoclipConnection = nil,
    processedDoors = {},
    MAX_DISTANCE = 300,
    lastCleanupTime = tick(),
    CLEANUP_INTERVAL = 30,
    noclipEnabled = false,
    noclipConnection = nil,
    TeleportActive = false,
    HeightOffset = 6,
    teleportConnection = nil,
    TargetHead = true,
    TeleportStats = {totalTeleports = 0, lastTarget = "None"},
    SkillToggles = {ZSkill = false, XSkill = false, CSkill = false, VSkill = false, Perk = false},
    BufferSpamActive = false,
    SpamRate = 0.05,
    SkillSpamRate = 0.9,
    TargetMode = "All Zombies",
    currentTarget = nil,
    targetHealthHistory = {},
    healthCheckTime = 0,
    HEALTH_CHECK_INTERVAL = 2,
    targetStartTime = 0,
    doorCache = {},
    targetCache = {},
    CACHE_DURATION = 2,
    isTeleporting = false,
}

Module.Services = {}
Module.Instances = {}

function Module.Initialize(player)
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local CollectionService = game:GetService("CollectionService")
    local ReplicatedFirst = game:GetService("ReplicatedFirst")
    local TweenService = game:GetService("TweenService")
    
    Module.Services.Players = Players
    Module.Services.RunService = RunService
    Module.Services.UserInputService = UserInputService
    Module.Services.ReplicatedStorage = ReplicatedStorage
    Module.Services.CollectionService = CollectionService
    Module.Services.ReplicatedFirst = ReplicatedFirst
    Module.Services.TweenService = TweenService
    
    Module.Instances.Player = player
    Module.Instances.Character = player.Character or player.CharacterAdded:Wait()
    Module.Instances.HumanoidRootPart = Module.Instances.Character:WaitForChild("HumanoidRootPart")
    
    local GameCore = ReplicatedFirst:WaitForChild("GameCore")
    local Shared = GameCore:WaitForChild("Shared")
    Module.Instances.ByteNetPackets = require(Shared:WaitForChild("ByteNetPackets"))
    
    Module.Instances.ByteNetReliable = ReplicatedStorage:WaitForChild("ByteNetReliable")
    
    Module.Variables.SkillBuffers = {
        ZSkill = buffer.fromstring("\9\2\1"),
        XSkill = buffer.fromstring("\9\5\1"),
        CSkill = buffer.fromstring("\9\1\1"),
        VSkill = buffer.fromstring("\9\3\1"),
        Perk = buffer.fromstring("\14")
    }
    Module.Variables.mainAttackBuffer = buffer.fromstring("\9\6\1")
    
    Module.Variables.DefaultJoints = {
        ["Neck"] = { CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
        ["LeftShoulder"] = { CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), CFrame.new(0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0) },
        ["RightShoulder"] = { CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0), CFrame.new(-0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
        ["LeftHip"] = { CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0) },
        ["RightHip"] = { CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0), CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
        ["Root"] = { CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
        ["Waist"] = { CFrame.new(0, 0.2, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), CFrame.new(0, -0.2, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
    }
    
    Module.Variables.ragdollConnections = {}
    Module.Variables.originalJoints = {}
end

function Module.updateCharacterReferences()
    Module.Instances.Character = Module.Instances.Player.Character or Module.Instances.Player.CharacterAdded:Wait()
    Module.Instances.HumanoidRootPart = Module.Instances.Character:WaitForChild("HumanoidRootPart")
end

function Module.isValidPosition(position)
    if not position then return false end
    if position.Y < -1000 then return false end
    if math.abs(position.X) > 10000 or math.abs(position.Z) > 10000 then return false end
    return true
end

function Module.CleanupMemory()
    pcall(function()
        if #Module.Variables.targetCache > 100 then
            local toRemove = #Module.Variables.targetCache - 50
            for i = 1, toRemove do
                table.remove(Module.Variables.targetCache, 1)
            end
        end
        collectgarbage("step", 100)
    end)
end

function Module.isDoorLocked(door)
    local root = door:FindFirstChild("Root")
    if root then
        local collision = root:FindFirstChild("Collision")
        if collision and collision:IsA("BasePart") then
            return collision.CanCollide == true
        end
    end
    return door:GetAttribute("locked") == true
end

function Module.activateAllDoors()
    if not Module.Variables.doorActivatorEnabled then return end
    
    local doors = Module.Services.CollectionService:GetTagged("LEVELDOOR")
    local Character = Module.Instances.Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    for i, door in pairs(doors) do
        if not Module.Variables.doorActivatorEnabled then break end
        if door:GetAttribute("activated") then continue end
        if Module.isDoorLocked(door) then continue end
        
        if Module.Variables.teleportToDoorEnabled then
            local doorPosition = door:GetPivot().Position
            local teleportPos = doorPosition + Vector3.new(0, 5, 0)
            HumanoidRootPart.CFrame = CFrame.new(teleportPos)
            task.wait(0.2)
        end
        
        if not Module.Services.CollectionService:HasTag(door, "_doorwait") then
            Module.Services.CollectionService:AddTag(door, "_doorwait")
            Module.Instances.ByteNetPackets.packets.activateDoor.send(door)
            task.wait(0.1)
        end
    end
end

function Module.setupAutoActivation()
    if Module.Variables.autoActivationConnection then
        Module.Variables.autoActivationConnection:Disconnect()
    end
    
    Module.Variables.autoActivationConnection = Module.Services.CollectionService:GetInstanceAddedSignal("LEVELDOOR"):Connect(function(newDoor)
        if not Module.Variables.doorActivatorEnabled then return end
        task.wait(0.5)
        if Module.Variables.doorActivatorEnabled and not newDoor:GetAttribute("activated") and not newDoor:GetAttribute("locked") then
            if not Module.Services.CollectionService:HasTag(newDoor, "_doorwait") then
                Module.Services.CollectionService:AddTag(newDoor, "_doorwait")
                Module.Instances.ByteNetPackets.packets.activateDoor.send(newDoor)
            end
        end
    end)
end

function Module.disableAutoActivation()
    if Module.Variables.autoActivationConnection then
        Module.Variables.autoActivationConnection:Disconnect()
        Module.Variables.autoActivationConnection = nil
    end
end

function Module.isDoorActivated(door)
    return door:GetAttribute("activated") == true
end

function Module.getDoorPosition(door)
    if door:IsA("Model") then
        if door.PrimaryPart then
            return door.PrimaryPart.Position
        else
            local root = door:FindFirstChild("Root")
            if root and root:IsA("BasePart") then
                return root.Position
            else
                local part = door:FindFirstChildWhichIsA("BasePart", true)
                if part then return part.Position end
            end
        end
    elseif door:IsA("BasePart") then
        return door.Position
    end
    return nil
end

function Module.getUnopenedDoorsNearby()
    local Character = Module.Instances.Player.Character
    if not Character then return {} end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return {} end
    
    local playerPos = HumanoidRootPart.Position
    local doors = Module.Services.CollectionService:GetTagged("LEVELDOOR")
    local unopenedDoors = {}
    
    for _, door in pairs(doors) do
        if door and door.Parent then
            task.wait()
            local roomIndex = door:GetAttribute("roomIndex")
            if not roomIndex then
                task.wait(0.1)
                roomIndex = door:GetAttribute("roomIndex")
            end
            
            if roomIndex and roomIndex >= 2 then
                local doorPos = Module.getDoorPosition(door)
                if doorPos then
                    local distance = (playerPos - doorPos).Magnitude
                    if distance <= Module.Variables.MAX_DISTANCE then
                        if not Module.Variables.processedDoors[door] and not Module.isDoorActivated(door) and not Module.isDoorLocked(door) then
                            table.insert(unopenedDoors, {door = door, position = doorPos, distance = distance, roomIndex = roomIndex})
                        end
                    end
                end
            end
        end
    end
    
    table.sort(unopenedDoors, function(a, b) 
        if a.roomIndex == b.roomIndex then
            return a.distance < b.distance
        end
        return a.roomIndex < b.roomIndex
    end)
    
    return unopenedDoors
end

function Module.cleanupProcessedDoors()
    local toRemove = {}
    local count = 0
    
    for door, _ in pairs(Module.Variables.processedDoors) do
        if not door or not door.Parent then
            table.insert(toRemove, door)
        end
        count = count + 1
    end
    
    for _, door in pairs(toRemove) do
        Module.Variables.processedDoors[door] = nil
    end
    
    if count > 100 then
        local temp = {}
        local kept = 0
        for door, _ in pairs(Module.Variables.processedDoors) do
            if kept < 50 then
                temp[door] = true
                kept = kept + 1
            end
        end
        Module.Variables.processedDoors = temp
    end
end

function Module.tryActivateDoor(door)
    pcall(function()
        local activateEvent = game:GetService("ReplicatedStorage"):FindFirstChild("Packets")
        if activateEvent then
            local activateDoor = activateEvent:FindFirstChild("ActivateDoor")
            if activateDoor then activateDoor:FireServer(door) end
        end
    end)
end

function Module.teleportAndActivateDoors()
    local Character = Module.Instances.Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if tick() - Module.Variables.lastCleanupTime > Module.Variables.CLEANUP_INTERVAL then
        Module.cleanupProcessedDoors()
        Module.Variables.lastCleanupTime = tick()
    end
    
    local unopenedDoors = Module.getUnopenedDoorsNearby()
    if #unopenedDoors == 0 then return end
    
    for _, doorData in pairs(unopenedDoors) do
        if not Module.Variables.teleportToDoorEnabled then break end
        local door = doorData.door
        local doorPosition = doorData.position
        
        if door and door.Parent and doorPosition then
            local tween1 = Module.Services.TweenService:Create(HumanoidRootPart, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {CFrame = CFrame.new(doorPosition)})
            tween1:Play()
            tween1.Completed:Wait()
            task.wait(0.15)
            Module.tryActivateDoor(door)
            task.wait(0.1)
            
            local tween2 = Module.Services.TweenService:Create(HumanoidRootPart, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {CFrame = CFrame.new(doorPosition + Vector3.new(5, 0, 0))})
            tween2:Play()
            tween2.Completed:Wait()
            task.wait(0.1)
            
            local tween3 = Module.Services.TweenService:Create(HumanoidRootPart, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {CFrame = CFrame.new(doorPosition - Vector3.new(5, 0, 0))})
            tween3:Play()
            tween3.Completed:Wait()
            task.wait(0.15)
            Module.Variables.processedDoors[door] = true
        end
    end
end

function Module.enableNoclip()
    if Module.Variables.noclipConnection then return end
    Module.Variables.noclipConnection = Module.Services.RunService.Stepped:Connect(function()
        local character = Module.Instances.Player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then part.CanCollide = false end
            end
        end
    end)
end

function Module.disableNoclip()
    if Module.Variables.noclipConnection then
        Module.Variables.noclipConnection:Disconnect()
        Module.Variables.noclipConnection = nil
    end
    local character = Module.Instances.Player.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then part.CanCollide = true end
        end
    end
end

function Module.enableV2Noclip()
    if Module.Variables.v2NoclipConnection then return end
    Module.Variables.v2NoclipConnection = Module.Services.RunService.Stepped:Connect(function()
        local character = Module.Instances.Player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then part.CanCollide = false end
            end
        end
    end)
end

function Module.disableV2Noclip()
    if Module.Variables.v2NoclipConnection then
        Module.Variables.v2NoclipConnection:Disconnect()
        Module.Variables.v2NoclipConnection = nil
    end
    local character = Module.Instances.Player.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then part.CanCollide = true end
        end
    end
end

function Module.enableV2DoorNoclip()
    if Module.Variables.v2DoorNoclipConnection then return end
    Module.Variables.v2DoorNoclipConnection = Module.Services.RunService.Stepped:Connect(function()
        local character = Module.Instances.Player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then part.CanCollide = false end
            end
        end
    end)
end

function Module.disableV2DoorNoclip()
    if Module.Variables.v2DoorNoclipConnection then
        Module.Variables.v2DoorNoclipConnection:Disconnect()
        Module.Variables.v2DoorNoclipConnection = nil
    end
    local character = Module.Instances.Player.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then part.CanCollide = true end
        end
    end
end

function Module.toggleNoclip(enabled)
    Module.Variables.noclipEnabled = enabled
    if enabled then Module.enableNoclip() else Module.disableNoclip() end
end

function Module.IsMobAlive(entity)
    if not entity or not entity.Parent then return false end
    local head = entity:FindFirstChild("Head")
    if not head then return false end
    local entityHealth = head:FindFirstChild("EntityHealth")
    if not entityHealth then return false end
    local healthBar = entityHealth:FindFirstChild("HealthBar")
    if not healthBar then return false end
    local bar = healthBar:FindFirstChild("Bar")
    if not bar then return false end
    if bar:IsA("Frame") and bar.Size.X.Scale <= 0.01 then return false end
    if bar:IsA("Frame") and bar.BackgroundColor3 == Color3.fromRGB(255, 0, 0) and bar.Size.X.Scale <= 0.1 then return false end
    return true
end

function Module.GetEntityHealth(entity)
    if not entity or not entity.Parent then return nil end
    local head = entity:FindFirstChild("Head")
    if not head then return nil end
    local entityHealth = head:FindFirstChild("EntityHealth")
    if not entityHealth then return nil end
    local healthBar = entityHealth:FindFirstChild("HealthBar")
    if not healthBar then return nil end
    local bar = healthBar:FindFirstChild("Bar")
    if not bar or not bar:IsA("Frame") then return nil end
    return bar.Size.X.Scale
end

function Module.IsTargetTakingDamage(entity)
    if not entity or not entity.Parent then return false end
    local currentTime = tick()
    local currentHealth = Module.GetEntityHealth(entity)
    if not currentHealth then return false end
    
    if Module.Variables.currentTarget ~= entity then
        Module.Variables.currentTarget = entity
        Module.Variables.targetHealthHistory = {currentHealth}
        Module.Variables.targetStartTime = currentTime
        Module.Variables.healthCheckTime = currentTime
        return true
    end
    
    if currentTime - Module.Variables.healthCheckTime >= Module.Variables.HEALTH_CHECK_INTERVAL then
        table.insert(Module.Variables.targetHealthHistory, currentHealth)
        if #Module.Variables.targetHealthHistory > 3 then
            table.remove(Module.Variables.targetHealthHistory, 1)
        end
        Module.Variables.healthCheckTime = currentTime
        
        if currentTime - Module.Variables.targetStartTime >= Module.Variables.HEALTH_CHECK_INTERVAL then
            if #Module.Variables.targetHealthHistory >= 2 then
                local oldHealth = Module.Variables.targetHealthHistory[1]
                local newHealth = Module.Variables.targetHealthHistory[#Module.Variables.targetHealthHistory]
                if oldHealth - newHealth < 0.01 then
                    Module.Variables.currentTarget = nil
                    Module.Variables.targetHealthHistory = {}
                    return false
                end
            end
        end
    end
    return true
end

function Module.GetBestMobTarget()
    local Character = Module.Instances.Player.Character
    if not Character then return nil end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return nil end
    
    local entitiesFolder = workspace:FindFirstChild("Entities")
    if not entitiesFolder then return nil end
    
    local validTargets = {}
    local playerPos = HumanoidRootPart.Position
    local targetParts = Module.Variables.TargetHead and {"Head", "Torso", "HumanoidRootPart"} or {"Left Leg", "Right Leg", "Torso", "HumanoidRootPart"}
    
    local function processEntity(entity)
        if entity.Name ~= "Entities" and entity ~= Character and entity.Name ~= "Highlight" then
            if not Module.IsMobAlive(entity) then return end
            if Module.Variables.currentTarget == entity and not Module.IsTargetTakingDamage(entity) then return end
            if Module.Variables.TargetMode == "Boss Only" then
                local entityID = entity:GetAttribute("EntityID")
                if entityID ~= 8 then return end
            end
            
            for _, partName in ipairs(targetParts) do
                local targetPart = entity:FindFirstChild(partName)
                if targetPart and targetPart:IsA("BasePart") then
                    local distance = (targetPart.Position - playerPos).Magnitude
                    if distance <= Module.CONFIG.MaxTeleportDistance then
                        local targetPos = targetPart.Position
                        if not Module.isValidPosition(targetPos) then return end
                        table.insert(validTargets, {part = targetPart, entity = entity, distance = distance, partName = partName, position = targetPos})
                    end
                    break
                end
            end
        end
    end
    
    for _, entity in pairs(entitiesFolder:GetChildren()) do processEntity(entity) end
    for _, folder in pairs(entitiesFolder:GetChildren()) do
        if folder:IsA("Folder") or folder:IsA("Model") then
            if folder.Name ~= "Highlight" then
                for _, numberedFolder in pairs(folder:GetChildren()) do
                    if numberedFolder:IsA("Model") or numberedFolder:IsA("Folder") then
                        processEntity(numberedFolder)
                    end
                end
            end
        end
    end
    
    table.sort(validTargets, function(a, b) return a.distance < b.distance end)
    if #validTargets > 0 then
        local bestTarget = validTargets[1]
        Module.Variables.TeleportStats.lastTarget = bestTarget.entity.Name
        return bestTarget.position
    end
    return nil
end

function Module.TeleportToMob()
    local Character = Module.Instances.Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    local targetPosition = Module.GetBestMobTarget()
    if not targetPosition then return end
    local finalPosition = targetPosition + Vector3.new(0, Module.Variables.HeightOffset, 0)
    if not Module.isValidPosition(finalPosition) then return end
    
    local currentPos = HumanoidRootPart.Position
    local distance = (currentPos - finalPosition).Magnitude
    if distance > Module.CONFIG.MaxTeleportDistance * 2 then return end
    
    HumanoidRootPart.CFrame = CFrame.new(finalPosition)
    Module.Variables.TeleportStats.totalTeleports = Module.Variables.TeleportStats.totalTeleports + 1
    Module.CleanupMemory()
end

function Module.getItemPosition(item)
    if not item or not item.Parent then return nil end
    local targetPosition = nil
    if item:IsA("BasePart") and item.Position then
        targetPosition = item.Position
    elseif item:IsA("Model") then
        local primaryPart = item.PrimaryPart or item:FindFirstChild("HumanoidRootPart")
        if primaryPart and primaryPart.Position then
            targetPosition = primaryPart.Position
        else
            local part = item:FindFirstChildWhichIsA("BasePart")
            if part and part.Position then targetPosition = part.Position end
        end
    elseif item:FindFirstChildWhichIsA("BasePart") then
        local part = item:FindFirstChildWhichIsA("BasePart")
        if part and part.Position then targetPosition = part.Position end
    end
    return targetPosition
end

function Module.teleportToItems()
    if not Module.Variables.teleportToItemsEnabled then return end
    local character = Module.Instances.Player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    local humanoidRootPart = character.HumanoidRootPart
    local dropItems = workspace:FindFirstChild("DropItems")
    if not dropItems then return end
    
    local originalPosition = humanoidRootPart.CFrame
    local validItems = {}
    local items = dropItems:GetChildren()
    
    for _, item in pairs(items) do
        local position = Module.getItemPosition(item)
        if position and Module.isValidPosition(position) then
            local distance = (humanoidRootPart.Position - position).Magnitude
            if distance < 500 then
                table.insert(validItems, {item = item, position = position, distance = distance, name = item.Name or "Unknown"})
            end
        end
    end
    
    table.sort(validItems, function(a, b) return a.distance < b.distance end)
    local itemCount = #validItems
    if itemCount == 0 then return false end
    
    Module.Variables.isTeleporting = true
    for i, itemData in pairs(validItems) do
        if not Module.Variables.teleportToItemsEnabled then break end
        if itemData.item and itemData.item.Parent then
            local currentPosition = Module.getItemPosition(itemData.item)
            if currentPosition and Module.isValidPosition(currentPosition) then
                local distanceFromOriginal = (originalPosition.Position - currentPosition).Magnitude
                if distanceFromOriginal < 1000 then
                    pcall(function()
                        local safeHeight = math.max(currentPosition.Y + 10, 50)
                        local teleportPosition = Vector3.new(currentPosition.X, safeHeight, currentPosition.Z)
                        if Module.isValidPosition(teleportPosition) then
                            humanoidRootPart.CFrame = CFrame.new(teleportPosition)
                            task.wait(0.05)
                            local finalPosition = Vector3.new(currentPosition.X, currentPosition.Y + 5, currentPosition.Z)
                            if Module.isValidPosition(finalPosition) then
                                humanoidRootPart.CFrame = CFrame.new(finalPosition)
                                task.wait(0.15)
                            end
                        end
                    end)
                else
                    warn("Item too far away, skipping: " .. itemData.name)
                end
            end
        end
    end
    
    pcall(function()
        local currentPos = humanoidRootPart.Position
        if not Module.isValidPosition(currentPos) or currentPos.Y < -500 then
            humanoidRootPart.CFrame = originalPosition
            warn("Teleported back to original position (failsafe)")
        end
    end)
    
    Module.Variables.isTeleporting = false
    return true
end

function Module.pauseAllAutomation()
    if Module.Variables.TeleportActive then
        Module.Variables.TeleportActive = false
        if Module.Variables.teleportConnection then
            Module.Variables.teleportConnection:Disconnect()
            Module.Variables.teleportConnection = nil
        end
    end
    Module.Variables.teleportToItemsEnabled = false
    if Module.Variables.doorActivatorEnabled then
        Module.Variables.doorActivatorEnabled = false
        Module.disableAutoActivation()
    end
    if Module.Variables.teleportToDoorEnabled then
        Module.Variables.teleportToDoorEnabled = false
        Module.disableV2DoorNoclip()
    end
end

function Module.resumeAllAutomation(Toggles)
    if Toggles.AutoTeleport and Toggles.AutoTeleport.Value then
        Module.Variables.TeleportActive = true
        Module.Variables.teleportConnection = Module.Services.RunService.Heartbeat:Connect(function()
            if Module.Variables.teleportToDoorEnabled then
                local doorsToOpen = Module.getUnopenedDoorsNearby()
                if #doorsToOpen > 0 then return end
            end
            if Module.Variables.isTeleporting then return end
            Module.TeleportToMob()
        end)
    end
    
    if Toggles.TeleportToItems and Toggles.TeleportToItems.Value then
        Module.Variables.teleportToItemsEnabled = true
    end
    
    if Toggles.DoorActivator and Toggles.DoorActivator.Value then
        Module.Variables.doorActivatorEnabled = true
        Module.setupAutoActivation()
    end
    
    if Toggles.TeleportToDoors and Toggles.TeleportToDoors.Value then
        Module.Variables.teleportToDoorEnabled = true
        spawn(function()
            Module.enableV2DoorNoclip()
            while Module.Variables.teleportToDoorEnabled do
                local doorsToOpen = Module.getUnopenedDoorsNearby()
                if #doorsToOpen > 0 then
                    Module.teleportAndActivateDoors()
                else
                    task.wait(1.5)
                end
            end
            Module.disableV2DoorNoclip()
        end)
    end
end

function Module.findHeliPrompt()
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj.Name == "HeliObjective" then
            local prompt = obj:FindFirstChild("ProximityPrompt")
            if prompt then return obj, prompt end
        end
    end
    return nil, nil
end

function Module.completeHeliObjective()
    wait(5.5)
    Module.updateCharacterReferences()
    local character = Module.Instances.Player.Character
    if not character then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local heliObj, prompt = Module.findHeliPrompt()
    if heliObj and prompt then
        humanoidRootPart.CFrame = heliObj.CFrame + Vector3.new(0, 5, 0)
        wait(1)
        prompt.Enabled = true
        prompt.HoldDuration = 0
        prompt.RequiresLineOfSight = false
        prompt.MaxActivationDistance = 1000
        
        for i = 1, 15 do
            pcall(function()
                prompt:InputHoldBegin()
                task.wait(0.05)
                prompt:InputHoldEnd()
            end)
            pcall(function() fireproximityprompt(prompt) end)
            pcall(function()
                for _, triggerConnection in pairs(getconnections(prompt.Triggered)) do
                    triggerConnection:Fire()
                end
            end)
            wait(0.2)
        end
    end
end

function Module.completeRadioObjective(radio, Toggles)
    if Module.Variables.radioCompleted then return end
    Module.Variables.radioCompleted = true
    Module.pauseAllAutomation()
    wait(5)
    Module.updateCharacterReferences()
    local character = Module.Instances.Player.Character
    if not character then
        Module.Variables.radioCompleted = false
        Module.resumeAllAutomation(Toggles)
        return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        Module.Variables.radioCompleted = false
        Module.resumeAllAutomation(Toggles)
        return
    end
    Module.enableV2Noclip()
    humanoidRootPart.CFrame = radio.CFrame + Vector3.new(0, 3, 0)
    wait(1)
    
    local proximityPrompt = radio:FindFirstChild("ProximityPrompt")
    if not proximityPrompt then
        for _, child in pairs(radio:GetDescendants()) do
            if child:IsA("ProximityPrompt") then
                proximityPrompt = child
                break
            end
        end
    end
    
    if proximityPrompt then
        proximityPrompt.Enabled = true
        proximityPrompt.HoldDuration = 0
        proximityPrompt.RequiresLineOfSight = false
        proximityPrompt.MaxActivationDistance = 1000
        
        for i = 1, 15 do
            humanoidRootPart.CFrame = radio.CFrame + Vector3.new(0, 3, 0)
            wait(0.1)
            pcall(function()
                proximityPrompt:InputHoldBegin()
                task.wait(0.05)
                proximityPrompt:InputHoldEnd()
            end)
            pcall(function() fireproximityprompt(proximityPrompt) end)
            pcall(function()
                for _, triggerConnection in pairs(getconnections(proximityPrompt.Triggered)) do
                    triggerConnection:Fire()
                end
            end)
            wait(0.3)
        end
        wait(2)
        local currentPosition = humanoidRootPart.CFrame
        humanoidRootPart.CFrame = currentPosition + Vector3.new(0, 8, 0)
        wait(3)
        wait(3)

        if Module.Variables.v2ObjectiveMode == "Radio + Helicopter" then
            task.spawn(function()
                for i = 1, 8 do
                    Module.Variables.heliCompleted = false
                    Module.completeHeliObjective()
                    wait(i % 2 == 0 and 3 or 1)
                end
                Module.disableV2Noclip()
                wait(2)
                Module.resumeAllAutomation(Toggles)
            end)
        else
            wait(2)
            Module.disableV2Noclip()
            Module.resumeAllAutomation(Toggles)
        end
    end
end

function Module.onDescendantAdded(descendant, Toggles)
    if not Module.Variables.v2Enabled then return end
    if descendant.Name == "RadioObjective" and not Module.Variables.radioCompleted then
        task.spawn(Module.completeRadioObjective, descendant, Toggles)
    end
end

function Module.checkExistingRadio(Toggles)
    if not Module.Variables.v2Enabled then return end
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj.Name == "RadioObjective" and not Module.Variables.radioCompleted then
            task.spawn(Module.completeRadioObjective, obj, Toggles)
            break
        end
    end
end

function Module.waitForCharacter()
    local character = Module.Instances.Player.Character or Module.Instances.Player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 10)
    return character, humanoidRootPart
end

function Module.teleportToObjective(target)
    if not target then return end
    local targetPosition
    if target:IsA("BasePart") then
        targetPosition = target.CFrame
    elseif target:IsA("Model") then
        local primaryPart = target.PrimaryPart
        if not primaryPart then
            for _, child in pairs(target:GetChildren()) do
                if child:IsA("BasePart") then
                    primaryPart = child
                    break
                end
            end
        end
        if primaryPart then targetPosition = primaryPart.CFrame end
    end
    if targetPosition then
        local Character = Module.Instances.Player.Character
        if Character and Character:FindFirstChild("HumanoidRootPart") then
            Character.HumanoidRootPart.CFrame = targetPosition
        end
    end
end

function Module.getNearestPrompt()
    local Character = Module.Instances.Player.Character
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then return nil end
    local HumanoidRootPart = Character.HumanoidRootPart
    local nearestPrompt = nil
    local shortestDistance = math.huge
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("ProximityPrompt") and descendant.Enabled then
            local promptPart = descendant.Parent:IsA("BasePart") and descendant.Parent
            if promptPart then
                local distance = (HumanoidRootPart.Position - promptPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestPrompt = descendant
                end
            end
        end
    end
    return nearestPrompt
end

function Module.activatePrompt(prompt, targetObject, maxRetries)
    if not prompt or not prompt:IsA("ProximityPrompt") then return end
    maxRetries = maxRetries or 10
    local attempts = 0
    local wasTriggered = false
    local connection
    connection = prompt.Triggered:Connect(function()
        wasTriggered = true
        if connection then connection:Disconnect() end
    end)
    
    local function attemptActivation()
        attempts = attempts + 1
        Module.teleportToObjective(targetObject)
        task.wait(0.3)
        prompt.HoldDuration = 0
        prompt.Enabled = true
        prompt.RequiresLineOfSight = false
        prompt.MaxActivationDistance = 1000
        
        pcall(function()
            prompt:InputHoldBegin()
            task.wait(0.1)
            prompt:InputHoldEnd()
        end)
        task.wait(0.2)
        pcall(function() fireproximityprompt(prompt) end)
        task.wait(0.2)
        pcall(function()
            for _, triggerConnection in pairs(getconnections(prompt.Triggered)) do
                triggerConnection:Fire()
            end
        end)
        task.wait(0.2)
        pcall(function() prompt.TriggerEnded:Fire() end)
        task.wait(0.5)
        
        if not wasTriggered and (targetObject.Name == "jarst_radio" or targetObject.Name == "RadioObjective") then
            local autoFireAttempts = 0
            local maxAutoFireAttempts = 20
            while not wasTriggered and autoFireAttempts < maxAutoFireAttempts do
                autoFireAttempts = autoFireAttempts + 1
                if not Module.Variables.firing then
                    Module.Variables.firing = true
                    local nearestPrompt = Module.getNearestPrompt()
                    if nearestPrompt and nearestPrompt == prompt then
                        pcall(function() fireproximityprompt(nearestPrompt) end)
                        task.wait(0.3)
                        pcall(function()
                            nearestPrompt:InputHoldBegin()
                            task.wait(0.1)
                            nearestPrompt:InputHoldEnd()
                        end)
                        task.wait(0.2)
                        for i = 1, 3 do
                            pcall(function() fireproximityprompt(nearestPrompt) end)
                            task.wait(0.1)
                        end
                    end
                    Module.Variables.firing = false
                    task.wait(0.2)
                end
                if wasTriggered then break end
            end
        end
        task.wait(0.5)
        if not wasTriggered and attempts < maxRetries then
            task.wait(1)
            attemptActivation()
        elseif not wasTriggered then
            if connection then connection:Disconnect() end
        end
    end
    attemptActivation()
end

function Module.setupGlobalListener(parent, Toggles)
    parent.DescendantAdded:Connect(function(descendant)
        if not Module.Variables.ObjectiveAutomationActive then return end
        task.wait(0.1)
        if descendant.Name == "generator" then
            Module.pauseAllAutomation()
            Module.enableNoclip()
            task.wait(5)
            Module.updateCharacterReferences()
            Module.teleportToObjective(descendant)
            task.wait(0.5)
            local prompt = descendant:FindFirstChildOfClass("ProximityPrompt")
            if not prompt then
                for _, child in pairs(descendant:GetDescendants()) do
                    if child:IsA("ProximityPrompt") then
                        prompt = child
                        break
                    end
                end
            end
            if prompt then Module.activatePrompt(prompt, descendant) end
            wait(2)
            Module.disableNoclip()
            Module.resumeAllAutomation(Toggles)
        end
    end)
end

function Module.checkExistingV1(Toggles)
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant.Name == "generator" then
            Module.pauseAllAutomation()
            Module.enableNoclip()
            task.wait(5)
            Module.updateCharacterReferences()
            Module.teleportToObjective(descendant)
            task.wait(0.5)
            local prompt = descendant:FindFirstChildOfClass("ProximityPrompt")
            if not prompt then
                for _, child in pairs(descendant:GetDescendants()) do
                    if child:IsA("ProximityPrompt") then
                        prompt = child
                        break
                    end
                end
            end
            if prompt then Module.activatePrompt(prompt, descendant) end
            wait(2)
            Module.disableNoclip()
            Module.resumeAllAutomation(Toggles)
        end
    end
end

function Module.RestoreJoint(joint)
    if not joint or not joint.Parent then return end
    local jointName = joint.Name
    local jointData = Module.Variables.DefaultJoints[jointName]
    if jointData and joint:IsA("Motor6D") then
        joint.C0 = jointData[1]
        joint.C1 = jointData[2]
        joint.Enabled = true
        if joint.Part0 and joint.Part1 then
            joint.Part0.Anchored = false
            joint.Part1.Anchored = false
            joint.Part0.CanCollide = false
            joint.Part1.CanCollide = false
        end
    end
end

function Module.RestoreCharacter(character)
    if not character then return end
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
        humanoid.Sit = false
        humanoid:ChangeState(Enum.HumanoidStateType.Running)
        if humanoid.Health <= 0 then humanoid.Health = humanoid.MaxHealth end
    end
    for _, joint in pairs(character:GetDescendants()) do
        if joint:IsA("Motor6D") then Module.RestoreJoint(joint) end
    end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.Anchored = false
            part.CanCollide = false
            for _, constraint in pairs(part:GetChildren()) do
                if constraint:IsA("BallSocketConstraint") or constraint:IsA("HingeConstraint") or constraint:IsA("RodConstraint") or constraint:IsA("UniversalConstraint") then
                    constraint:Destroy()
                end
            end
        end
    end
end

function Module.MonitorCharacter(character)
    if not character then return end
    for _, joint in pairs(character:GetDescendants()) do
        if joint:IsA("Motor6D") then
            Module.Variables.originalJoints[joint] = {C0 = joint.C0, C1 = joint.C1, Enabled = joint.Enabled}
        end
    end
    local function checkRagdoll()
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid and (humanoid.PlatformStand or humanoid:GetState() == Enum.HumanoidStateType.Physics) then
            Module.RestoreCharacter(character)
        end
        for _, joint in pairs(character:GetDescendants()) do
            if joint:IsA("Motor6D") and Module.Variables.originalJoints[joint] then
                if not joint.Enabled or joint.Parent == nil then
                    Module.RestoreJoint(joint)
                end
            end
        end
    end
    Module.Variables.ragdollConnections[#Module.Variables.ragdollConnections + 1] = Module.Services.RunService.Heartbeat:Connect(checkRagdoll)
    Module.Variables.ragdollConnections[#Module.Variables.ragdollConnections + 1] = character.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Motor6D") then
            Module.Variables.originalJoints[descendant] = {C0 = descendant.C0, C1 = descendant.C1, Enabled = descendant.Enabled}
        end
    end)
    Module.Variables.ragdollConnections[#Module.Variables.ragdollConnections + 1] = character.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Motor6D") then
            task.wait()
            Module.RestoreCharacter(character)
        end
    end)
end

function Module.StartAntiRagdoll()
    local function onCharacterAdded(character)
        character:WaitForChild("Humanoid")
        character:WaitForChild("HumanoidRootPart")
        task.wait(1)
        Module.MonitorCharacter(character)
    end
    if Module.Instances.Player.Character then onCharacterAdded(Module.Instances.Player.Character) end
    Module.Instances.Player.CharacterAdded:Connect(onCharacterAdded)
end

function Module.setupInfiniteJump()
    local function enableInfiniteJump()
        local character = Module.Instances.Player.Character
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        local connection
        connection = Module.Services.UserInputService.JumpRequest:Connect(function()
            if humanoid then humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end
        end)
        character.AncestryChanged:Connect(function()
            if not character.Parent then connection:Disconnect() end
        end)
    end
    if Module.Instances.Player.Character then enableInfiniteJump() end
    Module.Instances.Player.CharacterAdded:Connect(enableInfiniteJump)
end

function Module.redeemCodes()
    local codes = {"200KLIKES", "Hugecode", "WDEV1", "WDEV2", "ALMOSTCHRISTMASEVE", "ALMOSTCHRISTMASEVE2", "ALMOSTCHRISTMASEVE3", "ALMOSTCHRISTMASEVE4", "WEAREBACK", "WEAREBACK2", "WEAREBACK3", "WEAREBACK4", "KRAMPUS", "JINGLEBELLS"}
    task.spawn(function()
        task.wait(2)
        local success, packetsFolder = pcall(function()
            return game:GetService("ReplicatedStorage"):WaitForChild("Packets", 5)
        end)
        if success and packetsFolder then
            local redeemCode = packetsFolder:FindFirstChild("RedeemCode")
            if redeemCode then
                for _, code in ipairs(codes) do
                    task.spawn(function()
                        pcall(function()
                            local args = {code}
                            redeemCode:InvokeServer(unpack(args))
                        end)
                    end)
                    task.wait(0.5)
                end
            end
        end
    end)
end

function Module.teleportToLobby()
    pcall(function()
        local TeleportService = game:GetService("TeleportService")
        local lobbyPlaceId = 103754275310547
        TeleportService:Teleport(lobbyPlaceId, Module.Instances.Player)
    end)
end

function Module.teleportToMap2SafeSpot()
    pcall(function()
        local Character = Module.Instances.Player.Character
        if Character and Character:FindFirstChild("HumanoidRootPart") then
            Character.HumanoidRootPart.CFrame = CFrame.new(-98.7486877, 32.2496185, 0.000988006592, -1.1920929e-07, 0, -1.00000012, 0, -1.00000024, -0, -1.00000012, 0, -1.1920929e-07)
        end
    end)
end

function Module.startAutoReplay()
    task.spawn(function()
        while Module.Variables.autoReplayEnabled do
            pcall(function()
                local args = {"Test-Data"}
                game:GetService("ReplicatedStorage"):WaitForChild("external", 9e9):WaitForChild("Packets", 9e9):WaitForChild("voteReplay", 9e9):FireServer(unpack(args))
            end)
            task.wait(1)
        end
    end)
end

function Module.startSkillSpamLoop()
    task.spawn(function()
        while true do
            pcall(function()
                if Module.Variables.SkillSpamActive then
                    if Module.Variables.SkillToggles.ZSkill then
                        pcall(function()
                            Module.Instances.ByteNetReliable:FireServer(Module.Variables.SkillBuffers.ZSkill, {workspace:GetServerTimeNow()})
                        end)
                    end
                    if Module.Variables.SkillToggles.XSkill then
                        pcall(function()
                            Module.Instances.ByteNetReliable:FireServer(Module.Variables.SkillBuffers.XSkill, {workspace:GetServerTimeNow()})
                        end)
                    end
                    if Module.Variables.SkillToggles.CSkill then
                        pcall(function()
                            Module.Instances.ByteNetReliable:FireServer(Module.Variables.SkillBuffers.CSkill, {workspace:GetServerTimeNow()})
                        end)
                    end
                    if Module.Variables.SkillToggles.VSkill then
                        pcall(function()
                            Module.Instances.ByteNetReliable:FireServer(Module.Variables.SkillBuffers.VSkill, {workspace:GetServerTimeNow()})
                        end)
                    end
                    if Module.Variables.SkillToggles.Perk then
                        pcall(function()
                            Module.Instances.ByteNetReliable:FireServer(Module.Variables.SkillBuffers.Perk, {workspace:GetServerTimeNow()})
                        end)
                    end
                end
            end)
            task.wait(Module.Variables.SkillSpamRate)
        end
    end)
end

function Module.startMainAttackLoop()
    task.spawn(function()
        while true do
            pcall(function()
                if Module.Variables.BufferSpamActive then
                    pcall(function()
                        Module.Instances.ByteNetReliable:FireServer(Module.Variables.mainAttackBuffer, {workspace:GetServerTimeNow()})
                    end)
                    task.wait(Module.Variables.SpamRate)
                else
                    task.wait(0.1)
                end
            end)
        end
    end)
end

function Module.startMemoryCleanupLoop()
    task.spawn(function()
        while true do
            pcall(function() Module.CleanupMemory() end)
            task.wait(5)
        end
    end)
end

function Module.startDoorCleanupLoop()
    task.spawn(function()
        while true do
            task.wait(30)
            pcall(function()
                local taggedDoors = Module.Services.CollectionService:GetTagged("LEVELDOOR")
                for _, door in ipairs(taggedDoors) do
                    if not door.Parent then
                        Module.Services.CollectionService:RemoveTag(door, "LEVELDOOR")
                    end
                end
            end)
        end
    end)
end

function Module.setupCharacterResetHandler(Toggles)
    Module.Instances.Player.CharacterAdded:Connect(function(newCharacter)
        pcall(function()
            Module.Instances.Character = newCharacter
            Module.Instances.HumanoidRootPart = Module.Instances.Character:WaitForChild("HumanoidRootPart")
            Module.updateCharacterReferences()
            Module.Variables.currentTarget = nil
            Module.Variables.targetHealthHistory = {}
            Module.Variables.radioCompleted = false
            Module.Variables.heliCompleted = false
            if Module.Variables.v2Enabled then
                wait(1)
                Module.enableV2Noclip()
            end
            wait(1)
            Module.GetBestMobTarget()
        end)
    end)
end

function Module.setupManualTeleportHotkey()
    Module.Services.UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        pcall(function()
            if input.KeyCode == Enum.KeyCode.T then Module.TeleportToMob() end
        end)
    end)
end

return Module
