-- Load Fluent Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

getgenv().VaultReady = false

local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService('HttpService')

local function constructUrl(parts)
    return table.concat(parts, '')
end

local function getSecureEndpoint()
    local protocol = string.char(
        104,
        116,
        116,
        112,
        115,
        58,
        47,
        47
    )

    local webhookParts = {}

    webhookParts[1] = protocol

    local trash1 = 5 * math.random(1, 9)
    local dummy1 = tostring(trash1) .. '_lol'

    webhookParts[2] = 'v0-secure-'

    for i = 1, 3 do
        local temp = i * 3
    end
    local extra = 'ignore_me'

    webhookParts[3] = 'discord'

    local shadow = 'who_dis' .. tostring(math.random(100, 999))
    local bogus = math.pi * 2.718

    webhookParts[4] = '-proxy'

    local void = {}
    for i = 1, 2 do
        table.insert(void, i * 9)
    end
    local skipThis = table.concat(void, '-')

    webhookParts[5] = '.vercel'

    local notUsed = math.cos(os.clock()) * 99
    local filler = 'not_shown_' .. tostring(notUsed)

    webhookParts[6] = '.app'

    local joke = (1234 % 100) + 33
    local decoy = tostring(joke)

    webhookParts[7] = '/api/'

    local rando = tostring(math.random(1, 99999))
    local deepfake = 'key_' .. rando

    webhookParts[8] = 'webhook'

    return table.concat(webhookParts)
end

local function getVersionUrl()
    local urlParts = {}
    urlParts[1] = string.char(
        104,
        116,
        116,
        112,
        115,
        58,
        47,
        47
    )
    local noise = math.random(10, 99) * 3.14
    local dummy = 'ignore_' .. tostring(noise)
    urlParts[2] = 'pastebin'
    for i = 1, 4 do
        local temp = i * i * 2
    end
    local garbage = 'skip_this'
    urlParts[3] = '.com/raw/'
    local decoy = {}
    for i = 1, 3 do
        table.insert(decoy, i * 7)
    end
    local unused = table.concat(decoy, '+')
    urlParts[4] = 'ptHNczy5'
    local junkMath = math.sin(os.time() % 10) * 55
    local extra = 'not_important_' .. tostring(junkMath)

    return table.concat(urlParts)
end

local function getBlacklistUrl()
    local segments = {}
    segments[1] = string.char(
        104,
        116,
        116,
        112,
        115,
        58,
        47,
        47
    )
    local mockData = tostring(math.random(1000, 9999))
    local fakeRef = 'ref_' .. mockData
    segments[2] = 'pastebin'
    for m = 1, 5 do
        local throwaway = m * m + 7
    end
    local dummyToken = 'token_' .. tostring(os.time() % 100)
    segments[3] = '.com/raw/'
    local noise = {}
    for i = 1, 4 do
        table.insert(noise, i * 11)
    end
    local jumble = table.concat(noise, '-')
    segments[4] = '3h23tX2Y'
    local lastCalc = math.abs(math.sin(os.clock())) * 200
    local dummyEnd = 'verify_' .. tostring(lastCalc)

    return table.concat(segments)
end

local function getWhitelistUrl()
    local fragments = {}
    fragments[1] = string.char(
        104,
        116,
        116,
        112,
        115,
        58,
        47,
        47
    )
    local randomBits = math.random(1, 64) * 4
    local skipMe = 'skip_' .. tostring(randomBits)
    fragments[2] = 'pastebin'
    for n = 3, 6 do
        local useless = n * 3.33
    end
    local dummyVar = 'debug_' .. tostring(math.floor(math.random() * 1000))
    fragments[3] = '.com/raw/'
    local fakeData = {}
    for i = 1, 3 do
        table.insert(fakeData, i * 33)
    end
    local junkStr = table.concat(fakeData, '_')
    fragments[4] = 'Qmp4r6es'
    local endJunk = math.ceil(os.clock() * 50)
    local dummyEnd = 'end_' .. tostring(endJunk)

    return table.concat(fragments)
end

local function getScriptApiUrl()
    local scriptParts = {}
    scriptParts[1] = string.char(104, 116, 116, 112, 115, 58, 47, 47)
    local randJunk = math.random(100, 777) * 1.618
    local dummyScript = 'script_' .. tostring(randJunk)
    scriptParts[2] = 'combo0-chroncile'
    for j = 1, 4 do
        local throwaway = j * 19 + 3
    end
    local extraData = 'combo_' .. tostring(os.time() % 888)
    scriptParts[3] = '.vercel'
    local mockCalc = math.cos(os.clock()) * 150
    local dummyVercel = 'vercel_' .. tostring(mockCalc)
    scriptParts[4] = '.app/api/roblox'
    local finalNoise = math.floor(math.random() * 999)
    local lastDummy = 'api_' .. tostring(finalNoise)

    return table.concat(scriptParts)
end

local function getDefaultScriptUrl()
    local defaultParts = {}
    defaultParts[1] = string.char(104, 116, 116, 112, 115, 58, 47, 47)
    local noiseVar = math.random(50, 555) * 2.718
    local dummyDefault = 'default_' .. tostring(noiseVar)
    defaultParts[2] = 'raw.githubusercontent'
    for p = 1, 3 do
        local throwaway = p * p * 5
    end
    local extraJunk = 'github_' .. tostring(os.time() % 444)
    defaultParts[3] = '.com/checkurasshole/'
    local mockData = {}
    for i = 1, 4 do
        table.insert(mockData, i * 7)
    end
    local junkArray = table.concat(mockData, '-')
    defaultParts[4] = 'Script/refs/heads/main/'
    local calcJunk = math.abs(math.sin(os.clock())) * 300
    local dummyScript = 'main_' .. tostring(calcJunk)
    defaultParts[5] = 'Default'
    local endJunk = math.ceil(os.clock() * 123)
    local finalDummy = 'default_' .. tostring(endJunk)

    return table.concat(defaultParts)
end

local CONFIG = {
    VERSION_URL = getVersionUrl(),
    SECURE_ENDPOINT = getSecureEndpoint(),
    BLACKLIST_URLS = {
        getBlacklistUrl(),
    },
    WHITELIST_URL = getWhitelistUrl(),
    HTTP_TIMEOUT = 15,
    FEEDBACK_COOLDOWN = 4500,
    VERSION = '1.3.3',
    MIN_VERSION = '1.3.3',
    VERSION_TOKEN_FALLBACK = 'VAULT_1_3_3_AUTH',
}

local startTime = tick()

local function getPlayerInfo()
    local info = {}
    info.UserId = LocalPlayer.UserId
    info.Username = LocalPlayer.Name
    info.DisplayName = LocalPlayer.DisplayName
    info.HWID = game:GetService('RbxAnalyticsService'):GetClientId()
    info.GameId = game.PlaceId
    info.JobId = game.JobId
    info.AccountAge = LocalPlayer.AccountAge
    info.Executor = identifyexecutor and identifyexecutor() or 'Unknown'
    info.Locale = LocalPlayer.LocaleId
    info.Platform = game:GetService('UserInputService'):GetPlatform().Name
    info.PlaceName = game:GetService('MarketplaceService'):GetProductInfo(
        game.PlaceId
    ).Name
    return info
end

local function getDebugInfo()
    local debug = {}
    debug.ScriptVersion = CONFIG.VERSION
    debug.ExecutorType = identifyexecutor and identifyexecutor() or 'Unknown'
    debug.RobloxVersion = version()
    debug.LoadTime = tick() - startTime
    debug.HttpSupport = {
        game_HttpGet = game.HttpGet ~= nil,
        syn_request = syn and syn.request ~= nil,
        http_request = http_request ~= nil,
        request = request ~= nil,
        httprequest = httprequest ~= nil
    }
    debug.ServiceAccess = {
        Players = pcall(function() return game:GetService('Players') end),
        HttpService = pcall(function() return game:GetService('HttpService') end),
        DataStoreService = pcall(function() return game:GetService('DataStoreService') end),
        MarketplaceService = pcall(function() return game:GetService('MarketplaceService') end)
    }
    debug.ErrorLog = {}
    return debug
end

local HTTP_RATE_LIMIT = 0.5
local lastHttpRequest = 0
local function safeHttpGet(url, retries)
    retries = retries or 3
    local data, success, errorMsg

    for i = 1, retries do
        while (tick() - lastHttpRequest) < HTTP_RATE_LIMIT do
            task.wait(0.1)
        end
        lastHttpRequest = tick()

        local requestComplete = false
        local requestThread = coroutine.create(function()
            success, data = pcall(function()
                return game:HttpGet(url)
            end)
            if not success then
                errorMsg = data
                data = nil
            end
            requestComplete = true
        end)

        coroutine.resume(requestThread)

        local startTime = tick()
        while
            not requestComplete
            and (tick() - startTime) < CONFIG.HTTP_TIMEOUT
        do
            task.wait(0.1)
        end

        if requestComplete and success then
            return true, data
        end

        if i < retries then
            task.wait(2)
        end
    end

    return false, errorMsg or 'Request timed out or blocked'
end

local function compareVersions(v1, v2)
    local v1Parts = { v1:match('(%d+)%.(%d+)%.(%d+)') }
    local v2Parts = { v2:match('(%d+)%.(%d+)%.(%d+)') }
    for i = 1, 3 do
        local n1, n2 = tonumber(v1Parts[i]) or 0, tonumber(v2Parts[i]) or 0
        if n1 < n2 then
            return -1
        end
        if n1 > n2 then
            return 1
        end
    end
    return 0
end

local function checkVersionAndToken()
    local success, response = safeHttpGet(CONFIG.VERSION_URL)
    if success then
        local version, token = response:match('([^|]+)|(.+)')
        if not version or not token then
            return false,
                'Invalid version format in Pastebin',
                CONFIG.VERSION_TOKEN_FALLBACK
        end
        if compareVersions(CONFIG.VERSION, version) < 0 then
            return false,
                'Script outdated. Please update to v' .. version,
                token
        elseif compareVersions(CONFIG.VERSION, CONFIG.MIN_VERSION) < 0 then
            return false,
                'Version below minimum required (' .. CONFIG.MIN_VERSION .. ')',
                token
        end
        return true, version, token
    end
    return true, CONFIG.VERSION, CONFIG.VERSION_TOKEN_FALLBACK
end

local collectedData = {
    users = {},
    addUser = function(self, username, hwid, version)
        if not self.users[username] then
            self.users[username] = { hwids = {}, versions = {} }
        end
        self.users[username].hwids[hwid] = true
        self.users[username].versions[version] = true
    end,
    format = function(self)
        local formatted = 'Outdated Version Detection (v'
            .. CONFIG.VERSION
            .. ')\n'
        formatted = formatted .. '================================\n'
        for username, data in pairs(self.users) do
            formatted = formatted .. 'Username: ' .. username .. '\n'
            formatted = formatted .. 'Hardware IDs:\n'
            for hwid, _ in pairs(data.hwids) do
                formatted = formatted .. '  - ' .. hwid .. '\n'
            end
            formatted = formatted .. 'Detected Versions:\n'
            for version, _ in pairs(data.versions) do
                formatted = formatted .. '  - ' .. version .. '\n'
            end
            formatted = formatted .. '----------------\n'
        end
        return formatted
    end,
}

local accessControl = {
    blacklistUsers = {},
    blacklistHWIDs = {},
    whitelist = {},
    lastFetch = 0,
    isFetching = false,

    fetchLists = function(self)
        if self.isFetching or (tick() - self.lastFetch < 300) then
            return
        end
        self.isFetching = true

        self.blacklistUsers = {}
        self.blacklistHWIDs = {}
        for _, url in ipairs(CONFIG.BLACKLIST_URLS) do
            local success, data = safeHttpGet(url)
            if success then
                for line in data:gmatch('[^\n]+') do
                    local trimmed = line:match('^%s*(.-)%s*$')
                    if trimmed and trimmed ~= '' then
                        if trimmed:match('^%d+$') then
                            self.blacklistUsers[tonumber(trimmed)] = true
                        else
                            self.blacklistHWIDs[trimmed] = true
                        end
                    end
                end
            end
        end

        local wlSuccess, wlData = safeHttpGet(CONFIG.WHITELIST_URL)
        if wlSuccess then
            self.whitelist = {}
            for line in wlData:gmatch('[^\n]+') do
                local userId = tonumber(line)
                if userId then
                    self.whitelist[userId] = true
                end
            end
        end

        self.lastFetch = tick()
        self.isFetching = false
    end,

    isBlacklisted = function(self, userId, hwid)
        self:fetchLists()
        return self.blacklistUsers[userId] == true
            or self.blacklistHWIDs[hwid] == true
    end,

    isWhitelisted = function(self, userId)
        self:fetchLists()
        return self.whitelist[userId] == true
    end,

    getStatus = function(self, userId, hwid)
        self:fetchLists()
        if self.blacklistUsers[userId] then
            return 'Blacklisted (User)'
        elseif self.blacklistHWIDs[hwid] then
            return 'Blacklisted (HWID)'
        elseif self.whitelist[userId] then
            return 'Whitelisted'
        else
            return 'Neutral'
        end
    end,
}

local webhookSystem = {
    queue = {},
    processing = false,
    batchSize = 5,
    secureEndpoint = CONFIG.SECURE_ENDPOINT,

    formatTime = function(self, seconds)
        local hours = math.floor(seconds / 3600)
        local minutes = math.floor((seconds % 3600) / 60)
        local secs = math.floor(seconds % 60)
        if hours > 0 then
            return string.format('%d hrs, %d min', hours, minutes)
        elseif minutes > 0 then
            return string.format('%d min, %d sec', minutes, secs)
        else
            return string.format('%d sec', secs)
        end
    end,

    send = function(self, embedData)
        table.insert(self.queue, { data = embedData, secure = true })
        if not self.processing then
            self:processQueue()
        end
    end,

    processQueue = function(self)
        if #self.queue == 0 then
            self.processing = false
            return
        end
        self.processing = true
        local batch = {}
        for i = 1, math.min(self.batchSize, #self.queue) do
            local item = table.remove(self.queue, 1)
            local embed = item.data
            embed.footer = embed.footer
                or { text = 'Vault v' .. CONFIG.VERSION }
            embed.timestamp = embed.timestamp or os.date('!%Y-%m-%dT%H:%M:%SZ')
            if embed.title == 'Debug Report' then
                embed.components = {
                    {
                        type = 1,
                        components = {
                            {
                                type = 2,
                                style = 1,
                                label = 'Debug Info',
                                custom_id = 'debug_' .. LocalPlayer.UserId,
                            },
                        },
                    },
                }
            end
            table.insert(batch, { embed = embed, secure = item.secure })
        end

        local http_request = (syn and syn.request)
            or (http and http.request)
            or request
            or httprequest
        if not http_request then
            return
        end

        for _, item in ipairs(batch) do
            local success = false
            if item.secure then
                success = pcall(function()
                    local result = http_request({
                        Url = self.secureEndpoint,
                        Method = 'POST',
                        Headers = { ['Content-Type'] = 'application/json' },
                        Body = HttpService:JSONEncode({
                            embeds = { item.embed },
                        }),
                    })
                    return result
                        and (
                            result.StatusCode == 204
                            or result.StatusCode == 200
                        )
                end)
            end

            if not success and item.secure then
                if item.embed.retryCount < 3 then
                    table.insert(self.queue, item)
                end
            end
        end
        task.wait(1)
        self:processQueue()
    end,
}

local scriptSystem = {
    scripts = {
        api = getScriptApiUrl(),
    },
    defaultScript = getDefaultScriptUrl()
        .. '\n'
        .. [[ ]],

    getScriptForGame = function(self)
        local apiUrl = self.scripts.api
        local success, result = pcall(function()
            local response = syn and syn.request
                or http and http.request
                or http_request
                or request
            if not response then
                error("Your executor doesn't support HTTP requests.")
            end

            local res = response({
                Url = apiUrl,
                Method = 'GET',
            })

            if not res or not res.Body then
                error('Invalid response from API.')
            end

            local data = HttpService:JSONDecode(res.Body)
            local gameIdStr = tostring(game.PlaceId)

            if data[gameIdStr] then
                return data[gameIdStr]
            elseif data['default'] then
                return data['default']
            end
        end)

        if success and result then
            return result
        else
            Fluent:Notify({
                Title = 'Warning',
                Content = 'No script found for this game. Loading default.',
                Duration = 5,
            })
            return self.defaultScript
        end
    end,

    loadScript = function(self, scriptUrl, notifyOnLoad)
        spawn(function()
            if notifyOnLoad then
                Fluent:Notify({
                    Title = 'Loading',
                    Content = 'Loading script...',
                    Duration = 2,
                })
            end
            local success, errorMsg = pcall(function()
                loadstring(game:HttpGet(scriptUrl:match('^[^%s]+')))()
            end)
            if success and notifyOnLoad then
                Fluent:Notify({
                    Title = 'Success',
                    Content = 'Script loaded!',
                    Duration = 3,
                })
            elseif not success then
                Fluent:Notify({
                    Title = 'Error',
                    Content = 'Failed: ' .. (errorMsg or 'Unknown'),
                    Duration = 5,
                })
            end
        end)
    end,

    loadScriptSet = function(self, scriptSet, notifyOnLoad)
        if type(scriptSet) == 'table' then
            for i, url in ipairs(scriptSet) do
                self:loadScript(url, notifyOnLoad and i == 1)
            end
        else
            self:loadScript(scriptSet, notifyOnLoad)
        end
    end,
}

local memoryCleanup = {
    connections = {},
    cleanup_interval = 30,
    last_cleanup = tick(),
    
    addConnection = function(self, connection)
        table.insert(self.connections, connection)
    end,
    
    cleanupMemory = function(self)
        if tick() - self.last_cleanup < self.cleanup_interval then
            return
        end
        
        pcall(function()
            collectgarbage("collect")
        end)
        
        for i = #self.connections, 1, -1 do
            local connection = self.connections[i]
            if connection and connection.Connected == false then
                table.remove(self.connections, i)
            end
        end
        
        self.last_cleanup = tick()
    end,
    
    disconnectAll = function(self)
        for _, connection in ipairs(self.connections) do
            if connection and connection.Connected then
                connection:Disconnect()
            end
        end
        self.connections = {}
        pcall(function()
            collectgarbage("collect")
        end)
    end
}

local cleanupConnection = RunService.Heartbeat:Connect(function()
    memoryCleanup:cleanupMemory()
end)
memoryCleanup:addConnection(cleanupConnection)

local function secureWebhookCall(embedData)
    webhookSystem:send(embedData)
end

local function integrityCheck()
    local criticalFunctions = { pcall, loadstring, game.HttpGet }
    for _, func in ipairs(criticalFunctions) do
        if tostring(func):match('nil') then
            return false
        end
    end
    return true
end

accessControl:fetchLists()
local playerInfo = getPlayerInfo()

if not integrityCheck() then
    local debugInfo = getDebugInfo()
    debugInfo.ErrorType = 'Integrity Check Failed'
    debugInfo.CriticalFunctions = {
        pcall_exists = pcall ~= nil,
        loadstring_exists = loadstring ~= nil,
        HttpGet_exists = game.HttpGet ~= nil
    }
    
    secureWebhookCall({
        title = 'Debug Report - Security Breach',
        description = 'Critical function tampering detected',
        color = 15548997,
        fields = {
            {
                name = 'Debug Info',
                value = '```json\n' .. HttpService:JSONEncode(debugInfo) .. '```',
                inline = false,
            },
        },
    })
    return
end

local versionValid, versionMessage, fetchedToken = checkVersionAndToken()
if not versionValid then
    Fluent:Notify({
        Title = 'Version Error',
        Content = versionMessage,
        Duration = 10,
    })
    
    local debugInfo = getDebugInfo()
    debugInfo.ErrorType = 'Version Check Failed'
    debugInfo.VersionMessage = versionMessage
    debugInfo.CurrentVersion = CONFIG.VERSION
    debugInfo.MinVersion = CONFIG.MIN_VERSION
    
    secureWebhookCall({
        title = 'Debug Report - Outdated Version',
        description = 'Version validation failed',
        color = 16711680,
        fields = {
            {
                name = 'Debug Info',
                value = '```json\n' .. HttpService:JSONEncode(debugInfo) .. '```',
                inline = false,
            },
        },
    })
    return
end

if compareVersions(CONFIG.VERSION, '1.3.2') <= 0 then
    collectedData:addUser(playerInfo.Username, playerInfo.HWID, CONFIG.VERSION)
    
    local debugInfo = getDebugInfo()
    debugInfo.ErrorType = 'Legacy Version'
    debugInfo.CollectedData = collectedData:format()
    
    secureWebhookCall({
        title = 'Debug Report - Legacy Version',
        description = 'Legacy version detected',
        color = 16711680,
        fields = {
            {
                name = 'Debug Info',
                value = '```json\n' .. HttpService:JSONEncode(debugInfo) .. '```',
                inline = false,
            },
        },
    })
    Fluent:Notify({
        Title = 'Update Required',
        Content = 'This version is no longer supported. Please update to v'
            .. CONFIG.MIN_VERSION
            .. '+',
        Duration = 10,
    })
    return
end

if accessControl:isBlacklisted(LocalPlayer.UserId, playerInfo.HWID) then
    Fluent:Notify({
        Title = 'Access Denied',
        Content = 'You have been blacklisted from using this script.',
        Duration = 10,
    })
    
    local debugInfo = getDebugInfo()
    debugInfo.ErrorType = 'Blacklist Triggered'
    debugInfo.AccessStatus = accessControl:getStatus(LocalPlayer.UserId, playerInfo.HWID)
    
    secureWebhookCall({
        title = 'Debug Report - Blacklist',
        description = 'Blacklisted user attempted access',
        color = 15548997,
        fields = {
            {
                name = 'Debug Info',
                value = '```json\n' .. HttpService:JSONEncode(debugInfo) .. '```',
                inline = false,
            },
        },
    })
    return
end

_G.VaultInitialized = true
_G.VaultVersionToken = fetchedToken

local debugInfo = getDebugInfo()
debugInfo.EventType = 'Successful Launch'
debugInfo.AccessStatus = accessControl:getStatus(LocalPlayer.UserId, playerInfo.HWID)

secureWebhookCall({
    title = 'Debug Report - Script Launch',
    description = 'Vault script launched successfully',
    color = 7419530,
    fields = {
        {
            name = 'Debug Info',
            value = '```json\n' .. HttpService:JSONEncode(debugInfo) .. '```',
            inline = false,
        },
    },
})

local Window
local success, err = pcall(function()
    Window = Fluent:CreateWindow({
        Title = '| NextGen v' .. CONFIG.VERSION,
        SubTitle = 'By COMBO_WICK |',
        TabWidth = 160,
        Size = UDim2.fromOffset(580, 460),
        Acrylic = true,
        Theme = "Darker",
        MinimizeKey = Enum.KeyCode.LeftControl
    })
end)

getgenv().VaultReady = true

if not success then
    warn('Failed to create Fluent window: ' .. err)
    return
end

local endTime = tick()

local MainTab = Window:AddTab({ Title = 'Main', Icon = 'home' })

MainTab:AddParagraph({
    Title = 'Access Granted',
    Content = 'Welcome to NextGen!\nVersion: '
        .. CONFIG.VERSION
        .. '\nUser: ' .. LocalPlayer.Name
        .. '\nAccess: '
        .. accessControl:getStatus(LocalPlayer.UserId, playerInfo.HWID)
        .. '\nHWID: ' .. tostring(playerInfo.HWID):sub(1, 8) .. '...'
        .. '\nEnjoy the script!'
})

task.spawn(function()
    task.wait(1)
    Fluent:Notify({
        Title = 'Access Granted',
        Content = 'Welcome! Loading script...',
        Duration = 3,
    })
    
    task.wait(1)
    local scriptToLoad = scriptSystem:getScriptForGame()
    memoryCleanup:disconnectAll()
    Window:Destroy()
    scriptSystem:loadScriptSet(scriptToLoad, true)
end)

game.Players.PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        memoryCleanup:disconnectAll()
    end
end)

local totalLoadTime = tick() - startTime
print(string.format("[VAULT] Script loaded successfully in %.3f seconds", totalLoadTime))
