-- PlantHouseBuilder Module
-- Put this file in your GitHub repository

local PlantHouseBuilder = {}

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- Default configuration
PlantHouseBuilder.config = {
    plantShape = "none",
    houseType = "none", 
    size = 50,
    density = 20,
    centerX = 0,
    centerZ = 0,
    centerY = 0,
    tilt = 0,
    itemFilter = "sap",
    buildSpeed = 20,
    previewEnabled = true,
    skyMode = false,
    isBuilding = false,
    pendingPositions = {},
    maxZoom = 400
}

-- Initialize preview folder
local previewFolder = workspace:FindFirstChild("BuilderPreview")
if previewFolder then previewFolder:Destroy() end
previewFolder = Instance.new("Folder")
previewFolder.Name = "BuilderPreview"
previewFolder.Parent = workspace

PlantHouseBuilder.previewFolder = previewFolder
PlantHouseBuilder.connections = {}
PlantHouseBuilder.isActive = true

-- Resource tracking function
function PlantHouseBuilder.countAvailableItems(itemName)
    local count = 0
    local itemsFolder = workspace:FindFirstChild("Items")
    
    if itemsFolder then
        for _, item in pairs(itemsFolder:GetChildren()) do
            if string.find(string.lower(item.Name), string.lower(itemName)) then
                count = count + 1
            end
        end
    end
    return count
end

-- Shape definitions
PlantHouseBuilder.shapes = {
    circle = function(size, density)
        local points = {}
        for i = 0, density - 1 do
            local angle = (i / density) * 2 * math.pi
            local x = size * math.cos(angle)
            local z = size * math.sin(angle)
            table.insert(points, Vector3.new(x, 0, z))
        end
        return points
    end,
    
    square = function(size, density)
        local points = {}
        local perimeter = size * 4
        local spacing = perimeter / density
        
        for i = 0, density - 1 do
            local distance = i * spacing
            local x, z
            
            if distance <= size then
                x, z = -size/2 + distance, size/2
            elseif distance <= size * 2 then
                x, z = size/2, size/2 - (distance - size)
            elseif distance <= size * 3 then
                x, z = size/2 - (distance - size * 2), -size/2
            else
                x, z = -size/2, -size/2 + (distance - size * 3)
            end
            
            table.insert(points, Vector3.new(x, 0, z))
        end
        return points
    end,
    
    star = function(size, density)
        local points = {}
        local outerRadius = size
        local innerRadius = size * 0.4
        local numStarPoints = 5
        local totalPoints = numStarPoints * 2
        
        local starVertices = {}
        for i = 0, totalPoints - 1 do
            local angle = (i / totalPoints) * 2 * math.pi - math.pi / 2
            local isOuter = i % 2 == 0
            local radius = isOuter and outerRadius or innerRadius
            local x = radius * math.cos(angle)
            local z = radius * math.sin(angle)
            table.insert(starVertices, Vector3.new(x, 0, z))
        end
        
        local totalPerimeter = 0
        local segmentLengths = {}
        
        for i = 1, #starVertices do
            local nextI = (i % #starVertices) + 1
            local length = (starVertices[nextI] - starVertices[i]).Magnitude
            table.insert(segmentLengths, length)
            totalPerimeter = totalPerimeter + length
        end
        
        for i = 0, density - 1 do
            local targetDistance = (i / density) * totalPerimeter
            local segmentIndex = 1
            local accumulatedDistance = 0
            
            while segmentIndex <= #segmentLengths and accumulatedDistance + segmentLengths[segmentIndex] < targetDistance do
                accumulatedDistance = accumulatedDistance + segmentLengths[segmentIndex]
                segmentIndex = segmentIndex + 1
            end
            
            if segmentIndex <= #segmentLengths then
                local segmentProgress = (targetDistance - accumulatedDistance) / segmentLengths[segmentIndex]
                local startVertex = starVertices[segmentIndex]
                local endVertex = starVertices[(segmentIndex % #starVertices) + 1]
                
                local x = startVertex.X + (endVertex.X - startVertex.X) * segmentProgress
                local z = startVertex.Z + (endVertex.Z - startVertex.Z) * segmentProgress
                table.insert(points, Vector3.new(x, 0, z))
            end
        end
        
        return points
    end
}

-- House definitions
PlantHouseBuilder.houses = {
    small_house = function(size)
        local points = {}
        local doors = {}
        local stairs = {}
        local wallThickness = 2
        
        -- Ground level walls
        for x = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(x, 0, -size/2))
            table.insert(points, Vector3.new(x, 0, size/2))
        end
        for z = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(-size/2, 0, z))
            table.insert(points, Vector3.new(size/2, 0, z))
        end
        
        -- Second level walls
        for x = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(x, 6, -size/2))
            table.insert(points, Vector3.new(x, 6, size/2))
        end
        for z = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(-size/2, 6, z))
            table.insert(points, Vector3.new(size/2, 6, z))
        end
        
        -- Door opening
        doors = {
            Vector3.new(-4, 0, size/2), Vector3.new(0, 0, size/2), Vector3.new(4, 0, size/2),
            Vector3.new(-4, 6, size/2), Vector3.new(0, 6, size/2), Vector3.new(4, 6, size/2)
        }
        
        -- Simple stairs
        for i = 1, 3 do
            table.insert(stairs, Vector3.new(-size/4, (i-1) * 6, -size/4 + i * 4))
        end
        
        -- Filter out door positions
        local finalPoints = {}
        for _, wall in pairs(points) do
            local isDoor = false
            for _, door in pairs(doors) do
                if (wall - door).Magnitude < 3 then
                    isDoor = true
                    break
                end
            end
            if not isDoor then
                table.insert(finalPoints, wall)
            end
        end
        
        -- Add stairs
        for _, stair in pairs(stairs) do
            table.insert(finalPoints, stair)
        end
        
        return finalPoints
    end,
    
    large_house = function(size)
        local points = {}
        local doors = {}
        local stairs = {}
        local wallThickness = 2
        
        -- Ground level outer walls
        for x = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(x, 0, -size/2))
            table.insert(points, Vector3.new(x, 0, size/2))
        end
        for z = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(-size/2, 0, z))
            table.insert(points, Vector3.new(size/2, 0, z))
        end
        
        -- Second level walls
        for x = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(x, 6, -size/2))
            table.insert(points, Vector3.new(x, 6, size/2))
        end
        for z = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(-size/2, 6, z))
            table.insert(points, Vector3.new(size/2, 6, z))
        end
        
        -- Cross divider
        for x = -size/2 + 8, size/2 - 8, wallThickness do
            if math.abs(x) > 8 then
                table.insert(points, Vector3.new(x, 0, 0))
            end
        end
        for z = -size/2 + 8, size/2 - 8, wallThickness do
            if math.abs(z) > 8 then
                table.insert(points, Vector3.new(0, 0, z))
            end
        end
        
        doors = {
            Vector3.new(0, 0, size/2), Vector3.new(0, 6, size/2),
            Vector3.new(8, 0, 0), Vector3.new(-8, 0, 0)
        }
        
        -- L-shaped stairs
        for i = 1, 3 do
            table.insert(stairs, Vector3.new(-size/3 + i * 4, (i-1) * 6, -size/3))
        end
        
        local finalPoints = {}
        for _, wall in pairs(points) do
            local isDoor = false
            for _, door in pairs(doors) do
                if (wall - door).Magnitude < 6 then
                    isDoor = true
                    break
                end
            end
            if not isDoor then
                table.insert(finalPoints, wall)
            end
        end
        
        for _, stair in pairs(stairs) do
            table.insert(finalPoints, stair)
        end
        
        return finalPoints
    end,
    
    castle = function(size)
        local points = {}
        local doors = {}
        local stairs = {}
        local wallThickness = 2
        local castleSize = size
        
        -- Main castle walls (2 levels high)
        for x = -castleSize/2, castleSize/2, wallThickness do
            table.insert(points, Vector3.new(x, 0, -castleSize/2))
            table.insert(points, Vector3.new(x, 6, -castleSize/2))
            table.insert(points, Vector3.new(x, 0, castleSize/2))
            table.insert(points, Vector3.new(x, 6, castleSize/2))
        end
        for z = -castleSize/2, castleSize/2, wallThickness do
            table.insert(points, Vector3.new(-castleSize/2, 0, z))
            table.insert(points, Vector3.new(-castleSize/2, 6, z))
            table.insert(points, Vector3.new(castleSize/2, 0, z))
            table.insert(points, Vector3.new(castleSize/2, 6, z))
        end
        
        -- Corner towers
        local towerSize = 8
        local towerPositions = {
            {-castleSize/2, -castleSize/2}, {castleSize/2, -castleSize/2},
            {-castleSize/2, castleSize/2}, {castleSize/2, castleSize/2}
        }
        
        for _, pos in pairs(towerPositions) do
            for x = pos[1] - towerSize, pos[1] + towerSize, wallThickness do
                for z = pos[2] - towerSize, pos[2] + towerSize, wallThickness do
                    table.insert(points, Vector3.new(x, 0, z))
                    table.insert(points, Vector3.new(x, 6, z))
                    table.insert(points, Vector3.new(x, 12, z))
                end
            end
        end
        
        doors = {
            Vector3.new(0, 0, castleSize/2), Vector3.new(-8, 0, castleSize/2), Vector3.new(8, 0, castleSize/2),
            Vector3.new(0, 6, castleSize/2), Vector3.new(-8, 6, castleSize/2), Vector3.new(8, 6, castleSize/2)
        }
        
        -- Tower stairs
        for _, towerPos in pairs(towerPositions) do
            for i = 1, 5 do
                local angle = (i-1) * 0.8
                local x = towerPos[1] + 4 * math.cos(angle)
                local z = towerPos[2] + 4 * math.sin(angle)
                table.insert(stairs, Vector3.new(x, (i-1) * 6, z))
            end
        end
        
        local finalPoints = {}
        for _, wall in pairs(points) do
            local isDoor = false
            for _, door in pairs(doors) do
                if (wall - door).Magnitude < 8 then
                    isDoor = true
                    break
                end
            end
            if not isDoor then
                table.insert(finalPoints, wall)
            end
        end
        
        for _, stair in pairs(stairs) do
            table.insert(finalPoints, stair)
        end
        
        return finalPoints
    end,
    
    fortress = function(size)
        local points = {}
        local wallThickness = 2
        
        -- Main fortress outer walls
        for x = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(x, 0, -size/2))
            table.insert(points, Vector3.new(x, 6, -size/2))
            table.insert(points, Vector3.new(x, 0, size/2))
            table.insert(points, Vector3.new(x, 6, size/2))
        end
        
        for z = -size/2, size/2, wallThickness do
            table.insert(points, Vector3.new(-size/2, 0, z))
            table.insert(points, Vector3.new(-size/2, 6, z))
            table.insert(points, Vector3.new(size/2, 0, z))
            table.insert(points, Vector3.new(size/2, 6, z))
        end
        
        -- Inner defensive wall
        for x = -size/2 + 12, size/2 - 12, wallThickness do
            table.insert(points, Vector3.new(x, 0, -size/2 + 12))
            table.insert(points, Vector3.new(x, 6, -size/2 + 12))
            if math.abs(x) > 16 then
                table.insert(points, Vector3.new(x, 0, size/2 - 12))
                table.insert(points, Vector3.new(x, 6, size/2 - 12))
            end
        end
        
        for z = -size/2 + 12, size/2 - 12, wallThickness do
            table.insert(points, Vector3.new(-size/2 + 12, 0, z))
            table.insert(points, Vector3.new(-size/2 + 12, 6, z))
            table.insert(points, Vector3.new(size/2 - 12, 0, z))
            table.insert(points, Vector3.new(size/2 - 12, 6, z))
        end
        
        -- Defensive towers
        local towerPositions = {
            {-size/3, -size/3}, {size/3, -size/3},
            {-size/3, size/3}, {size/3, size/3},
            {0, -size/2}, {0, size/2}
        }
        
        for _, pos in pairs(towerPositions) do
            table.insert(points, Vector3.new(pos[1], 0, pos[2]))
            table.insert(points, Vector3.new(pos[1], 6, pos[2]))
            table.insert(points, Vector3.new(pos[1], 12, pos[2]))
        end
        
        -- Central watchtower
        table.insert(points, Vector3.new(0, 0, 0))
        table.insert(points, Vector3.new(0, 6, 0))
        table.insert(points, Vector3.new(0, 12, 0))
        table.insert(points, Vector3.new(0, 18, 0))
        
        -- Entrance stairs
        for i = 1, 3 do
            table.insert(points, Vector3.new(-8 * i, (i-1) * 6, size/2 + 8))
        end
        
        return points
    end
}

-- Utility functions
function PlantHouseBuilder.applyTilt(points, tilt)
    if tilt == 0 then return points end
    
    local tiltedPoints = {}
    local cos_t = math.cos(math.rad(tilt))
    local sin_t = math.sin(math.rad(tilt))
    
    for _, point in pairs(points) do
        local x, y, z = point.X, point.Y, point.Z
        
        local newY = y * cos_t - z * sin_t
        local newZ = y * sin_t + z * cos_t
        
        table.insert(tiltedPoints, Vector3.new(x, newY, newZ))
    end
    
    return tiltedPoints
end

function PlantHouseBuilder.createPreviewPoint(position, color)
    local part = Instance.new("Part")
    part.Name = "PreviewPoint"
    part.Size = Vector3.new(3, 12, 3)
    
    local yPos = PlantHouseBuilder.config.skyMode and 100 or 6
    part.Position = Vector3.new(
        position.X + PlantHouseBuilder.config.centerX,
        yPos + position.Y + PlantHouseBuilder.config.centerY,
        position.Z + PlantHouseBuilder.config.centerZ
    )
    
    part.Material = Enum.Material.Neon
    part.Color = color
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 0.2
    part.Parent = PlantHouseBuilder.previewFolder
    
    return part
end

function PlantHouseBuilder.updatePreview()
    if not PlantHouseBuilder.config.previewEnabled then
        for _, child in pairs(PlantHouseBuilder.previewFolder:GetChildren()) do
            child:Destroy()
        end
        return
    end
    
    PlantHouseBuilder.previewFolder:ClearAllChildren()
    
    local allPoints = {}
    
    if PlantHouseBuilder.config.plantShape ~= "none" and PlantHouseBuilder.shapes[PlantHouseBuilder.config.plantShape] then
        local points = PlantHouseBuilder.shapes[PlantHouseBuilder.config.plantShape](PlantHouseBuilder.config.size, PlantHouseBuilder.config.density)
        points = PlantHouseBuilder.applyTilt(points, PlantHouseBuilder.config.tilt)
        for _, point in pairs(points) do
            table.insert(allPoints, {point, Color3.fromRGB(255, 50, 50)})
        end
    end
    
    if PlantHouseBuilder.config.houseType ~= "none" and PlantHouseBuilder.houses[PlantHouseBuilder.config.houseType] then
        local points = PlantHouseBuilder.houses[PlantHouseBuilder.config.houseType](PlantHouseBuilder.config.size)
        points = PlantHouseBuilder.applyTilt(points, PlantHouseBuilder.config.tilt)
        for _, point in pairs(points) do
            local isStair = point.Y > 0
            local color = isStair and Color3.fromRGB(255, 150, 0) or Color3.fromRGB(255, 100, 150)
            table.insert(allPoints, {point, color})
        end
    end
    
    for _, pointData in pairs(allPoints) do
        PlantHouseBuilder.createPreviewPoint(pointData[1], pointData[2])
    end
end

function PlantHouseBuilder.buildAtPositions(points)
    if PlantHouseBuilder.config.isBuilding or not PlantHouseBuilder.isActive then return end
    
    PlantHouseBuilder.config.isBuilding = true
    PlantHouseBuilder.config.pendingPositions = {}
    
    points = PlantHouseBuilder.applyTilt(points, PlantHouseBuilder.config.tilt)
    for _, point in pairs(points) do
        local yPos = PlantHouseBuilder.config.skyMode and 100 or 0
        local finalPosition = Vector3.new(
            point.X + PlantHouseBuilder.config.centerX,
            yPos + point.Y + PlantHouseBuilder.config.centerY,
            point.Z + PlantHouseBuilder.config.centerZ
        )
        table.insert(PlantHouseBuilder.config.pendingPositions, finalPosition)
    end
    
    local function tryBuildNext()
        if #PlantHouseBuilder.config.pendingPositions == 0 or not PlantHouseBuilder.isActive then
            PlantHouseBuilder.config.isBuilding = false
            return
        end
        
        local position = table.remove(PlantHouseBuilder.config.pendingPositions, 1)
        
        local itemsFolder = workspace:FindFirstChild("Items")
        if itemsFolder then
            for _, item in pairs(itemsFolder:GetChildren()) do
                if string.find(string.lower(item.Name), string.lower(PlantHouseBuilder.config.itemFilter)) then
                    local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
                    if remoteEvents and remoteEvents:FindFirstChild("RequestPlantItem") then
                        pcall(function()
                            remoteEvents.RequestPlantItem:InvokeServer(item, position)
                        end)
                        break
                    end
                end
            end
        end
        
        task.wait(1 / PlantHouseBuilder.config.buildSpeed)
        tryBuildNext()
    end
    
    tryBuildNext()
end

function PlantHouseBuilder.cleanup()
    PlantHouseBuilder.isActive = false
    PlantHouseBuilder.config.isBuilding = false
    PlantHouseBuilder.config.pendingPositions = {}
    
    for _, connection in pairs(PlantHouseBuilder.connections) do
        connection:Disconnect()
    end
    
    if PlantHouseBuilder.previewFolder then
        PlantHouseBuilder.previewFolder:Destroy()
    end
end

return PlantHouseBuilder
