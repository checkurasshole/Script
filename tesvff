local success, Rayfield = pcall(loadstring(game:HttpGet('https://sirius.menu/rayfield')))
if not success then
    return
end
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local DataStoreService = game:GetService("DataStoreService")

local CONFIG = {
    WEBHOOK_URL = "https://discord.com/api/webhooks/1354219342840991964/kgyogYrGVoTXLoR472lDz7zM8KcKHK1EK46ss-Ppmg7tSOpUz0uYeujtrdGMD5Dfk1bw",
    KEY_URLS = {
        PASTEBIN = "https://pastebin.com/raw/VHW3Fa9s",
        GITHUB = "https://raw.githubusercontent.com/checkurasshole/Script/refs/heads/main/Tune",
        FALLBACK = "Key22Changed"
    },
    SUBSCRIPTION_URL = "https://pastebin.com/raw/ThRPn5JG",
    NEWS_URL = "https://pastebin.com/raw/vTKfsvCr",
    BLACKLIST_URL = "https://pastebin.com/raw/3h23tX2Y",
    WHITELIST_URL = "https://pastebin.com/raw/Qmp4r6es",
    HTTP_TIMEOUT = 15,  -- Increased timeout
    FEEDBACK_COOLDOWN = 4500,
    REFRESH_INTERVAL = 180,
    VERSION = "1.3.1",  -- Bumped version
    VIP_PERKS = {
        SCRIPT_BOOST = "https://raw.githubusercontent.com/checkurasshole/Script/refs/heads/main/VIP_Boost",
        EXCLUSIVE_UI = "https://pastebin.com/raw/your_exclusive_ui"
    }
}

-- Rest of your original DataStore and HTTP functions remain largely unchanged
local VaultDataStore
local function initializeDataStore()
    local success, ds = pcall(function()
        return DataStoreService:GetDataStore("VaultData_v1")
    end)
    if success then
        VaultDataStore = ds
    end
end
initializeDataStore()

local function getDataStore(key, default)
    if not VaultDataStore then return default end
    local success, data = pcall(function()
        return VaultDataStore:GetAsync(tostring(LocalPlayer.UserId) .. "_" .. key)
    end)
    return success and data or default
end

local function setDataStore(key, value)
    if VaultDataStore then
        pcall(function()
            VaultDataStore:SetAsync(tostring(LocalPlayer.UserId) .. "_" .. key, value)
        end)
    end
end

local HTTP_RATE_LIMIT = 0.5
local lastHttpRequest = 0
local function safeHttpGet(url, retries)
    retries = retries or 3
    local data, success, errorMsg
    
    for i = 1, retries do
        while (tick() - lastHttpRequest) < HTTP_RATE_LIMIT do wait(0.1) end
        lastHttpRequest = tick()
        
        local requestComplete = false
        local requestThread = coroutine.create(function()
            success, data = pcall(function()
                return game:HttpGet(url)
            end)
            if not success then
                errorMsg = data
                data = nil
            end
            requestComplete = true
        end)
        
        coroutine.resume(requestThread)
        
        local startTime = tick()
        while not requestComplete and (tick() - startTime) < CONFIG.HTTP_TIMEOUT do
            wait(0.1)
        end
        
        if requestComplete and success then
            return true, data
        end
        
        if i < retries then wait(1) end
    end
    
    return false, errorMsg or "Request timed out"
end

-- Updated keySystem with multiple sources
local keySystem = {
    key = nil,
    lastFetch = 0,
    isFetching = false,
    validKey = nil,
    
    fetch = function(self)
        if self.isFetching then return self.validKey end
        if self.key and (tick() - self.lastFetch < 300) then return self.validKey end
        
        self.isFetching = true
        Rayfield:Notify({Title = "Loading", Content = "Fetching key...", Duration = 2})
        
        -- Try each source in order
        local sources = {
            {name = "Pastebin", url = CONFIG.KEY_URLS.PASTEBIN},
            {name = "GitHub", url = CONFIG.KEY_URLS.GITHUB}
        }
        
        for _, source in ipairs(sources) do
            local success, response = safeHttpGet(source.url)
            if success and response and response ~= "" then
                self.key = response
                self.validKey = response
                self.lastFetch = tick()
                self.isFetching = false
                Rayfield:Notify({Title = "Success", Content = "Key fetched from " .. source.name, Duration = 2})
                return self.validKey
            end
        end
        
        -- Fallback if all sources fail
        self.key = CONFIG.KEY_URLS.FALLBACK
        self.validKey = CONFIG.KEY_URLS.FALLBACK
        self.lastFetch = tick()
        self.isFetching = false
        Rayfield:Notify({Title = "Warning", Content = "Using fallback key due to source failures", Duration = 3})
        return self.validKey
    end,
    
    verify = function(self, input)
        local fetchedKey = self:fetch()
        if not fetchedKey then
            Rayfield:Notify({Title = "Error", Content = "Key fetch failed, try again", Duration = 3})
            return false
        end
        local isValid = (input == fetchedKey)
        if not isValid then
            Rayfield:Notify({Title = "Invalid", Content = "Key didn't match: '" .. input .. "' vs '" .. fetchedKey .. "'", Duration = 5})
        end
        return isValid
    end
}

-- Rest of your original systems (accessControl, subscriptionSystem, etc.) remain unchanged
-- Skipping to the UI part that needs adjustment

local Window
local success, err = pcall(function()
    Window = Rayfield:CreateWindow({
        Name = "ComboChronicle Vault | NextGen v" .. CONFIG.VERSION,
        LoadingTitle = "Initializing Vault",
        LoadingSubtitle = "By COMBO_WICK | Bang.E.Line",
        Theme = "Ocean"
    })
end)
if not success then
    return
end

local KeyTab = Window:CreateTab("Key & Credits", 4483362458)
local keyInput = KeyTab:CreateInput({
    Name = "Enter Key",
    PlaceholderText = "Type the key here...",
    RemoveTextAfterFocusLost = false,
    Callback = function(input)
        Rayfield:Notify({Title = "Checking", Content = "Verifying key...", Duration = 2})
        task.wait(0.7)
        if keySystem:verify(input) then
            Rayfield:Notify({Title = "Success", Content = "Access granted!", Duration = 3})
            challengeSystem:updateProgress("login_streak")
            local gameId = game.PlaceId
            local scriptToLoad = scriptSystem:getScriptForGame(gameId)
            task.wait(1)
            Rayfield:Destroy()
            scriptSystem:loadScriptSet(scriptToLoad, true)
        else
            Rayfield:Notify({Title = "Invalid", Content = "Join Discord for key!\nCopied to clipboard", Duration = 5, Image = 4483362458})
            setclipboard("discord.com/invite/mwTHaCKzhw")
        end
    end
})

-- Rest of your UI code (other tabs) remains unchanged
