-- Complete Plant Checker Script for Rayfield
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- Modules
local ItemModule = require(ReplicatedStorage:WaitForChild("Item_Module"))
local MutationHandler = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("MutationHandler"))

local PlantChecker = {}

-- Calculate plant/fruit value
local function CalculatePlantValue(obj)
	local itemStr = obj:FindFirstChild("Item_String")
	local itemName = itemStr and itemStr.Value or obj.Name
	local variant = obj:FindFirstChild("Variant")
	local weight = obj:FindFirstChild("Weight")
	if not variant or not weight then return 0 end

	local itemData = ItemModule.Return_Data(itemName)
	if not itemData or #itemData < 3 then return 0 end

	local baseValue = itemData[3]
	local weightFactor = itemData[2]
	local variantMultiplier = ItemModule.Return_Multiplier(variant.Value)
	local mutationMultiplier = MutationHandler:CalcValueMulti(obj)
	local base = baseValue * mutationMultiplier * variantMultiplier
	local ratio = weight.Value / weightFactor
	local clamped = math.clamp(ratio, 0.95, 1e8)
	return math.round(base * clamped * clamped)
end

-- Inventory checker
local function getInventoryItems()
	local items = {}
	for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
		table.insert(items, tool)
	end
	local char = LocalPlayer.Character
	if char then
		for _, tool in ipairs(char:GetChildren()) do
			if tool:IsA("Tool") then
				table.insert(items, tool)
			end
		end
	end
	return items
end

function PlantChecker.GetInventoryValue()
	local items = getInventoryItems()
	local totalValue = 0
	local count = 0
	for _, item in ipairs(items) do
		local value = CalculatePlantValue(item)
		if value > 0 then
			totalValue += value
			count += 1
		end
	end
	return totalValue, count
end

-- Farm value checker
local function findLocalPlayerFarm()
	local farms = workspace:WaitForChild("Farm", 9e9)
	for _, farm in ipairs(farms:GetChildren()) do
		local important = farm:FindFirstChild("Important")
		if important then
			local data = important:FindFirstChild("Data")
			if data and data:FindFirstChild("Owner") and data.Owner.Value == LocalPlayer.Name then
				return farm
			end
		end
	end
	return nil
end

local function getAllFarmPlants()
	local items = {}
	local myFarm = findLocalPlayerFarm()
	if myFarm then
		local important = myFarm:FindFirstChild("Important")
		local plants = important and important:FindFirstChild("Plants_Physical")
		if plants then
			for _, plant in ipairs(plants:GetChildren()) do
				table.insert(items, plant)
			end
		end
	end
	return items
end

function PlantChecker.GetFarmValue()
	local farmPlants = getAllFarmPlants()
	local totalValue = 0
	local count = 0
	for _, plant in ipairs(farmPlants) do
		local value = CalculatePlantValue(plant)
		if value > 0 then
			totalValue += value
			count += 1
		end
	end
	return totalValue, count
end

-- Most expensive fruit checker (excluding own farm)
function PlantChecker.FindMostExpensiveFruit()
	local farmFolder = workspace:FindFirstChild("Farm")
	if not farmFolder then return nil, "Unknown", 0 end

	local highestValue = 0
	local bestFruit = nil
	local ownerName = "Unknown"

	for _, farm in pairs(farmFolder:GetChildren()) do
		local important = farm:FindFirstChild("Important")
		if important then
			local plants = important:FindFirstChild("Plants_Physical")
			local data = important:FindFirstChild("Data")
			local owner = data and data:FindFirstChild("Owner")
			local ownerVal = owner and owner.Value or "Unknown"

			-- Only check other players' farms, not your own
			if plants and ownerVal ~= LocalPlayer.Name then
				for _, plant in pairs(plants:GetChildren()) do
					local fruitsFolder = plant:FindFirstChild("Fruits")
					if fruitsFolder then
						for _, fruit in pairs(fruitsFolder:GetChildren()) do
							local val = CalculatePlantValue(fruit)
							if val > highestValue then
								highestValue = val
								bestFruit = fruit
								ownerName = ownerVal
							end
						end
					end
				end
			end
		end
	end

	return bestFruit, ownerName, highestValue
end

-- Get distance to fruit
function PlantChecker.GetDistanceToFruit(targetFruit)
	if not targetFruit or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
		return 0
	end

	local character = LocalPlayer.Character
	local humanoidRootPart = character.HumanoidRootPart
	
	local fruitPosition = nil
	for _, child in pairs(targetFruit:GetChildren()) do
		if child:IsA("BasePart") then
			fruitPosition = child.Position
			break
		end
	end
	
	if not fruitPosition then
		return 0
	end

	local playerPosition = humanoidRootPart.Position
	local distance = (fruitPosition - playerPosition).Magnitude
	
	return distance
end

-- Tracer system
local tracerPart = nil
local beam = nil
local beamAttachment1 = nil
local beamAttachment2 = nil
local selectionBox = nil

function PlantChecker.InitializeTracer()
	if tracerPart then return end -- Already initialized
	
	-- Create tracer part
	tracerPart = Instance.new("Part")
	tracerPart.Name = "FruitTracer"
	tracerPart.Material = Enum.Material.Neon
	tracerPart.BrickColor = BrickColor.new("Bright red")
	tracerPart.Anchored = true
	tracerPart.CanCollide = false
	tracerPart.TopSurface = Enum.SurfaceType.Smooth
	tracerPart.BottomSurface = Enum.SurfaceType.Smooth
	tracerPart.Transparency = 1
	tracerPart.Parent = workspace

	-- Create beam tracer
	beamAttachment1 = Instance.new("Attachment")
	beamAttachment2 = Instance.new("Attachment")
	beam = Instance.new("Beam")
	beam.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(1, 1, 0))
	beam.Width0 = 0.5
	beam.Width1 = 0.1
	beam.Transparency = NumberSequence.new(0.3)
	beam.FaceCamera = true
	beam.Attachment0 = beamAttachment1
	beam.Attachment1 = beamAttachment2
	beam.Enabled = false
	beam.Parent = workspace

	-- Create selection box
	selectionBox = Instance.new("SelectionBox")
	selectionBox.LineThickness = 0.05
	selectionBox.Color3 = Color3.new(1, 0, 0)
	selectionBox.SurfaceTransparency = 0.7
	selectionBox.Parent = workspace
end

function PlantChecker.UpdateTracer(targetFruit, tracerEnabled)
	if not tracerPart then PlantChecker.InitializeTracer() end
	
	if not tracerEnabled or not targetFruit or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
		tracerPart.Transparency = 1
		beam.Enabled = false
		selectionBox.Adornee = nil
		return
	end

	local character = LocalPlayer.Character
	local humanoidRootPart = character.HumanoidRootPart
	
	local fruitPosition = nil
	local adorneePart = nil
	for _, child in pairs(targetFruit:GetChildren()) do
		if child:IsA("BasePart") then
			fruitPosition = child.Position
			adorneePart = child
			break
		end
	end
	
	if not fruitPosition then
		tracerPart.Transparency = 1
		beam.Enabled = false
		selectionBox.Adornee = nil
		return
	end

	local playerPosition = humanoidRootPart.Position
	local direction = (fruitPosition - playerPosition)
	local distance = direction.Magnitude
	local midPoint = playerPosition + direction * 0.5

	-- Update tracer part
	tracerPart.Size = Vector3.new(0.2, 0.2, distance)
	tracerPart.CFrame = CFrame.lookAt(midPoint, fruitPosition)
	tracerPart.Transparency = 0.3

	-- Update beam
	beamAttachment1.Parent = humanoidRootPart
	beamAttachment2.WorldPosition = fruitPosition
	beam.Enabled = true

	-- Update selection box
	selectionBox.Adornee = adorneePart
end

-- Cleanup function
function PlantChecker.Cleanup()
	if tracerPart then tracerPart:Destroy() end
	if beam then beam:Destroy() end
	if selectionBox then selectionBox:Destroy() end
end

-- Cleanup when player leaves
Players.PlayerRemoving:Connect(function(player)
	if player == LocalPlayer then
		PlantChecker.Cleanup()
	end
end)

return PlantChecker
