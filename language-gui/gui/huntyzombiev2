-- COMBO_WICK Module
-- Host this at: https://raw.githubusercontent.com/yourusername/COMBO_WICK/main/Module.lua

local COMBO_WICK = {}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local ReplicatedFirst = game:GetService("ReplicatedFirst")
local TweenService = game:GetService("TweenService")

-- Variables
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Objective Automation Variables
local radioCompleted = false
local heliCompleted = false
local v2Enabled = false
local v2ObjectiveMode = "Radio + Helicopter"
local ObjectiveAutomationActive = false
local firing = false
local v2NoclipConnection = nil

-- Door System Variables
local doorActivatorEnabled = false
local teleportToDoorEnabled = false
local autoActivationConnection = nil
local v2DoorNoclipConnection = nil

-- NEW V2 DOOR SYSTEM VARIABLES
local processedDoors = {}
local MAX_DISTANCE = 300
local lastCleanupTime = tick()
local CLEANUP_INTERVAL = 30

-- Teleport Variables
local noclipEnabled = false
local noclipConnection = nil
local TeleportActive = false
local HeightOffset = 6
local teleportConnection
local TargetHead = true
local TeleportStats = {
    totalTeleports = 0,
    lastTarget = "None"
}

-- Combat Variables
local ByteNetReliable = ReplicatedStorage:WaitForChild("ByteNetReliable")
local SkillToggles = {
    ZSkill = false,
    XSkill = false,
    CSkill = false,
    VSkill = false,
    Perk = false
}
local BufferSpamActive = false
local SpamRate = 0.05
local SkillSpamRate = 0.9
local TargetMode = "All Zombies"

-- Health tracking for zombies
local currentTarget = nil
local targetHealthHistory = {}
local healthCheckTime = 0
local HEALTH_CHECK_INTERVAL = 2
local targetStartTime = 0

-- Combat Buffers
local SkillBuffers = {
    ZSkill = buffer.fromstring("\9\2\1"),
    XSkill = buffer.fromstring("\9\5\1"),
    CSkill = buffer.fromstring("\9\1\1"),
    VSkill = buffer.fromstring("\9\3\1"),
    Perk = buffer.fromstring("\14")
}
local mainAttackBuffer = buffer.fromstring("\9\6\1")

local doorCache = {}
local targetCache = {}
local CACHE_DURATION = 2

-- Item Collection Variables
local teleportToItemsEnabled = false
local AutoTeleportWasEnabledItems = false
local isTeleporting = false

-- Anti-Ragdoll System
local DefaultJoints = {
    ["Neck"] = { CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
    ["LeftShoulder"] = { CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), CFrame.new(0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0) },
    ["RightShoulder"] = { CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0), CFrame.new(-0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
    ["LeftHip"] = { CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0) },
    ["RightHip"] = { CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0), CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
    ["Root"] = { CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
    ["Waist"] = { CFrame.new(0, 0.2, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), CFrame.new(0, -0.2, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
}

local AntiRagdoll = {}
local ragdollConnections = {}
local originalJoints = {}

-- Helper Functions
function COMBO_WICK.updateCharacterReferences()
    Character = Player.Character or Player.CharacterAdded:Wait()
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end

function COMBO_WICK.isValidPosition(position)
    if not position then return false end
    if position.Y < -1000 then return false end
    if math.abs(position.X) > 10000 or math.abs(position.Z) > 10000 then return false end
    return true
end

function COMBO_WICK.CleanupMemory()
    pcall(function()
        if #targetCache > 100 then
            local toRemove = #targetCache - 50
            for i = 1, toRemove do
                table.remove(targetCache, 1)
            end
        end
        collectgarbage("step", 100)
    end)
end

function COMBO_WICK.isDoorLocked(door)
    -- Check if door is locked via CanCollide on Root
    local root = door:FindFirstChild("Root")
    if root then
        local collision = root:FindFirstChild("Collision")
        if collision and collision:IsA("BasePart") then
            return collision.CanCollide == true
        end
    end
    
    -- Fallback to attribute check
    return door:GetAttribute("locked") == true
end

function COMBO_WICK.isDoorActivated(door)
    return door:GetAttribute("activated") == true
end

function COMBO_WICK.getDoorPosition(door)
    if door:IsA("Model") then
        if door.PrimaryPart then
            return door.PrimaryPart.Position
        else
            local root = door:FindFirstChild("Root")
            if root and root:IsA("BasePart") then
                return root.Position
            else
                local part = door:FindFirstChildWhichIsA("BasePart", true)
                if part then
                    return part.Position
                end
            end
        end
    elseif door:IsA("BasePart") then
        return door.Position
    end
    return nil
end

function COMBO_WICK.getUnopenedDoorsNearby()
    local Character = Player.Character
    if not Character then return {} end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return {} end
    
    local playerPos = HumanoidRootPart.Position
    local doors = CollectionService:GetTagged("LEVELDOOR")
    local unopenedDoors = {}
    
    for _, door in pairs(doors) do
        if door and door.Parent then
            task.wait()
            
            local roomIndex = door:GetAttribute("roomIndex")
            if not roomIndex then
                task.wait(0.1)
                roomIndex = door:GetAttribute("roomIndex")
            end
            
            if roomIndex and roomIndex >= 2 then
                local doorPos = COMBO_WICK.getDoorPosition(door)
                if doorPos then
                    local distance = (playerPos - doorPos).Magnitude
                    
                    if distance <= MAX_DISTANCE then
                        if not processedDoors[door] and not COMBO_WICK.isDoorActivated(door) and not COMBO_WICK.isDoorLocked(door) then
                            table.insert(unopenedDoors, {
                                door = door, 
                                position = doorPos, 
                                distance = distance,
                                roomIndex = roomIndex
                            })
                        end
                    end
                end
            end
        end
    end
    
    table.sort(unopenedDoors, function(a, b) 
        if a.roomIndex == b.roomIndex then
            return a.distance < b.distance
        end
        return a.roomIndex < b.roomIndex
    end)
    
    return unopenedDoors
end

function COMBO_WICK.cleanupProcessedDoors()
    local toRemove = {}
    local count = 0
    
    for door, _ in pairs(processedDoors) do
        if not door or not door.Parent then
            table.insert(toRemove, door)
        end
        count = count + 1
    end
    
    for _, door in pairs(toRemove) do
        processedDoors[door] = nil
    end
    
    if count > 100 then
        local temp = {}
        local kept = 0
        for door, _ in pairs(processedDoors) do
            if kept < 50 then
                temp[door] = true
                kept = kept + 1
            end
        end
        processedDoors = temp
    end
end

function COMBO_WICK.tryActivateDoor(door)
    pcall(function()
        local activateEvent = game:GetService("ReplicatedStorage"):FindFirstChild("Packets")
        if activateEvent then
            local activateDoor = activateEvent:FindFirstChild("ActivateDoor")
            if activateDoor then
                activateDoor:FireServer(door)
            end
        end
    end)
end

function COMBO_WICK.activateAllDoors()
    if not doorActivatorEnabled then return end
    
    local GameCore = ReplicatedFirst:WaitForChild("GameCore")
    local Shared = GameCore:WaitForChild("Shared")
    local ByteNetPackets = require(Shared:WaitForChild("ByteNetPackets"))
    
    local doors = CollectionService:GetTagged("LEVELDOOR")
    local Character = Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    for i, door in pairs(doors) do
        if not doorActivatorEnabled then break end
        
        -- Skip if already activated
        if door:GetAttribute("activated") then
            continue
        end
        
        -- Check if door is locked
        if COMBO_WICK.isDoorLocked(door) then
            continue
        end
        
        -- If teleport mode is enabled, teleport to door first
        if teleportToDoorEnabled then
            local doorPosition = door:GetPivot().Position
            local teleportPos = doorPosition + Vector3.new(0, 5, 0)
            HumanoidRootPart.CFrame = CFrame.new(teleportPos)
            task.wait(0.2)
        end
        
        if not CollectionService:HasTag(door, "_doorwait") then
            CollectionService:AddTag(door, "_doorwait")
            ByteNetPackets.packets.activateDoor.send(door)
            task.wait(0.1)
        end
    end
end

function COMBO_WICK.setupAutoActivation()
    if autoActivationConnection then
        autoActivationConnection:Disconnect()
    end
    
    autoActivationConnection = CollectionService:GetInstanceAddedSignal("LEVELDOOR"):Connect(function(newDoor)
        if not doorActivatorEnabled then return end
        
        task.wait(0.5)
        
        if doorActivatorEnabled and not newDoor:GetAttribute("activated") and not newDoor:GetAttribute("locked") then
            if not CollectionService:HasTag(newDoor, "_doorwait") then
                CollectionService:AddTag(newDoor, "_doorwait")
                
                local GameCore = ReplicatedFirst:WaitForChild("GameCore")
                local Shared = GameCore:WaitForChild("Shared")
                local ByteNetPackets = require(Shared:WaitForChild("ByteNetPackets"))
                
                ByteNetPackets.packets.activateDoor.send(newDoor)
            end
        end
    end)
end

function COMBO_WICK.disableAutoActivation()
    if autoActivationConnection then
        autoActivationConnection:Disconnect()
        autoActivationConnection = nil
    end
end

function COMBO_WICK.teleportAndActivateDoors()
    local Character = Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if tick() - lastCleanupTime > CLEANUP_INTERVAL then
        COMBO_WICK.cleanupProcessedDoors()
        lastCleanupTime = tick()
    end
    
    local unopenedDoors = COMBO_WICK.getUnopenedDoorsNearby()
    if #unopenedDoors == 0 then return end
    
    for _, doorData in pairs(unopenedDoors) do
        if not teleportToDoorEnabled then break end
        
        local door = doorData.door
        local doorPosition = doorData.position
        
        if door and door.Parent and doorPosition then
            local tween1 = TweenService:Create(
                HumanoidRootPart,
                TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
                {CFrame = CFrame.new(doorPosition)}
            )
            tween1:Play()
            tween1.Completed:Wait()
            
            task.wait(0.15)
            COMBO_WICK.tryActivateDoor(door)
            task.wait(0.1)
            
            local tween2 = TweenService:Create(
                HumanoidRootPart,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
                {CFrame = CFrame.new(doorPosition + Vector3.new(5, 0, 0))}
            )
            tween2:Play()
            tween2.Completed:Wait()
            
            task.wait(0.1)
            
            local tween3 = TweenService:Create(
                HumanoidRootPart,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
                {CFrame = CFrame.new(doorPosition - Vector3.new(5, 0, 0))}
            )
            tween3:Play()
            tween3.Completed:Wait()
            
            task.wait(0.15)
            
            processedDoors[door] = true
        end
    end
end

function COMBO_WICK.enableNoclip()
    if noclipConnection then return end
    noclipConnection = RunService.Stepped:Connect(function()
        local character = Player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

function COMBO_WICK.disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    local character = Player.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

function COMBO_WICK.enableV2Noclip()
    if v2NoclipConnection then return end
    v2NoclipConnection = RunService.Stepped:Connect(function()
        local character = Player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

function COMBO_WICK.disableV2Noclip()
    if v2NoclipConnection then
        v2NoclipConnection:Disconnect()
        v2NoclipConnection = nil
    end
    local character = Player.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

function COMBO_WICK.enableV2DoorNoclip()
    if v2DoorNoclipConnection then return end
    v2DoorNoclipConnection = RunService.Stepped:Connect(function()
        local character = Player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

function COMBO_WICK.disableV2DoorNoclip()
    if v2DoorNoclipConnection then
        v2DoorNoclipConnection:Disconnect()
        v2DoorNoclipConnection = nil
    end
    local character = Player.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

function COMBO_WICK.toggleNoclip(enabled)
    noclipEnabled = enabled
    
    if noclipEnabled then
        noclipConnection = RunService.Stepped:Connect(function()
            local character = Player.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        
        local character = Player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- Anti-Ragdoll Functions
function AntiRagdoll.RestoreJoint(joint)
    if not joint or not joint.Parent then return end
    
    local jointName = joint.Name
    local jointData = DefaultJoints[jointName]
    
    if jointData and joint:IsA("Motor6D") then
        joint.C0 = jointData[1]
        joint.C1 = jointData[2]
        joint.Enabled = true
        
        if joint.Part0 and joint.Part1 then
            joint.Part0.Anchored = false
            joint.Part1.Anchored = false
            joint.Part0.CanCollide = false
            joint.Part1.CanCollide = false
        end
    end
end

function AntiRagdoll.RestoreCharacter(character)
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
        humanoid.Sit = false
        humanoid:ChangeState(Enum.HumanoidStateType.Running)
        
        if humanoid.Health <= 0 then
            humanoid.Health = humanoid.MaxHealth
        end
    end
    
    for _, joint in pairs(character:GetDescendants()) do
        if joint:IsA("Motor6D") then
            AntiRagdoll.RestoreJoint(joint)
        end
    end
    
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.Anchored = false
            part.CanCollide = false
            
            for _, constraint in pairs(part:GetChildren()) do
                if constraint:IsA("BallSocketConstraint") or 
                   constraint:IsA("HingeConstraint") or 
                   constraint:IsA("RodConstraint") or
                   constraint:IsA("UniversalConstraint") then
                    constraint:Destroy()
                end
            end
        end
    end
end

function AntiRagdoll.MonitorCharacter(character)
    if not character then return end
    
    for _, joint in pairs(character:GetDescendants()) do
        if joint:IsA("Motor6D") then
            originalJoints[joint] = {
                C0 = joint.C0,
                C1 = joint.C1,
                Enabled = joint.Enabled
            }
        end
    end
    
    local function checkRagdoll()
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid and (humanoid.PlatformStand or humanoid:GetState() == Enum.HumanoidStateType.Physics) then
            AntiRagdoll.RestoreCharacter(character)
        end
        
        for _, joint in pairs(character:GetDescendants()) do
            if joint:IsA("Motor6D") and originalJoints[joint] then
                if not joint.Enabled or joint.Parent == nil then
                    AntiRagdoll.RestoreJoint(joint)
                end
            end
        end
    end
    
    ragdollConnections[#ragdollConnections + 1] = RunService.Heartbeat:Connect(checkRagdoll)
    
    ragdollConnections[#ragdollConnections + 1] = character.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Motor6D") then
            originalJoints[descendant] = {
                C0 = descendant.C0,
                C1 = descendant.C1,
                Enabled = descendant.Enabled
            }
        end
    end)
    
    ragdollConnections[#ragdollConnections + 1] = character.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Motor6D") then
            task.wait()
            AntiRagdoll.RestoreCharacter(character)
        end
    end)
end

function AntiRagdoll.Start()
    local function onCharacterAdded(character)
        character:WaitForChild("Humanoid")
        character:WaitForChild("HumanoidRootPart")
        
        task.wait(1)
        
        AntiRagdoll.MonitorCharacter(character)
    end
    
    if Player.Character then
        onCharacterAdded(Player.Character)
    end
    
    Player.CharacterAdded:Connect(onCharacterAdded)
end

-- Auto-redeem codes
function COMBO_WICK.redeemCodes()
    local codes = {
        "200KLIKES",
        "Hugecode",
        "WDEV1",
        "WDEV2",
        "ALMOSTCHRISTMASEVE",
        "ALMOSTCHRISTMASEVE2",
        "ALMOSTCHRISTMASEVE3",
        "ALMOSTCHRISTMASEVE4",
        "WEAREBACK",
        "WEAREBACK2",
        "WEAREBACK3",
        "WEAREBACK4",
        "KRAMPUS",
        "JINGLEBELLS"
    }
    
    task.spawn(function()
        task.wait(2) -- Wait for game to fully load
        
        local success, packetsFolder = pcall(function()
            return game:GetService("ReplicatedStorage"):WaitForChild("Packets", 5)
        end)
        
        if success and packetsFolder then
            local redeemCode = packetsFolder:FindFirstChild("RedeemCode")
            
            if redeemCode then
                for _, code in ipairs(codes) do
                    task.spawn(function()
                        pcall(function()
                            local args = {code}
                            redeemCode:InvokeServer(unpack(args))
                        end)
                    end)
                    task.wait(0.5)
                end
            else
                warn("RedeemCode remote not found in Packets folder")
            end
        else
            warn("Packets folder not found in ReplicatedStorage - skipping code redemption")
        end
    end)
end

-- Combat Functions
function COMBO_WICK.IsMobAlive(entity)
    if not entity or not entity.Parent then
        return false
    end
    
    local head = entity:FindFirstChild("Head")
    if not head then return false end
    
    local entityHealth = head:FindFirstChild("EntityHealth")
    if not entityHealth then return false end
    
    local healthBar = entityHealth:FindFirstChild("HealthBar")
    if not healthBar then return false end
    
    local bar = healthBar:FindFirstChild("Bar")
    if not bar then return false end
    
    if bar:IsA("Frame") and bar.Size.X.Scale <= 0.01 then
        return false
    end
    
    if bar:IsA("Frame") and bar.BackgroundColor3 == Color3.fromRGB(255, 0, 0) and bar.Size.X.Scale <= 0.1 then
        return false
    end
    
    return true
end

function COMBO_WICK.GetEntityHealth(entity)
    if not entity or not entity.Parent then
        return nil
    end
    
    local head = entity:FindFirstChild("Head")
    if not head then return nil end
    
    local entityHealth = head:FindFirstChild("EntityHealth")
    if not entityHealth then return nil end
    
    local healthBar = entityHealth:FindFirstChild("HealthBar")
    if not healthBar then return nil end
    
    local bar = healthBar:FindFirstChild("Bar")
    if not bar or not bar:IsA("Frame") then return nil end
    
    -- Return health as percentage (0 to 1)
    return bar.Size.X.Scale
end

function COMBO_WICK.IsTargetTakingDamage(entity)
    if not entity or not entity.Parent then
        return false
    end
    
    local currentTime = tick()
    
    -- Get current health
    local currentHealth = COMBO_WICK.GetEntityHealth(entity)
    if not currentHealth then
        return false
    end
    
    -- If this is a new target, initialize tracking
    if currentTarget ~= entity then
        currentTarget = entity
        targetHealthHistory = {currentHealth}
        targetStartTime = currentTime
        healthCheckTime = currentTime
        return true  -- Give new targets a chance
    end
    
    -- Check if enough time has passed for health check
    if currentTime - healthCheckTime >= HEALTH_CHECK_INTERVAL then
        -- Store current health
        table.insert(targetHealthHistory, currentHealth)
        
        -- Keep only last 3 health readings
        if #targetHealthHistory > 3 then
            table.remove(targetHealthHistory, 1)
        end
        
        healthCheckTime = currentTime
        
        -- If we've been attacking for more than HEALTH_CHECK_INTERVAL seconds
        if currentTime - targetStartTime >= HEALTH_CHECK_INTERVAL then
            -- Check if health has decreased
            if #targetHealthHistory >= 2 then
                local oldHealth = targetHealthHistory[1]
                local newHealth = targetHealthHistory[#targetHealthHistory]
                
                -- If health hasn't decreased by at least 0.01 (1%), target is not taking damage
                if oldHealth - newHealth < 0.01 then
                    -- Reset target so we move to next one
                    currentTarget = nil
                    targetHealthHistory = {}
                    return false
                end
            end
        end
    end
    
    return true
end

function COMBO_WICK.GetBestMobTarget()
    local Character = Player.Character
    if not Character then return nil end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return nil end
    
    local entitiesFolder = workspace:FindFirstChild("Entities")
    if not entitiesFolder then return nil end
    
    local validTargets = {}
    local playerPos = HumanoidRootPart.Position
    
    local targetParts = TargetHead and {"Head", "Torso", "HumanoidRootPart"} or {"Left Leg", "Right Leg", "Torso", "HumanoidRootPart"}
    
    local function processEntity(entity)
        if entity.Name ~= "Entities" and entity ~= Character and entity.Name ~= "Highlight" then
            if not COMBO_WICK.IsMobAlive(entity) then
                return
            end
            
            -- Skip if this is the current target and it's not taking damage
            if currentTarget == entity and not COMBO_WICK.IsTargetTakingDamage(entity) then
                return
            end
            
            -- Check for Boss-Only mode
            if TargetMode == "Boss Only" then
                local entityID = entity:GetAttribute("EntityID")
                if entityID ~= 8 then
                    return -- Skip non-boss entities
                end
            end
            
            for _, partName in ipairs(targetParts) do
                local targetPart = entity:FindFirstChild(partName)
                if targetPart and targetPart:IsA("BasePart") then
                    local distance = (targetPart.Position - playerPos).Magnitude
                    
                    if distance <= 500 then
                        local targetPos = targetPart.Position
                        
                        if not COMBO_WICK.isValidPosition(targetPos) then
                            return
                        end
                        
                        local target = {
                            part = targetPart,
                            entity = entity,
                            distance = distance,
                            partName = partName,
                            position = targetPos
                        }
                        
                        table.insert(validTargets, target)
                    end
                    break
                end
            end
        end
    end
    
    for _, entity in pairs(entitiesFolder:GetChildren()) do
        processEntity(entity)
    end
    
    for _, folder in pairs(entitiesFolder:GetChildren()) do
        if folder:IsA("Folder") or folder:IsA("Model") then
            if folder.Name ~= "Highlight" then
                for _, numberedFolder in pairs(folder:GetChildren()) do
                    if numberedFolder:IsA("Model") or numberedFolder:IsA("Folder") then
                        processEntity(numberedFolder)
                    end
                end
            end
        end
    end
    
    table.sort(validTargets, function(a, b) return a.distance < b.distance end)
    
    if #validTargets >0 then
        local bestTarget = validTargets[1]
        TeleportStats.lastTarget = bestTarget.entity.Name
        return bestTarget.position
    end
    
    return nil
end

function COMBO_WICK.TeleportToMob()
    local Character = Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    local targetPosition = COMBO_WICK.GetBestMobTarget()
    if not targetPosition then return end
    
    local finalPosition = targetPosition + Vector3.new(0, HeightOffset, 0)
    
    if not COMBO_WICK.isValidPosition(finalPosition) then
        return
    end
    
    local currentPos = HumanoidRootPart.Position
    local distance = (currentPos - finalPosition).Magnitude
    
    if distance > 1000 then
        return
    end
    
    HumanoidRootPart.CFrame = CFrame.new(finalPosition)
    
    TeleportStats.totalTeleports = TeleportStats.totalTeleports + 1
    
    COMBO_WICK.CleanupMemory()
end

-- Item Collection Functions
function COMBO_WICK.getItemPosition(item)
    if not item or not item.Parent then
        return nil
    end
    
    local targetPosition = nil
    
    if item:IsA("BasePart") and item.Position then
        targetPosition = item.Position
    elseif item:IsA("Model") then
        local primaryPart = item.PrimaryPart or item:FindFirstChild("HumanoidRootPart")
        if primaryPart and primaryPart.Position then
            targetPosition = primaryPart.Position
        else
            local part = item:FindFirstChildWhichIsA("BasePart")
            if part and part.Position then
                targetPosition = part.Position
            end
        end
    elseif item:FindFirstChildWhichIsA("BasePart") then
        local part = item:FindFirstChildWhichIsA("BasePart")
        if part and part.Position then
            targetPosition = part.Position
        end
    end
    
    return targetPosition
end

function COMBO_WICK.teleportToItems()
    if not teleportToItemsEnabled then return end
    
    local character = Player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local humanoidRootPart = character.HumanoidRootPart
    local dropItems = workspace:FindFirstChild("DropItems")
    
    if not dropItems then
        return
    end
    
    -- Store player's current position as a failsafe
    local originalPosition = humanoidRootPart.CFrame
    
    local validItems = {}
    local items = dropItems:GetChildren()
    
    for _, item in pairs(items) do
        local position = COMBO_WICK.getItemPosition(item)
        if position and COMBO_WICK.isValidPosition(position) then
            -- Additional validation: check distance from player
            local distance = (humanoidRootPart.Position - position).Magnitude
            
            -- Only collect items within reasonable distance (500 studs)
            if distance < 500 then
                table.insert(validItems, {
                    item = item,
                    position = position,
                    distance = distance,
                    name = item.Name or "Unknown"
                })
            end
        end
    end
    
    -- Sort by distance (closest first)
    table.sort(validItems, function(a, b) return a.distance < b.distance end)
    
    local itemCount = #validItems
    
    if itemCount == 0 then
        return false
    end
    
    isTeleporting = true
    
    for i, itemData in pairs(validItems) do
        if not teleportToItemsEnabled then break end -- Allow stopping mid-collection
        
        if itemData.item and itemData.item.Parent then
            local currentPosition = COMBO_WICK.getItemPosition(itemData.item)
            
            -- Validate position again before teleporting
            if currentPosition and COMBO_WICK.isValidPosition(currentPosition) then
                -- Check if position is within reasonable bounds
                local distanceFromOriginal = (originalPosition.Position - currentPosition).Magnitude
                
                if distanceFromOriginal < 1000 then -- Don't teleport more than 1000 studs away
                    -- Teleport with pcall for safety
                    pcall(function()
                        -- First teleport: Go above the item
                        local safeHeight = math.max(currentPosition.Y + 10, 50)
                        local teleportPosition = Vector3.new(currentPosition.X, safeHeight, currentPosition.Z)
                        
                        -- Validate the teleport position
                        if COMBO_WICK.isValidPosition(teleportPosition) then
                            humanoidRootPart.CFrame = CFrame.new(teleportPosition)
                            task.wait(0.05)
                            
                            -- Second teleport: Go to the item
                            local finalPosition = Vector3.new(currentPosition.X, currentPosition.Y + 5, currentPosition.Z)
                            
                            if COMBO_WICK.isValidPosition(finalPosition) then
                                humanoidRootPart.CFrame = CFrame.new(finalPosition)
                                task.wait(0.15)
                            end
                        end
                    end)
                else
                    -- If item is too far, skip it
                    warn("Item too far away, skipping: " .. itemData.name)
                end
            end
        end
    end
    
    -- Failsafe: If character ends up in a weird position, teleport back
    pcall(function()
        local currentPos = humanoidRootPart.Position
        if not COMBO_WICK.isValidPosition(currentPos) or currentPos.Y < -500 then
            humanoidRootPart.CFrame = originalPosition
            warn("Teleported back to original position (failsafe)")
        end
    end)
    
    isTeleporting = false
    return true
end

-- Infinite Jump Setup
function COMBO_WICK.setupInfiniteJump()
    local function enableInfiniteJump()
        local character = Player.Character
        if not character then return end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        local connection
        connection = UserInputService.JumpRequest:Connect(function()
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
        
        character.AncestryChanged:Connect(function()
            if not character.Parent then
                connection:Disconnect()
            end
        end)
    end
    
    if Player.Character then
        enableInfiniteJump()
    end
    
    Player.CharacterAdded:Connect(enableInfiniteJump)
end

-- Objective Automation Functions
function COMBO_WICK.findHeliPrompt()
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj.Name == "HeliObjective" then
            local prompt = obj:FindFirstChild("ProximityPrompt")
            if prompt then
                return obj, prompt
            end
        end
    end
    return nil, nil
end

function COMBO_WICK.completeHeliObjective()
    wait(5.5)
    
    -- Update character references
    COMBO_WICK.updateCharacterReferences()
    local character = Player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local heliObj, prompt = COMBO_WICK.findHeliPrompt()
    if heliObj and prompt then
        humanoidRootPart.CFrame = heliObj.CFrame + Vector3.new(0, 5, 0)
        wait(1)
        
        prompt.Enabled = true
        prompt.HoldDuration = 0
        prompt.RequiresLineOfSight = false
        prompt.MaxActivationDistance = 1000
        
        for i = 1, 15 do
            pcall(function()
                prompt:InputHoldBegin()
                task.wait(0.05)
                prompt:InputHoldEnd()
            end)
            
            pcall(function()
                fireproximityprompt(prompt)
            end)
            
            pcall(function()
                for _, triggerConnection in pairs(getconnections(prompt.Triggered)) do
                    triggerConnection:Fire()
                end
            end)
            
            wait(0.2)
        end
    end
end

function COMBO_WICK.completeRadioObjective(radio)
    if radioCompleted then return end
    radioCompleted = true
    
    -- PAUSE ALL AUTOMATION
    COMBO_WICK.pauseAllAutomation()
    
    wait(5)
    
    -- Update character references properly
    COMBO_WICK.updateCharacterReferences()
    local character = Player.Character
    if not character then
        radioCompleted = false
        COMBO_WICK.resumeAllAutomation()
        return
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        radioCompleted = false
        COMBO_WICK.resumeAllAutomation()
        return
    end
    
    -- Enable noclip for V2
    COMBO_WICK.enableV2Noclip()
    
    -- Teleport to radio
    humanoidRootPart.CFrame = radio.CFrame + Vector3.new(0, 3, 0)
    wait(1)
    
    local proximityPrompt = radio:FindFirstChild("ProximityPrompt")
    if not proximityPrompt then
        -- Search in descendants if not found as direct child
        for _, child in pairs(radio:GetDescendants()) do
            if child:IsA("ProximityPrompt") then
                proximityPrompt = child
                break
            end
        end
    end
    
    if proximityPrompt then
        proximityPrompt.Enabled = true
        proximityPrompt.HoldDuration = 0
        proximityPrompt.RequiresLineOfSight = false
        proximityPrompt.MaxActivationDistance = 1000
        
        -- Aggressive activation loop - 15 attempts
        for i = 1, 15 do
            -- Teleport again each time to ensure we're close
            humanoidRootPart.CFrame = radio.CFrame + Vector3.new(0, 3, 0)
            wait(0.1)
            
            pcall(function()
                proximityPrompt:InputHoldBegin()
                task.wait(0.05)
                proximityPrompt:InputHoldEnd()
            end)
            
            pcall(function()
                fireproximityprompt(proximityPrompt)
            end)
            
            pcall(function()
                for _, triggerConnection in pairs(getconnections(proximityPrompt.Triggered)) do
                    triggerConnection:Fire()
                end
            end)
            
            wait(0.3)
        end
        
        wait(2)
        
        -- Move up after activating radio
        local currentPosition = humanoidRootPart.CFrame
        humanoidRootPart.CFrame = currentPosition + Vector3.new(0, 8, 0)
        
        wait(3)
        
        wait(3)

        -- Complete helicopter objectives ONLY if mode is "Radio + Helicopter"
        if v2ObjectiveMode == "Radio + Helicopter" then
            task.spawn(function()
                for i = 1, 8 do
                    heliCompleted = false
                    COMBO_WICK.completeHeliObjective()
                    wait(i % 2 == 0 and 3 or 1)
                end
                
                -- Disable V2 noclip after completion
                COMBO_WICK.disableV2Noclip()
                
                -- RESUME ALL AUTOMATION AFTER COMPLETION
                wait(2)
                COMBO_WICK.resumeAllAutomation()
            end)
        else
            -- If Radio Only mode, just resume without doing helicopter
            wait(2)
            COMBO_WICK.disableV2Noclip()
            COMBO_WICK.resumeAllAutomation()
        end
    end
end

function COMBO_WICK.onDescendantAdded(descendant)
    if not v2Enabled then return end
    
    if descendant.Name == "RadioObjective" and not radioCompleted then
        task.spawn(COMBO_WICK.completeRadioObjective, descendant)
    end
end

function COMBO_WICK.checkExistingRadio()
    if not v2Enabled then return end
    
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj.Name == "RadioObjective" and not radioCompleted then
            task.spawn(COMB O_WICK.completeRadioObjective, obj)
            break
        end
    end
end

function COMBO_WICK.waitForCharacter()
    local character = Player.Character or Player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 10)
    return character, humanoidRootPart
end

function COMBO_WICK.teleportToObjective(target)
    if not target then return end
    
    local targetPosition
    if target:IsA("BasePart") then
        targetPosition = target.CFrame
    elseif target:IsA("Model") then
        local primaryPart = target.PrimaryPart
        if not primaryPart then
            for _, child in pairs(target:GetChildren()) do
                if child:IsA("BasePart") then
                    primaryPart = child
                    break
                end
            end
        end
        if primaryPart then
            targetPosition = primaryPart.CFrame
        end
    end
    
    if targetPosition then
        local Character = Player.Character
        if Character and Character:FindFirstChild("HumanoidRootPart") then
            Character.HumanoidRootPart.CFrame = targetPosition
        end
    end
end

function COMBO_WICK.getNearestPrompt()
    local Character = Player.Character
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then return nil end
    local HumanoidRootPart = Character.HumanoidRootPart
    
    local nearestPrompt = nil
    local shortestDistance = math.huge
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("ProximityPrompt") and descendant.Enabled then
            local promptPart = descendant.Parent:IsA("BasePart") and descendant.Parent
            if promptPart then
                local distance = (HumanoidRootPart.Position - promptPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestPrompt = descendant
                end
            end
        end
    end
    return nearestPrompt
end

function COMBO_WICK.activatePrompt(prompt, targetObject, maxRetries)
    if not prompt or not prompt:IsA("ProximityPrompt") then return end
    
    maxRetries = maxRetries or 10
    local attempts = 0
    local wasTriggered = false
    
    local connection
    connection = prompt.Triggered:Connect(function()
        wasTriggered = true
        if connection then connection:Disconnect() end
    end)
    
    local function attemptActivation()
        attempts = attempts + 1
        
        COMBO_WICK.teleportToObjective(targetObject)
        task.wait(0.3)
        
        prompt.HoldDuration = 0
        prompt.Enabled = true
        prompt.RequiresLineOfSight = false
        prompt.MaxActivationDistance = 1000
        
        pcall(function()
            prompt:InputHoldBegin()
            task.wait(0.1)
            prompt:InputHoldEnd()
        end)
        
        task.wait(0.2)
        
        pcall(function()
            fireproximityprompt(prompt)
        end)
        
        task.wait(0.2)
        
        pcall(function()
            for _, triggerConnection in pairs(getconnections(prompt.Triggered)) do
                triggerConnection:Fire()
            end
        end)
        
        task.wait(0.2)
        
        pcall(function()
            prompt.TriggerEnded:Fire()
        end)
        
        task.wait(0.5)
        
        if not wasTriggered and (targetObject.Name == "jarst_radio" or targetObject.Name == "RadioObjective") then
            local autoFireAttempts = 0
            local maxAutoFireAttempts = 20
            
            while not wasTriggered and autoFireAttempts < maxAutoFireAttempts do
                autoFireAttempts = autoFireAttempts + 1
                
                if not firing then
                    firing = true
                    
                    local nearestPrompt = COMBO_WICK.getNearestPrompt()
                    if nearestPrompt and nearestPrompt == prompt then
                        pcall(function()
                            fireproximityprompt(nearestPrompt)
                        end)
                        
                        task.wait(0.3)
                        
                        pcall(function()
                            nearestPrompt:InputHoldBegin()
                            task.wait(0.1)
                            nearestPrompt:InputHoldEnd()
                        end)
                        
                        task.wait(0.2)
                        
                        for i = 1, 3 do
                            pcall(function()
                                fireproximityprompt(nearestPrompt)
                            end)
                            task.wait(0.1)
                        end
                    end
                    
                    firing = false
                    task.wait(0.2)
                end
                
                if wasTriggered then break end
            end
        end
        
        task.wait(0.5)
        
        if not wasTriggered and attempts < maxRetries then
            task.wait(1)
            attemptActivation()
        elseif not wasTriggered then
            if connection then connection:Disconnect() end
        end
    end
    
    attemptActivation()
end

function COMBO_WICK.setupGlobalListener(parent)
    parent.DescendantAdded:Connect(function(descendant)
        if not ObjectiveAutomationActive then return end
        
        task.wait(0.1)
        
        if descendant.Name == "generator" then
            -- PAUSE ALL AUTOMATION
            COMBO_WICK.pauseAllAutomation()
            COMBO_WICK.enableNoclip()

            task.wait(5)
            COMBO_WICK.updateCharacterReferences()
            
            COMBO_WICK.teleportToObjective(descendant)
            task.wait(0.5)
            
            local prompt = descendant:FindFirstChildOfClass("ProximityPrompt")
            if not prompt then
                for _, child in pairs(descendant:GetDescendants()) do
                    if child:IsA("ProximityPrompt") then
                        prompt = child
                        break
                    end
                end
            end
            
            if prompt then
                COMBO_WICK.activatePrompt(prompt, descendant)
            end
            
            wait(2)
            COMBO_WICK.disableNoclip()
            COMBO_WICK.resumeAllAutomation()
        end
    end)
end

function COMBO_WICK.checkExistingV1()
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant.Name == "generator" then
            -- PAUSE ALL AUTOMATION
            COMBO_WICK.pauseAllAutomation()
            -- FIX: Enable noclip for this objective
            COMBO_WICK.enableNoclip()

            task.wait(5)
            COMBO_WICK.updateCharacterReferences()
            
            COMBO_WICK.teleportToObjective(descendant)
            task.wait(0.5)
            
            local prompt = descendant:FindFirstChildOfClass("ProximityPrompt")
            if not prompt then
                for _, child in pairs(descendant:GetDescendants()) do
                    if child:IsA("ProximityPrompt") then
                        prompt = child
                        break
                    end
                end
            end
            
            if prompt then
                COMBO_WICK.activatePrompt(prompt, descendant)
            end
            
            -- RESUME AFTER COMPLETION
            wait(2)
            -- FIX: Disable noclip after completion
            COMBO_WICK.disableNoclip()
            COMBO_WICK.resumeAllAutomation()
        end
    end
end

-- Pause/Resume System
function COMBO_WICK.pauseAllAutomation()
    -- Disable all automation without saving state
    if TeleportActive then
        TeleportActive = false
        if teleportConnection then
            teleportConnection:Disconnect()
            teleportConnection = nil
        end
    end
    
    teleportToItemsEnabled = false
    
    if doorActivatorEnabled then
        doorActivatorEnabled = false
        COMBO_WICK.disableAutoActivation()
    end
    
    if teleportToDoorEnabled then
        teleportToDoorEnabled = false
        COMBO_WICK.disableV2DoorNoclip()
    end
end

function COMBO_WICK.resumeAllAutomation()
    -- Restart loops based on the current state of the UI toggles
    -- This will be called from the main script with the current toggle states
end

-- Expose functions to be used by the main script
COMBO_WICK.AntiRagdoll = AntiRagdoll
COMBO_WICK.SkillToggles = SkillToggles
COMBO_WICK.SkillBuffers = SkillBuffers
COMBO_WICK.mainAttackBuffer = mainAttackBuffer
COMBO_WICK.SpamRate = SpamRate
COMBO_WICK.SkillSpamRate = SkillSpamRate
COMBO_WICK.TargetMode = TargetMode
COMBO_WICK.TargetHead = TargetHead
COMBO_WICK.HeightOffset = HeightOffset
COMBO_WICK.TeleportActive = TeleportActive
COMBO_WICK.teleportToItemsEnabled = teleportToItemsEnabled
COMBO_WICK.doorActivatorEnabled = doorActivatorEnabled
COMBO_WICK.teleportToDoorEnabled = teleportToDoorEnabled
COMBO_WICK.v2Enabled = v2Enabled
COMBO_WICK.v2ObjectiveMode = v2ObjectiveMode
COMBO_WICK.ObjectiveAutomationActive = ObjectiveAutomationActive
COMBO_WICK.BufferSpamActive = BufferSpamActive
COMBO_WICK.teleportConnection = teleportConnection

-- Expose functions
COMBO_WICK.updateCharacterReferences = updateCharacterReferences
COMBO_WICK.isValidPosition = isValidPosition
COMBO_WICK.CleanupMemory = CleanupMemory
COMBO_WICK.isDoorLocked = isDoorLocked
COMBO_WICK.isDoorActivated = isDoorActivated
COMBO_WICK.getDoorPosition = getDoorPosition
COMBO_WICK.getUnopenedDoorsNearby = getUnopenedDoorsNearby
COMBO_WICK.cleanupProcessedDoors = cleanupProcessedDoors
COMBO_WICK.tryActivateDoor = tryActivateDoor
COMBO_WICK.activateAllDoors = activateAllDoors
COMBO_WICK.setupAutoActivation = setupAutoActivation
COMBO_WICK.disableAutoActivation = disableAutoActivation
COMBO_WICK.teleportAndActivateDoors = teleportAndActivateDoors
COMBO_WICK.enableNoclip = enableNoclip
COMBO_WICK.disableNoclip = disableNoclip
COMBO_WICK.enableV2Noclip = enableV2Noclip
COMBO_WICK.disableV2Noclip = disableV2Noclip
COMBO_WICK.enableV2DoorNoclip = enableV2DoorNoclip
COMBO_WICK.disableV2DoorNoclip = disableV2DoorNoclip
COMBO_WICK.toggleNoclip = toggleNoclip
COMBO_WICK.redeemCodes = redeemCodes
COMBO_WICK.IsMobAlive = IsMobAlive
COMBO_WICK.GetEntityHealth = GetEntityHealth
COMBO_WICK.IsTargetTakingDamage = IsTargetTakingDamage
COMBO_WICK.GetBestMobTarget = GetBestMobTarget
COMBO_WICK.TeleportToMob = TeleportToMob
COMBO_WICK.getItemPosition = getItemPosition
COMBO_WICK.teleportToItems = teleportToItems
COMBO_WICK.setupInfiniteJump = setupInfiniteJump
COMBO_WICK.findHeliPrompt = findHeliPrompt
COMBO_WICK.completeHeliObjective = completeHeliObjective
COMBO_WICK.completeRadioObjective = completeRadioObjective
COMBO_WICK.onDescendantAdded = onDescendantAdded
COMBO_WICK.checkExistingRadio = checkExistingRadio
COMBO_WICK.waitForCharacter = waitForCharacter
COMBO_WICK.teleportToObjective = teleportToObjective
COMBO_WICK.getNearestPrompt = getNearestPrompt
COMBO_WICK.activatePrompt = activatePrompt
COMBO_WICK.setupGlobalListener = setupGlobalListener
COMBO_WICK.checkExistingV1 = checkExistingV1
COMBO_WICK.pauseAllAutomation = pauseAllAutomation
COMBO_WICK.resumeAllAutomation = resumeAllAutomation

return COMBO_WICK
